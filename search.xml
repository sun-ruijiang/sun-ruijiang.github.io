<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo写作——我的第一篇博客</title>
    <url>/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>大体上建好了网站，现在我们来学习一下如何在<code>hexo</code>上写作，并同步你的第一篇文章到GitHub上</p>
</blockquote>
<h2 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h2><h3 id="创建一篇博客"><a href="#创建一篇博客" class="headerlink" title="创建一篇博客"></a>创建一篇博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;My New Post&gt;</span><br></pre></td></tr></table></figure>

<p>如果不想使用命令行，直接在<code>source/_post</code>文件夹创建即可</p>
<p>需要注意的是，在文件编写的开头需要加上，<code>title</code>、<code>date</code>、<code>tag</code>、<code>category</code>、<code>author</code>、<code>Topping</code>这几个信息</p>
<h3 id="打开hexo服务器"><a href="#打开hexo服务器" class="headerlink" title="打开hexo服务器"></a>打开<code>hexo</code>服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>打开一个shell，输入这行命令</p>
<p>这是为了在本地观察渲染后的博客网站，显示一个<code>http://localhost:4000</code>网址，可以再这里观察网站变化</p>
<h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure>

<p>打开另一个shell，输入命令·</p>
<p>如果不输入这行命令，网页是不会变化的，需要不断重复打开</p>
<p>输入命令后，我们可以刷新网页以更新变化，也可以在shell中看到网站的改变</p>
<h3 id="部署到GitHub仓库"><a href="#部署到GitHub仓库" class="headerlink" title="部署到GitHub仓库"></a>部署到GitHub仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署命令·，可能出错，如果出现<code>SSL Connection</code>错误，就是因为网络不好</p>
<p>再次输入部署命令就好了</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法——双机调度问题</title>
    <url>/2021/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>用2台处理机<code>A</code>和<code>B</code>处理<code>n</code>个作业。设第<code>i</code>个作业交给机器A处理时需要时间<code>ai</code>，若由机器<code>B</code>来处理,则需要时间bi。</p>
<p>由于各作业的特点和机器的性能关系，很可能对于某些<code>i</code>，有<code>ai ≥ bi</code>，而对于某些<code>j ≠ i</code>，有<code>aj &lt; bj</code>。既不能将一个作业分开由2台机器处理，也没有一台机器能同时处理2个作业。</p>
<p>研究一个实例:</p>
<p><code>(a1, a2, a3, a4, a5, a6) = (2, 5, 7, 10, 5, 2)</code></p>
<p><code>(b1, b2, b3, b4, b5, b6) = (3, 8, 4, 11, 3, 4)</code></p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h3><p>对于给定的n个作业，找出一个最优调度方案，使<code>A</code>、<code>B</code>两台机器处理完这n个作业的时间最短。</p>
<h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入:"></a>数据输入:</h3><p>由文件<code>input. txt</code>提供输入数据。</p>
<p>文件的第1行是1个正整数<code>n</code>,表示要处理<code>n</code>个作业</p>
<p>在接下来的2行中,每行有n个正整数，分别表示处理机<code>A</code>和<code>B</code>处理第<code>i</code>个作业需要的处理时间。</p>
<h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出:"></a>结果输出:</h3><p>将计算出的最短处理时间输出到文件<code>output txt</code>。</p>
<ul>
<li><p>输入文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">2 5 7 10 5 2</span><br><span class="line">3 8 4 11 3 4</span><br></pre></td></tr></table></figure></li>
<li><p>输出文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line"></span><br><span class="line">15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>找出<code>n</code>个任务所有耗时中最大的数<code>m</code>，也就是<code>A</code>和<code>B</code>数组的最大值。</li>
<li>设置三维布尔量数组<code>p[mn][mn][n]</code>，布尔量<code>p[i][j][k]</code>表示前<code>k</code>个作业可以在处理机<code>A</code>用时不超过<code>i</code>，处理机B不超过<code>j</code>的时间内完成。动态规划算法：<code>p[i][j][k] = p[i-ak][j][k-1] | p[i][j-bk][k-1]</code>（<code>|</code>为按位与运算符）</li>
<li>由上一步所得的结果我们可以找到时间最短的答案，具体是遍历布尔量为1的<code>k = n</code>的数组，取<code>min(i, j)</code>，如果比前一个小则取这个</li>
<li>具体算法如下</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream infile ;</span><br><span class="line">	infile.<span class="built_in">open</span>( <span class="string">&quot;input.txt&quot;</span> ) ;</span><br><span class="line">	infile &gt;&gt; n ;</span><br><span class="line">	</span><br><span class="line">	a = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	b = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; a[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( a[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; b[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( b[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	mn = m * n ;</span><br><span class="line">	</span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dyna</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span>*** p = <span class="keyword">new</span> <span class="keyword">bool</span>** [mn+<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="keyword">new</span> <span class="keyword">bool</span>* [mn+<span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			p[i][j] = <span class="keyword">new</span> <span class="keyword">bool</span> [n+<span class="number">1</span>] ;</span><br><span class="line">			p[i][j][<span class="number">0</span>] = <span class="literal">true</span> ;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">			&#123;</span><br><span class="line">				p[i][j][k] = <span class="literal">false</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( i - a[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i-a[k<span class="number">-1</span>]][j][k<span class="number">-1</span>] ;</span><br><span class="line">				<span class="keyword">if</span>( j - b[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i][j][k] || p[i][j-b[k<span class="number">-1</span>]][k<span class="number">-1</span>] ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> opt = mn ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j= <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( p[i][j][n] )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = <span class="built_in">max</span>( i , j ) ;</span><br><span class="line">				<span class="keyword">if</span>( tmp &lt; opt ) opt = tmp ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ofstream outfile ;</span><br><span class="line">	outfile.<span class="built_in">open</span>( <span class="string">&quot;output.txt&quot;</span> ) ;</span><br><span class="line">	outfile &lt;&lt; opt &lt;&lt; endl ;</span><br><span class="line"> 	outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>() ;</span><br><span class="line">	<span class="built_in">dyna</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法的时间复杂度为<code>O(m2n3) </code></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法——子集和问题</title>
    <url>/2021/04/24/%E5%9B%9E%E6%BA%AF%E6%B3%95%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>子集和问题的一个实例为<code>&lt;S,t&gt;</code>。</p>
<p>其中，<code>S=&#123;s1,x2,...,xn&#125;</code>是一个正整数的集合，c是一个正整数。</p>
<p>子集和问题判定是否存在S的一个子集<code>S1</code>，使得集合中所有元素的和等于c。</p>
<p>试设计一个解子集和问题的回溯法。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的正整数集合<code>S=&#123;s1,x2,...,xn&#125;</code>和正整数c，计算S的一个子集，使得子集和为c</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>提供输入数据。</p>
<p>文件第1行有2个整数n和c，n表示S的大小，c是子集和的目标值。</p>
<p>接下来的1行中，有n个正整数，表示集合S中的元素。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将子集和问题的解输出到文件<code>output.txt</code>。</p>
<p>当问题无解时，输出“No Solution！”。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">2 2 6</span><br></pre></td></tr></table></figure>

<h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li>回溯法的步骤为：<ul>
<li>修改当前节点状态</li>
<li>递归子节点状态</li>
<li>回改当前节点状态</li>
</ul>
</li>
<li><code>backtracking</code>函数：<ul>
<li>我们将<code>value</code>的值加上当前节点的值，同时添加当前元素到<code>tem</code>数组里。</li>
<li>递归下一节点，<code>backtracking(i + 1, n, c, S, tem, answer, value);</code></li>
<li>弹出<code>tem</code>数组刚刚添加的元素，<code>value</code>减去刚才加上的值</li>
<li>如果<code>value</code>值等于<code>c</code>，那么就添加此时的<code>tem</code>数组到<code>answer</code>二维数组中</li>
</ul>
</li>
<li><code>ssumc</code>函数：<ul>
<li>如果<code>answer</code>二维数组为空，则返回<code>tem</code>数组</li>
<li>如果<code>answer</code>不为空，则返回<code>answer</code>数组的第一个元素</li>
</ul>
</li>
<li><code>main</code>函数：<ul>
<li>从文件输入n、c、S数组</li>
<li>数组<code>ans</code>等于函数<code>ssumc</code>函数的返回值</li>
<li>输出数组元素，如果为空，则输出“No Solution！”到文件中</li>
</ul>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;outfile.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem,  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ssumc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> c, vector&lt;<span class="keyword">int</span>&gt; S)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; answer;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; tem;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">backtracking</span>(i, n, c, S, tem, answer, value);</span><br><span class="line">	<span class="keyword">if</span> (!answer.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> answer[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value == c) &#123;</span><br><span class="line">		answer.<span class="built_in">push_back</span>(tem);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i++) &#123;</span><br><span class="line">		tem.<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">		value += S[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">backtracking</span>(i + <span class="number">1</span>, n, c, S, tem, answer, value);</span><br><span class="line"></span><br><span class="line">		tem.<span class="built_in">pop_back</span>();</span><br><span class="line">		value -= S[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> n, c;</span><br><span class="line">	infile &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> tem;</span><br><span class="line">		infile &gt;&gt; tem;</span><br><span class="line">		S.<span class="built_in">push_back</span>(tem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">ssumc</span>(n, c, S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		outfile &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans.<span class="built_in">empty</span>())</span><br><span class="line">		outfile &lt;&lt; <span class="string">&quot;No Soution!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，回溯法的核心是回溯。</p>
<p>在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。</p>
<p>这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法——会场安排问题</title>
    <url>/2021/04/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="贪心算法——会场安排问题"><a href="#贪心算法——会场安排问题" class="headerlink" title="贪心算法——会场安排问题"></a>贪心算法——会场安排问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。</p>
<p>设计一个有效的贪心算法进行安排。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的k个待安排的活动，计算使用最少会场的时间表。</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>给出输入数据。</p>
<p>第一行有1个正整数k，表示有k个待安排的活动。</p>
<p>接下来的k行中，每行有两个正整数，分别表示k个待安排的活动开始时间和活动结束时间。</p>
<p>时间以0点开始的分钟计。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将计算的最小会场数输出到文件<code>output.txt</code>。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5</span><br><span class="line">1 23</span><br><span class="line">12 28</span><br><span class="line">25 35</span><br><span class="line">27 80</span><br><span class="line">36 50</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">78 52</span><br></pre></td></tr></table></figure>

<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>贪心算法，选择局部最优解</li>
<li>即按开始时间升序排列，再由后一个活动的开始时间大于或等于前一个活动的结束时间作为筛选条件，直到所有的活动都安排完成。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	infile &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> start[k], end[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		infile &gt;&gt; start[i] &gt;&gt; end[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(start, start + k);</span><br><span class="line">	<span class="built_in">sort</span>(end, end + k);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (start[i] &lt; end[j]) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	outfile &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——LAB-3_BombLab</title>
    <url>/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——LAB-3-Bomb-Lab"><a href="#深入理解计算机系统——LAB-3-Bomb-Lab" class="headerlink" title="深入理解计算机系统——LAB-3_Bomb_Lab"></a>深入理解计算机系统——LAB-3_Bomb_Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作者学校的课程作业，<code>Bomb Lab</code>对应<code>CS:APP</code>中第三章内容：<strong>程序的机器级表示的<code>lab</code></strong></p>
<p>程序运行在**<code>linux</code>环境**中。</p>
<p>程序运行中有6个关卡（6个<code>phase</code>），每个<code>phase</code>需要用户在终端上<strong>输入特定的字符或者数字</strong>才能<strong>通关</strong>，否则会引爆炸弹！</p>
<p>那么如何才能知道输入什么内容呢？</p>
<p>这需要你使用<code>gdb</code>工具<strong>反汇编</strong>出汇编代码，结合c语言文件找到<strong>每个关卡的入口函数</strong>。</p>
<p>然后<strong>分析汇编代码</strong>，找到在每个phase程序段中，引导程序<strong>跳转到<code>explode_bomb</code>程序段</strong>的地方，并分<strong>析其成功跳转的条件</strong>，以此为突破口寻找应该在命令行输入何种字符通关。</p>
<h2 id="实验环境和使用工具"><a href="#实验环境和使用工具" class="headerlink" title="实验环境和使用工具"></a>实验环境和使用工具</h2><ul>
<li><p>主机为<code>Windows10</code></p>
</li>
<li><p>运行炸弹的虚拟机<code>Ubuntu12.04.5</code></p>
</li>
<li><p><code>gdb7.4</code>版本</p>
</li>
<li><p><code>objdump2.22</code>版本</p>
</li>
<li><p><code>VS code</code>编辑器，下载了<code>x86 and x86_64 Assembly</code>插件，提供汇编代码高亮功能</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备工作，研究bomb-c源代码"><a href="#准备工作，研究bomb-c源代码" class="headerlink" title="准备工作，研究bomb.c源代码"></a>准备工作，研究<code>bomb.c</code>源代码</h3><p>一共有两个文件：<code>bomb.c</code>和<code>bomb</code>。</p>
<p><code>bomb.c</code>编译得到<code>bomb</code>文件，所以我先研究一下<code>bomb.c</code>的代码</p>
<ul>
<li>代码如下（随便看看）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">	infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">				      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>首先，我们看到一个有趣的<code>license</code>，（Google翻译）意思是</p>
<blockquote>
<p>Evil Incorporated博士（PERPETRATOR）特此授予您（VICTIM）使用该炸弹（BOMB）的明确许可。 </p>
<p>这是一个有时间限制的许可证，在VICTIM死亡时到期。 </p>
<p>PERPETRATOR对损坏，挫败，精神错乱，虫眼，腕隧道综合症，睡眠不足或对VICTIM造成的其他伤害不承担任何责任。 除非PERPETRATOR想要获得信誉，否则就是这样。</p>
<p> VICTIM不得将此炸弹源代码分发给PERPETRATOR的任何敌人。                     <strong>//重点，问问别人</strong></p>
<p> VICTIM不得调试，反向工程，在其上运行“字符串”，反编译，解密或使用任何其他技术来了解和拆除BOMB。 处理此程序时，不能穿防弹衣。                                                                                                <strong>//重点，使用上述所提到的技术拆除炸弹，穿防弹衣</strong></p>
<p>PERPETRATOR不会因PERPETRATOR糟糕的幽默感而道歉。                            <strong>//哈哈（强颜欢笑）</strong></p>
<p> 在法律禁止BOMB的情况下，此许可无效。                                                                </p>
</blockquote>
</li>
<li><p>,四个头文件，波浪线的两个我们没有，很好，过！<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428143806306.png" alt="image-20210428143806306"></p>
</li>
<li><p>注释意思是</p>
<blockquote>
<p>提醒自己：记得把这个文件删掉，这样我的受害者就不会知道发生了什么事，这样他们就会在一场可怕的恐怖爆炸中全部引爆。——邪恶博士                                                                                                           <strong>//重点，看这个文件，我们就知道炸弹怎么做的了</strong></p>
</blockquote>
</li>
<li><p><code>FILE *infile；</code>全局变量，文件指针，接下来要用到</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code>主函数，参数<code>argc</code>是提供给主函数的参数个数，参数<code>argv[]</code>是参数的字符串数组的指针。</p>
<blockquote>
<p>举例：./bomb answer.txt   此时，argc=2，argv[0]=”./bomb”，argv[1]=”answer.txt”</p>
</blockquote>
</li>
<li><p><code>char *input;</code>输入字符串用的变量</p>
</li>
<li><p>注释环节</p>
<blockquote>
<p>提醒自己：记得将炸弹移植到Windows并在上面放上精美的GUI。                     //老师拿来考试的</p>
</blockquote>
</li>
<li><p>后面的太多了，又看注释又看代码太累，我直接写意思，用法：</p>
<ol>
<li><code>./bomb</code>，然后自己一个一个输入</li>
<li><code>./bomb xxx.txt</code>，不用输入，直接看炸没炸</li>
</ol>
<p>显然我们选第二种，一个一个答案存起来。</p>
</li>
<li><p><code>initialize_bomb();</code>做炸弹函数，我们显然没有这个函数所需要的头文件。</p>
</li>
<li><p>输出文件开始执行的提示信息</p>
</li>
<li><p>接下来是6个<code>phase</code>，<code>phase</code>流程：</p>
<ul>
<li><code>input=read_line();</code>没有函数所需的头文件，功能就是输入字符串或者数字，也就是<code>phase</code>的答案</li>
<li><code>phase_x(input);</code>将输入作为参数运行第x个<code>phase</code>函数</li>
<li><code>phase_defused();</code>看答案是否匹配。</li>
<li>输出成功的提示信息</li>
</ul>
</li>
<li><p>至此，<code>bomb.c</code>已经看完了，我们已经知道炸弹是怎么做的了！</p>
</li>
<li><p>接下来，我们需要反汇编<code>bomb</code>文件，看看这些<code>phase</code>函数都是干什么的！</p>
</li>
</ul>
<h3 id="反汇编bomb文件"><a href="#反汇编bomb文件" class="headerlink" title="反汇编bomb文件"></a>反汇编<code>bomb</code>文件</h3><ul>
<li>在<code>Ubuntu</code>虚拟机中，实验文件夹下，我们执行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>

<ul>
<li>然后将<code>bomb.asm</code>移动到本机，用<code>vscode</code>打开，有1716行汇编代码<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428154937224.png" alt="image-20210428154937224">、</li>
<li>用<code>objdump</code>反汇编得到的文件，方便我们全局查找，<code>gdb</code>用来调试</li>
</ul>
<h3 id="分析汇编代码"><a href="#分析汇编代码" class="headerlink" title="分析汇编代码"></a>分析汇编代码</h3><p>上千行的汇编代码，我们不是一行一行看的，而是一个函数一个函数看的。</p>
<p>而且我们需要看的是关键部分。</p>
<ul>
<li><p>在文件夹下输入命令行使用gdb反汇编函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">gdb&gt; disassemble &lt;函数名&gt;           </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="read-line："><a href="#read-line：" class="headerlink" title="read_line："></a><code>read_line</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function read_line:</span><br><span class="line">   0x0804911d &lt;+0&gt;:	sub    $0x2c,%esp</span><br><span class="line">   0x08049120 &lt;+3&gt;:	mov    %ebx,0x20(%esp)</span><br><span class="line">   0x08049124 &lt;+7&gt;:	mov    %esi,0x24(%esp)</span><br><span class="line">   0x08049128 &lt;+11&gt;:	mov    %edi,0x28(%esp)</span><br><span class="line">   0x0804912c &lt;+15&gt;:	call   0x80490b0 &lt;skip&gt;</span><br><span class="line">   0x08049131 &lt;+20&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049133 &lt;+22&gt;:	jne    0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049135 &lt;+24&gt;:	mov    0x804c3a4,%eax</span><br><span class="line">   0x0804913a &lt;+29&gt;:	cmp    %eax,0x804c3d0</span><br><span class="line">   0x08049140 &lt;+35&gt;:	jne    0x804915a &lt;read_line+61&gt;</span><br><span class="line">   0x08049142 &lt;+37&gt;:	movl   $0x804a383,(%esp)</span><br><span class="line">   0x08049149 &lt;+44&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x0804914e &lt;+49&gt;:	movl   $0x8,(%esp)</span><br><span class="line">   0x08049155 &lt;+56&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x0804915a &lt;+61&gt;:	movl   $0x804a3a1,(%esp)</span><br><span class="line">   0x08049161 &lt;+68&gt;:	call   0x80487f0 &lt;getenv@plt&gt;</span><br><span class="line">   0x08049166 &lt;+73&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049168 &lt;+75&gt;:	je     0x8049176 &lt;read_line+89&gt;</span><br><span class="line">   0x0804916a &lt;+77&gt;:	movl   $0x0,(%esp)</span><br><span class="line">   0x08049171 &lt;+84&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x08049176 &lt;+89&gt;:	mov    0x804c3a4,%eax</span><br><span class="line">   0x0804917b &lt;+94&gt;:	mov    %eax,0x804c3d0</span><br><span class="line">   0x08049180 &lt;+99&gt;:	call   0x80490b0 &lt;skip&gt;</span><br><span class="line">   0x08049185 &lt;+104&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049187 &lt;+106&gt;:	jne    0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049189 &lt;+108&gt;:	movl   $0x804a383,(%esp)</span><br><span class="line">   0x08049190 &lt;+115&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x08049195 &lt;+120&gt;:	movl   $0x0,(%esp)</span><br><span class="line">   0x0804919c &lt;+127&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x080491a1 &lt;+132&gt;:	mov    0x804c3cc,%edx</span><br><span class="line">   0x080491a7 &lt;+138&gt;:	lea    (%edx,%edx,4),%ebx</span><br><span class="line">   0x080491aa &lt;+141&gt;:	shl    $0x4,%ebx</span><br><span class="line">   0x080491ad &lt;+144&gt;:	add    $0x804c3e0,%ebx</span><br><span class="line">   0x080491b3 &lt;+150&gt;:	mov    %ebx,%edi</span><br><span class="line">   0x080491b5 &lt;+152&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x080491ba &lt;+157&gt;:	mov    $0xffffffff,%ecx</span><br><span class="line">   0x080491bf &lt;+162&gt;:	repnz scas %es:(%edi),%al</span><br><span class="line">   0x080491c1 &lt;+164&gt;:	not    %ecx</span><br><span class="line">   0x080491c3 &lt;+166&gt;:	sub    $0x1,%ecx</span><br><span class="line">   0x080491c6 &lt;+169&gt;:	cmp    $0x4e,%ecx</span><br><span class="line">   0x080491c9 &lt;+172&gt;:	jle    0x8049202 &lt;read_line+229&gt;</span><br><span class="line">   0x080491cb &lt;+174&gt;:	movl   $0x804a3ac,(%esp)</span><br><span class="line">   0x080491d2 &lt;+181&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x080491d7 &lt;+186&gt;:	mov    0x804c3cc,%eax</span><br><span class="line">   0x080491dc &lt;+191&gt;:	lea    0x1(%eax),%edx</span><br><span class="line">   0x080491df &lt;+194&gt;:	mov    %edx,0x804c3cc</span><br><span class="line">   0x080491e5 &lt;+200&gt;:	imul   $0x50,%eax,%eax</span><br><span class="line">   0x080491e8 &lt;+203&gt;:	add    $0x804c3e0,%eax</span><br><span class="line">   0x080491ed &lt;+208&gt;:	mov    $0x804a3c7,%edx</span><br><span class="line">   0x080491f2 &lt;+213&gt;:	mov    $0x4,%ecx</span><br><span class="line">   0x080491f7 &lt;+218&gt;:	mov    %eax,%edi</span><br><span class="line">   0x080491f9 &lt;+220&gt;:	mov    %edx,%esi</span><br><span class="line">   0x080491fb &lt;+222&gt;:	rep movsl %ds:(%esi),%es:(%edi)</span><br><span class="line">   0x080491fd &lt;+224&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08049202 &lt;+229&gt;:	lea    (%edx,%edx,4),%eax</span><br><span class="line">   0x08049205 &lt;+232&gt;:	shl    $0x4,%eax</span><br><span class="line">   0x08049208 &lt;+235&gt;:	movb   $0x0,0x804c3df(%ecx,%eax,1)</span><br><span class="line">   0x08049210 &lt;+243&gt;:	add    $0x1,%edx</span><br><span class="line">   0x08049213 &lt;+246&gt;:	mov    %edx,0x804c3cc</span><br><span class="line">   0x08049219 &lt;+252&gt;:	mov    %ebx,%eax</span><br><span class="line">   0x0804921b &lt;+254&gt;:	mov    0x20(%esp),%ebx</span><br><span class="line">   0x0804921f &lt;+258&gt;:	mov    0x24(%esp),%esi</span><br><span class="line">   0x08049223 &lt;+262&gt;:	mov    0x28(%esp),%edi</span><br><span class="line">   0x08049227 &lt;+266&gt;:	add    $0x2c,%esp</span><br><span class="line">   0x0804922a &lt;+269&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以得出，<code>read_line</code>函数对输入的处理。</li>
</ul>
<h4 id="phase-1："><a href="#phase-1：" class="headerlink" title="phase_1："></a><code>phase_1</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:   </span><br><span class="line">   0x08048b50 &lt;+0&gt;:	    sub    $0x1c,%esp                           </span><br><span class="line">   &#x2F;&#x2F;栈指针%esp-0x1c，即该操作是为了给当前帧开辟一个大小为0x1c字节的空间</span><br><span class="line">   0x08048b53 &lt;+3&gt;:     movl   $0x804a1c4,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;将0x804a1c4（正确的字符串在内存中存放的地址）赋给(0x4+%esp)内存地址</span><br><span class="line">   0x08048b5b &lt;+11&gt;:	mov    0x20(%esp),%eax</span><br><span class="line">   &#x2F;&#x2F;将*(0x20+%esp)的地址赋给寄存器%eax，其实就是输入的字符串地址</span><br><span class="line">   0x08048b5f &lt;+15&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F;将寄存器%eax中的值赋给*(%esp)地址</span><br><span class="line">   0x08048b62 &lt;+18&gt;:	call   0x8048fe4 &lt;strings_not_equal&gt; </span><br><span class="line">    &#x2F;&#x2F;比较两字符串是否相等，根据结果给%eax赋值</span><br><span class="line">   0x08048b67 &lt;+23&gt;:	test   %eax,%eax</span><br><span class="line">   &#x2F;&#x2F;将两个值进行逻辑与操作，可以影响zf的值</span><br><span class="line">   0x08048b69 &lt;+25&gt;:	je     0x8048b70 &lt;phase_1+32&gt;</span><br><span class="line">   &#x2F;&#x2F;如果eax&#x3D;0，则zf&#x3D;1，则跳转进入0x8048b70</span><br><span class="line">   0x08048b6b &lt;+27&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   &#x2F;&#x2F;没有跳转则执行这一行指令，爆炸</span><br><span class="line">   0x08048b70 &lt;+32&gt;:	add    $0x1c,%esp</span><br><span class="line">   &#x2F;&#x2F;栈指针%esp+0x1c，函数执行完成，释放空间</span><br><span class="line">   0x08048b73 &lt;+35&gt;:	ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了搞清楚这个过程，我们需要进行<code>gdb</code>调试，下面是一些<code>gdb</code>命令（列出来的我都用了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb&gt; break *&lt;&lt;函数名&gt;+&lt;偏移值&gt;&gt;                             &#x2F;&#x2F;设置断点</span><br><span class="line">gdb&gt; run                                                  &#x2F;&#x2F;运行</span><br><span class="line">gdb&gt; step                                                 &#x2F;&#x2F;下一步</span><br><span class="line">gdb&gt; info registers &lt;寄存器&gt;                               &#x2F;&#x2F;列出寄存器的值，寄存器可选</span><br><span class="line">gdb&gt; set var &lt;寄存器或者变量&gt;&#x3D;&lt;0x111&gt;                        &#x2F;&#x2F;改变寄存器的值</span><br><span class="line">gdb&gt; set *&lt;内存地址&gt;&#x3D;&lt;0x11&gt;                                 &#x2F;&#x2F;改变内存的值</span><br><span class="line">gdb&gt; x&#x2F;nfu &lt;内存地址&gt;                  &#x2F;&#x2F;查看内存地址的值，examine简写为x，n长度，f显示格式，u一个地址单元的长度</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>执行命令，查看正确字符串<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220435495.png" alt="image-20210428220435495"></p>
</li>
<li><p>运行，输入正确字符串，提示炸弹已经被拆，下一关！<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220713564.png" alt="image-20210428220713564"></p>
</li>
</ul>
<h4 id="phase-2："><a href="#phase-2：" class="headerlink" title="phase_2："></a><code>phase_2</code>：</h4>]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>LAB</tag>
      </tags>
  </entry>
</search>
