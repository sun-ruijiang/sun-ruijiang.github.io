<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo写作——我的第一篇博客</title>
    <url>/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>大体上建好了网站，现在我们来学习一下如何在<code>hexo</code>上写作，并同步你的第一篇文章到GitHub上</p>
</blockquote>
<h2 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h2><h3 id="创建一篇博客"><a href="#创建一篇博客" class="headerlink" title="创建一篇博客"></a>创建一篇博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;My New Post&gt;</span><br></pre></td></tr></table></figure>

<p>如果不想使用命令行，直接在<code>source/_post</code>文件夹创建即可</p>
<p>需要注意的是，在文件编写的开头需要加上，<code>title</code>、<code>date</code>、<code>tag</code>、<code>category</code>、<code>author</code>、<code>Topping</code>这几个信息</p>
<h3 id="打开hexo服务器"><a href="#打开hexo服务器" class="headerlink" title="打开hexo服务器"></a>打开<code>hexo</code>服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>打开一个shell，输入这行命令</p>
<p>这是为了在本地观察渲染后的博客网站，显示一个<code>http://localhost:4000</code>网址，可以再这里观察网站变化</p>
<h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure>

<p>打开另一个shell，输入命令·</p>
<p>如果不输入这行命令，网页是不会变化的，需要不断重复打开</p>
<p>输入命令后，我们可以刷新网页以更新变化，也可以在shell中看到网站的改变</p>
<h3 id="部署到GitHub仓库"><a href="#部署到GitHub仓库" class="headerlink" title="部署到GitHub仓库"></a>部署到GitHub仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署命令·，可能出错，如果出现<code>SSL Connection</code>错误，就是因为网络不好</p>
<p>再次输入部署命令就好了</p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>为了实现插入图片，我们需要进行这几个操作：</p>
<ul>
<li><p>安装<code>hexo</code>插件：<code>npm install hexo-renderer-marked</code></p>
</li>
<li><p>修改配置文件<code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Typora</code>的偏好设置中，我们将图片存储到指定路径<code>./$&#123;filename&#125;</code></p>
</li>
<li><p>具体使用：随便粘贴一张图到文章中，<code>ctrl+f</code>寻找<code>&lt;md文件名&gt;/</code>将它替换为空</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法——双机调度问题</title>
    <url>/2021/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>用2台处理机<code>A</code>和<code>B</code>处理<code>n</code>个作业。设第<code>i</code>个作业交给机器A处理时需要时间<code>ai</code>，若由机器<code>B</code>来处理,则需要时间bi。</p>
<p>由于各作业的特点和机器的性能关系，很可能对于某些<code>i</code>，有<code>ai ≥ bi</code>，而对于某些<code>j ≠ i</code>，有<code>aj &lt; bj</code>。既不能将一个作业分开由2台机器处理，也没有一台机器能同时处理2个作业。</p>
<p>研究一个实例:</p>
<p><code>(a1, a2, a3, a4, a5, a6) = (2, 5, 7, 10, 5, 2)</code></p>
<p><code>(b1, b2, b3, b4, b5, b6) = (3, 8, 4, 11, 3, 4)</code></p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h3><p>对于给定的n个作业，找出一个最优调度方案，使<code>A</code>、<code>B</code>两台机器处理完这n个作业的时间最短。</p>
<h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入:"></a>数据输入:</h3><p>由文件<code>input. txt</code>提供输入数据。</p>
<p>文件的第1行是1个正整数<code>n</code>,表示要处理<code>n</code>个作业</p>
<p>在接下来的2行中,每行有n个正整数，分别表示处理机<code>A</code>和<code>B</code>处理第<code>i</code>个作业需要的处理时间。</p>
<h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出:"></a>结果输出:</h3><p>将计算出的最短处理时间输出到文件<code>output txt</code>。</p>
<ul>
<li><p>输入文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">2 5 7 10 5 2</span><br><span class="line">3 8 4 11 3 4</span><br></pre></td></tr></table></figure></li>
<li><p>输出文件示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line"></span><br><span class="line">15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>找出<code>n</code>个任务所有耗时中最大的数<code>m</code>，也就是<code>A</code>和<code>B</code>数组的最大值。</li>
<li>设置三维布尔量数组<code>p[mn][mn][n]</code>，布尔量<code>p[i][j][k]</code>表示前<code>k</code>个作业可以在处理机<code>A</code>用时不超过<code>i</code>，处理机B不超过<code>j</code>的时间内完成。动态规划算法：<code>p[i][j][k] = p[i-ak][j][k-1] | p[i][j-bk][k-1]</code>（<code>|</code>为按位与运算符）</li>
<li>由上一步所得的结果我们可以找到时间最短的答案，具体是遍历布尔量为1的<code>k = n</code>的数组，取<code>min(i, j)</code>，如果比前一个小则取这个</li>
<li>具体算法如下</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream infile ;</span><br><span class="line">	infile.<span class="built_in">open</span>( <span class="string">&quot;input.txt&quot;</span> ) ;</span><br><span class="line">	infile &gt;&gt; n ;</span><br><span class="line">	</span><br><span class="line">	a = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	b = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; a[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( a[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; b[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( b[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	mn = m * n ;</span><br><span class="line">	</span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dyna</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span>*** p = <span class="keyword">new</span> <span class="keyword">bool</span>** [mn+<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="keyword">new</span> <span class="keyword">bool</span>* [mn+<span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			p[i][j] = <span class="keyword">new</span> <span class="keyword">bool</span> [n+<span class="number">1</span>] ;</span><br><span class="line">			p[i][j][<span class="number">0</span>] = <span class="literal">true</span> ;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">			&#123;</span><br><span class="line">				p[i][j][k] = <span class="literal">false</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( i - a[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i-a[k<span class="number">-1</span>]][j][k<span class="number">-1</span>] ;</span><br><span class="line">				<span class="keyword">if</span>( j - b[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i][j][k] || p[i][j-b[k<span class="number">-1</span>]][k<span class="number">-1</span>] ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> opt = mn ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j= <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( p[i][j][n] )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = <span class="built_in">max</span>( i , j ) ;</span><br><span class="line">				<span class="keyword">if</span>( tmp &lt; opt ) opt = tmp ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ofstream outfile ;</span><br><span class="line">	outfile.<span class="built_in">open</span>( <span class="string">&quot;output.txt&quot;</span> ) ;</span><br><span class="line">	outfile &lt;&lt; opt &lt;&lt; endl ;</span><br><span class="line"> 	outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>() ;</span><br><span class="line">	<span class="built_in">dyna</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法的时间复杂度为<code>O(m2n3) </code></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法——子集和问题</title>
    <url>/2021/04/24/%E5%9B%9E%E6%BA%AF%E6%B3%95%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>子集和问题的一个实例为<code>&lt;S,t&gt;</code>。</p>
<p>其中，<code>S=&#123;s1,x2,...,xn&#125;</code>是一个正整数的集合，c是一个正整数。</p>
<p>子集和问题判定是否存在S的一个子集<code>S1</code>，使得集合中所有元素的和等于c。</p>
<p>试设计一个解子集和问题的回溯法。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的正整数集合<code>S=&#123;s1,x2,...,xn&#125;</code>和正整数c，计算S的一个子集，使得子集和为c</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>提供输入数据。</p>
<p>文件第1行有2个整数n和c，n表示S的大小，c是子集和的目标值。</p>
<p>接下来的1行中，有n个正整数，表示集合S中的元素。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将子集和问题的解输出到文件<code>output.txt</code>。</p>
<p>当问题无解时，输出“No Solution！”。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">2 2 6</span><br></pre></td></tr></table></figure>

<h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li>回溯法的步骤为：<ul>
<li>修改当前节点状态</li>
<li>递归子节点状态</li>
<li>回改当前节点状态</li>
</ul>
</li>
<li><code>backtracking</code>函数：<ul>
<li>我们将<code>value</code>的值加上当前节点的值，同时添加当前元素到<code>tem</code>数组里。</li>
<li>递归下一节点，<code>backtracking(i + 1, n, c, S, tem, answer, value);</code></li>
<li>弹出<code>tem</code>数组刚刚添加的元素，<code>value</code>减去刚才加上的值</li>
<li>如果<code>value</code>值等于<code>c</code>，那么就添加此时的<code>tem</code>数组到<code>answer</code>二维数组中</li>
</ul>
</li>
<li><code>ssumc</code>函数：<ul>
<li>如果<code>answer</code>二维数组为空，则返回<code>tem</code>数组</li>
<li>如果<code>answer</code>不为空，则返回<code>answer</code>数组的第一个元素</li>
</ul>
</li>
<li><code>main</code>函数：<ul>
<li>从文件输入n、c、S数组</li>
<li>数组<code>ans</code>等于函数<code>ssumc</code>函数的返回值</li>
<li>输出数组元素，如果为空，则输出“No Solution！”到文件中</li>
</ul>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;outfile.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem,  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ssumc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> c, vector&lt;<span class="keyword">int</span>&gt; S)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; answer;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; tem;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">backtracking</span>(i, n, c, S, tem, answer, value);</span><br><span class="line">	<span class="keyword">if</span> (!answer.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> answer[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value == c) &#123;</span><br><span class="line">		answer.<span class="built_in">push_back</span>(tem);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i++) &#123;</span><br><span class="line">		tem.<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">		value += S[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">backtracking</span>(i + <span class="number">1</span>, n, c, S, tem, answer, value);</span><br><span class="line"></span><br><span class="line">		tem.<span class="built_in">pop_back</span>();</span><br><span class="line">		value -= S[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> n, c;</span><br><span class="line">	infile &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> tem;</span><br><span class="line">		infile &gt;&gt; tem;</span><br><span class="line">		S.<span class="built_in">push_back</span>(tem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">ssumc</span>(n, c, S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		outfile &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans.<span class="built_in">empty</span>())</span><br><span class="line">		outfile &lt;&lt; <span class="string">&quot;No Soution!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，回溯法的核心是回溯。</p>
<p>在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。</p>
<p>这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法——会场安排问题</title>
    <url>/2021/04/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="贪心算法——会场安排问题"><a href="#贪心算法——会场安排问题" class="headerlink" title="贪心算法——会场安排问题"></a>贪心算法——会场安排问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。</p>
<p>设计一个有效的贪心算法进行安排。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的k个待安排的活动，计算使用最少会场的时间表。</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>给出输入数据。</p>
<p>第一行有1个正整数k，表示有k个待安排的活动。</p>
<p>接下来的k行中，每行有两个正整数，分别表示k个待安排的活动开始时间和活动结束时间。</p>
<p>时间以0点开始的分钟计。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将计算的最小会场数输出到文件<code>output.txt</code>。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5</span><br><span class="line">1 23</span><br><span class="line">12 28</span><br><span class="line">25 35</span><br><span class="line">27 80</span><br><span class="line">36 50</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">78 52</span><br></pre></td></tr></table></figure>

<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>贪心算法，选择局部最优解</li>
<li>即按开始时间升序排列，再由后一个活动的开始时间大于或等于前一个活动的结束时间作为筛选条件，直到所有的活动都安排完成。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	infile &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> start[k], end[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		infile &gt;&gt; start[i] &gt;&gt; end[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(start, start + k);</span><br><span class="line">	<span class="built_in">sort</span>(end, end + k);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (start[i] &lt; end[j]) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	outfile &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——LAB-3_BombLab</title>
    <url>/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——LAB-3-Bomb-Lab"><a href="#深入理解计算机系统——LAB-3-Bomb-Lab" class="headerlink" title="深入理解计算机系统——LAB-3_Bomb_Lab"></a>深入理解计算机系统——LAB-3_Bomb_Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Bomb Lab</code>对应<code>CS:APP</code>中第三章内容：<strong>程序的机器级表示的<code>lab</code></strong></p>
<p>程序运行在**<code>linux</code>环境**中。</p>
<p>程序运行中有6个关卡（6个<code>phase</code>），每个<code>phase</code>需要用户在终端上<strong>输入特定的字符或者数字</strong>才能<strong>通关</strong>，否则会引爆炸弹！</p>
<p>那么如何才能知道输入什么内容呢？</p>
<p>这需要你使用<code>gdb</code>工具<strong>反汇编</strong>出汇编代码，结合c语言文件找到<strong>每个关卡的入口函数</strong>。</p>
<p>然后<strong>分析汇编代码</strong>，找到在每个phase程序段中，引导程序<strong>跳转到<code>explode_bomb</code>程序段</strong>的地方，并分<strong>析其成功跳转的条件</strong>，以此为突破口寻找应该在命令行输入何种字符通关。</p>
<h2 id="实验环境和使用工具"><a href="#实验环境和使用工具" class="headerlink" title="实验环境和使用工具"></a>实验环境和使用工具</h2><ul>
<li><p>主机为<code>Windows10</code></p>
</li>
<li><p>运行炸弹的虚拟机<code>Ubuntu12.04.5</code></p>
</li>
<li><p><code>gdb7.4</code>版本</p>
</li>
<li><p><code>objdump2.22</code>版本</p>
</li>
<li><p><code>VS code</code>编辑器，下载了<code>x86 and x86_64 Assembly</code>插件，提供汇编代码高亮功能</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备工作，研究bomb-c源代码"><a href="#准备工作，研究bomb-c源代码" class="headerlink" title="准备工作，研究bomb.c源代码"></a>准备工作，研究<code>bomb.c</code>源代码</h3><p>一共有两个文件：<code>bomb.c</code>和<code>bomb</code>。</p>
<p><code>bomb.c</code>编译得到<code>bomb</code>文件，所以我先研究一下<code>bomb.c</code>的代码</p>
<ul>
<li>代码如下（随便看看）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">	infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">				      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>首先，我们看到一个有趣的<code>license</code>，（Google翻译）意思是</p>
<blockquote>
<p>Evil Incorporated博士（PERPETRATOR）特此授予您（VICTIM）使用该炸弹（BOMB）的明确许可。 </p>
<p>这是一个有时间限制的许可证，在VICTIM死亡时到期。 </p>
<p>PERPETRATOR对损坏，挫败，精神错乱，虫眼，腕隧道综合症，睡眠不足或对VICTIM造成的其他伤害不承担任何责任。 除非PERPETRATOR想要获得信誉，否则就是这样。</p>
<p> VICTIM不得将此炸弹源代码分发给PERPETRATOR的任何敌人。                     <strong>//重点，问问别人</strong></p>
<p> VICTIM不得调试，反向工程，在其上运行“字符串”，反编译，解密或使用任何其他技术来了解和拆除BOMB。 处理此程序时，不能穿防弹衣。                                                                                                <strong>//重点，使用上述所提到的技术拆除炸弹，穿防弹衣</strong></p>
<p>PERPETRATOR不会因PERPETRATOR糟糕的幽默感而道歉。                            <strong>//哈哈（强颜欢笑）</strong></p>
<p> 在法律禁止BOMB的情况下，此许可无效。                                                                </p>
</blockquote>
</li>
<li><p>,四个头文件，波浪线的两个我们没有，很好，过！<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428143806306.png" alt="image-20210428143806306"></p>
</li>
<li><p>注释意思是</p>
<blockquote>
<p>提醒自己：记得把这个文件删掉，这样我的受害者就不会知道发生了什么事，这样他们就会在一场可怕的恐怖爆炸中全部引爆。——邪恶博士                                                                                                           <strong>//重点，看这个文件，我们就知道炸弹怎么做的了</strong></p>
</blockquote>
</li>
<li><p><code>FILE *infile；</code>全局变量，文件指针，接下来要用到</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code>主函数，参数<code>argc</code>是提供给主函数的参数个数，参数<code>argv[]</code>是参数的字符串数组的指针。</p>
<blockquote>
<p>举例：./bomb answer.txt   此时，argc=2，argv[0]=”./bomb”，argv[1]=”answer.txt”</p>
</blockquote>
</li>
<li><p><code>char *input;</code>输入字符串用的变量</p>
</li>
<li><p>注释环节</p>
<blockquote>
<p>提醒自己：记得将炸弹移植到Windows并在上面放上精美的GUI。                     //老师拿来考试的</p>
</blockquote>
</li>
<li><p>后面的太多了，又看注释又看代码太累，我直接写意思，用法：</p>
<ol>
<li><code>./bomb</code>，然后自己一个一个输入</li>
<li><code>./bomb xxx.txt</code>，不用输入，直接看炸没炸</li>
</ol>
<p>显然我们选第二种，一个一个答案存起来。</p>
</li>
<li><p><code>initialize_bomb();</code>做炸弹函数，我们显然没有这个函数所需要的头文件。</p>
</li>
<li><p>输出文件开始执行的提示信息</p>
</li>
<li><p>接下来是6个<code>phase</code>，<code>phase</code>流程：</p>
<ul>
<li><code>input=read_line();</code>没有函数所需的头文件，功能就是输入字符串或者数字，也就是<code>phase</code>的答案</li>
<li><code>phase_x(input);</code>将输入作为参数运行第x个<code>phase</code>函数</li>
<li><code>phase_defused();</code>看答案是否匹配。</li>
<li>输出成功的提示信息</li>
</ul>
</li>
<li><p>至此，<code>bomb.c</code>已经看完了，我们已经知道炸弹是怎么做的了！</p>
</li>
<li><p>接下来，我们需要反汇编<code>bomb</code>文件，看看这些<code>phase</code>函数都是干什么的！</p>
</li>
</ul>
<h3 id="反汇编bomb文件"><a href="#反汇编bomb文件" class="headerlink" title="反汇编bomb文件"></a>反汇编<code>bomb</code>文件</h3><ul>
<li>在<code>Ubuntu</code>虚拟机中，实验文件夹下，我们执行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>

<ul>
<li>然后将<code>bomb.asm</code>移动到本机，用<code>vscode</code>打开，有1716行汇编代码<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428154937224.png" alt="image-20210428154937224">、</li>
<li>用<code>objdump</code>反汇编得到的文件，方便我们全局查找，<code>gdb</code>用来调试</li>
</ul>
<h3 id="分析汇编代码"><a href="#分析汇编代码" class="headerlink" title="分析汇编代码"></a>分析汇编代码</h3><p>上千行的汇编代码，我们不是一行一行看的，而是一个函数一个函数看的。</p>
<p>而且我们需要看的是关键部分。</p>
<ul>
<li><p>在文件夹下输入命令行使用gdb反汇编函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">gdb&gt; disassemble &lt;函数名&gt;           </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="read-line："><a href="#read-line：" class="headerlink" title="read_line："></a><code>read_line</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function read_line:</span><br><span class="line">   0x0804911d &lt;+0&gt;:	sub    $0x2c,%esp</span><br><span class="line">   0x08049120 &lt;+3&gt;:	mov    %ebx,0x20(%esp)</span><br><span class="line">   0x08049124 &lt;+7&gt;:	mov    %esi,0x24(%esp)</span><br><span class="line">   0x08049128 &lt;+11&gt;:	mov    %edi,0x28(%esp)</span><br><span class="line">   0x0804912c &lt;+15&gt;:	call   0x80490b0 &lt;skip&gt;</span><br><span class="line">   0x08049131 &lt;+20&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049133 &lt;+22&gt;:	jne    0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049135 &lt;+24&gt;:	mov    0x804c3a4,%eax</span><br><span class="line">   0x0804913a &lt;+29&gt;:	cmp    %eax,0x804c3d0</span><br><span class="line">   0x08049140 &lt;+35&gt;:	jne    0x804915a &lt;read_line+61&gt;</span><br><span class="line">   0x08049142 &lt;+37&gt;:	movl   $0x804a383,(%esp)</span><br><span class="line">   0x08049149 &lt;+44&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x0804914e &lt;+49&gt;:	movl   $0x8,(%esp)</span><br><span class="line">   0x08049155 &lt;+56&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x0804915a &lt;+61&gt;:	movl   $0x804a3a1,(%esp)</span><br><span class="line">   0x08049161 &lt;+68&gt;:	call   0x80487f0 &lt;getenv@plt&gt;</span><br><span class="line">   0x08049166 &lt;+73&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049168 &lt;+75&gt;:	je     0x8049176 &lt;read_line+89&gt;</span><br><span class="line">   0x0804916a &lt;+77&gt;:	movl   $0x0,(%esp)</span><br><span class="line">   0x08049171 &lt;+84&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x08049176 &lt;+89&gt;:	mov    0x804c3a4,%eax</span><br><span class="line">   0x0804917b &lt;+94&gt;:	mov    %eax,0x804c3d0</span><br><span class="line">   0x08049180 &lt;+99&gt;:	call   0x80490b0 &lt;skip&gt;</span><br><span class="line">   0x08049185 &lt;+104&gt;:	test   %eax,%eax</span><br><span class="line">   0x08049187 &lt;+106&gt;:	jne    0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049189 &lt;+108&gt;:	movl   $0x804a383,(%esp)</span><br><span class="line">   0x08049190 &lt;+115&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x08049195 &lt;+120&gt;:	movl   $0x0,(%esp)</span><br><span class="line">   0x0804919c &lt;+127&gt;:	call   0x8048840 &lt;exit@plt&gt;</span><br><span class="line">   0x080491a1 &lt;+132&gt;:	mov    0x804c3cc,%edx</span><br><span class="line">   0x080491a7 &lt;+138&gt;:	lea    (%edx,%edx,4),%ebx</span><br><span class="line">   0x080491aa &lt;+141&gt;:	shl    $0x4,%ebx</span><br><span class="line">   0x080491ad &lt;+144&gt;:	add    $0x804c3e0,%ebx</span><br><span class="line">   0x080491b3 &lt;+150&gt;:	mov    %ebx,%edi</span><br><span class="line">   0x080491b5 &lt;+152&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x080491ba &lt;+157&gt;:	mov    $0xffffffff,%ecx</span><br><span class="line">   0x080491bf &lt;+162&gt;:	repnz scas %es:(%edi),%al</span><br><span class="line">   0x080491c1 &lt;+164&gt;:	not    %ecx</span><br><span class="line">   0x080491c3 &lt;+166&gt;:	sub    $0x1,%ecx</span><br><span class="line">   0x080491c6 &lt;+169&gt;:	cmp    $0x4e,%ecx</span><br><span class="line">   0x080491c9 &lt;+172&gt;:	jle    0x8049202 &lt;read_line+229&gt;</span><br><span class="line">   0x080491cb &lt;+174&gt;:	movl   $0x804a3ac,(%esp)</span><br><span class="line">   0x080491d2 &lt;+181&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x080491d7 &lt;+186&gt;:	mov    0x804c3cc,%eax</span><br><span class="line">   0x080491dc &lt;+191&gt;:	lea    0x1(%eax),%edx</span><br><span class="line">   0x080491df &lt;+194&gt;:	mov    %edx,0x804c3cc</span><br><span class="line">   0x080491e5 &lt;+200&gt;:	imul   $0x50,%eax,%eax</span><br><span class="line">   0x080491e8 &lt;+203&gt;:	add    $0x804c3e0,%eax</span><br><span class="line">   0x080491ed &lt;+208&gt;:	mov    $0x804a3c7,%edx</span><br><span class="line">   0x080491f2 &lt;+213&gt;:	mov    $0x4,%ecx</span><br><span class="line">   0x080491f7 &lt;+218&gt;:	mov    %eax,%edi</span><br><span class="line">   0x080491f9 &lt;+220&gt;:	mov    %edx,%esi</span><br><span class="line">   0x080491fb &lt;+222&gt;:	rep movsl %ds:(%esi),%es:(%edi)</span><br><span class="line">   0x080491fd &lt;+224&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08049202 &lt;+229&gt;:	lea    (%edx,%edx,4),%eax</span><br><span class="line">   0x08049205 &lt;+232&gt;:	shl    $0x4,%eax</span><br><span class="line">   0x08049208 &lt;+235&gt;:	movb   $0x0,0x804c3df(%ecx,%eax,1)</span><br><span class="line">   0x08049210 &lt;+243&gt;:	add    $0x1,%edx</span><br><span class="line">   0x08049213 &lt;+246&gt;:	mov    %edx,0x804c3cc</span><br><span class="line">   0x08049219 &lt;+252&gt;:	mov    %ebx,%eax</span><br><span class="line">   0x0804921b &lt;+254&gt;:	mov    0x20(%esp),%ebx</span><br><span class="line">   0x0804921f &lt;+258&gt;:	mov    0x24(%esp),%esi</span><br><span class="line">   0x08049223 &lt;+262&gt;:	mov    0x28(%esp),%edi</span><br><span class="line">   0x08049227 &lt;+266&gt;:	add    $0x2c,%esp</span><br><span class="line">   0x0804922a &lt;+269&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中多次调用的函数</li>
</ul>
<h4 id="phase-1："><a href="#phase-1：" class="headerlink" title="phase_1："></a><code>phase_1</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:   </span><br><span class="line">   0x08048b50 &lt;+0&gt;:	    sub    $0x1c,%esp                           </span><br><span class="line">   &#x2F;&#x2F;栈指针%esp-0x1c，即该操作是为了给当前帧开辟一个大小为0x1c字节的空间</span><br><span class="line">   0x08048b53 &lt;+3&gt;:     movl   $0x804a1c4,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;将0x804a1c4（正确的字符串在内存中存放的地址）赋给(0x4+%esp)内存地址</span><br><span class="line">   0x08048b5b &lt;+11&gt;:	mov    0x20(%esp),%eax</span><br><span class="line">   &#x2F;&#x2F;将*(0x20+%esp)的地址赋给寄存器%eax，其实就是输入的字符串地址</span><br><span class="line">   0x08048b5f &lt;+15&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F;将寄存器%eax中的值赋给*(%esp)地址</span><br><span class="line">   0x08048b62 &lt;+18&gt;:	call   0x8048fe4 &lt;strings_not_equal&gt; </span><br><span class="line">    &#x2F;&#x2F;比较两字符串是否相等，根据结果给%eax赋值</span><br><span class="line">   0x08048b67 &lt;+23&gt;:	test   %eax,%eax</span><br><span class="line">   &#x2F;&#x2F;将两个值进行逻辑与操作，可以影响zf的值</span><br><span class="line">   0x08048b69 &lt;+25&gt;:	je     0x8048b70 &lt;phase_1+32&gt;</span><br><span class="line">   &#x2F;&#x2F;如果eax&#x3D;0，则zf&#x3D;1，则跳转进入0x8048b70</span><br><span class="line">   0x08048b6b &lt;+27&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   &#x2F;&#x2F;没有跳转则执行这一行指令，爆炸</span><br><span class="line">   0x08048b70 &lt;+32&gt;:	add    $0x1c,%esp</span><br><span class="line">   &#x2F;&#x2F;栈指针%esp+0x1c，函数执行完成，释放空间</span><br><span class="line">   0x08048b73 &lt;+35&gt;:	ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了搞清楚这个过程，我们需要进行<code>gdb</code>调试，下面是一些<code>gdb</code>命令（列出来的我都用了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb&gt; break *&lt;&lt;函数名&gt;+&lt;偏移值&gt;&gt;                             &#x2F;&#x2F;设置断点</span><br><span class="line">gdb&gt; run                                                  &#x2F;&#x2F;运行</span><br><span class="line">gdb&gt; step                                                 &#x2F;&#x2F;下一步</span><br><span class="line">gdb&gt; info registers &lt;寄存器&gt;                               &#x2F;&#x2F;列出寄存器的值，寄存器可选</span><br><span class="line">gdb&gt; set var &lt;寄存器或者变量&gt;&#x3D;&lt;0x111&gt;                        &#x2F;&#x2F;改变寄存器的值</span><br><span class="line">gdb&gt; set *&lt;内存地址&gt;&#x3D;&lt;0x11&gt;                                 &#x2F;&#x2F;改变内存的值</span><br><span class="line">gdb&gt; x&#x2F;nfu &lt;内存地址&gt;                  &#x2F;&#x2F;查看内存地址的值，examine简写为x，n长度，f显示格式，u一个地址单元的长度</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>执行命令，查看正确字符串<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220435495.png" alt="image-20210428220435495"></p>
</li>
<li><p>运行，输入正确字符串，提示炸弹已经被拆，下一关！<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220713564.png" alt="image-20210428220713564"></p>
</li>
</ul>
<h4 id="phase-2："><a href="#phase-2：" class="headerlink" title="phase_2："></a><code>phase_2</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">   0x08048b74 &lt;+0&gt;:	push   %esi</span><br><span class="line">   &#x2F;&#x2F;将程序的入口地址压入栈中</span><br><span class="line">   0x08048b75 &lt;+1&gt;:	push   %ebx</span><br><span class="line">   &#x2F;&#x2F;将被调用者保存寄存器中的值压入栈中，以便在返回前可以恢复它们</span><br><span class="line">   0x08048b76 &lt;+2&gt;:	sub    $0x34,%esp</span><br><span class="line">   0x08048b79 &lt;+5&gt;:	lea    0x18(%esp),%eax</span><br><span class="line">   0x08048b7d &lt;+9&gt;:	mov    %eax,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F; *0x4(%esp)存着0x18(%esp)</span><br><span class="line">   0x08048b81 &lt;+13&gt;:	mov    0x40(%esp),%eax</span><br><span class="line">   0x08048b85 &lt;+17&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F; *(%esp)存着0x40(%esp)</span><br><span class="line">   0x08048b88 &lt;+20&gt;:	call   0x804922b &lt;read_six_numbers&gt;</span><br><span class="line">   &#x2F;&#x2F;根据该函数名称可以推测答案是输入六个数</span><br><span class="line">   0x08048b8d &lt;+25&gt;:	cmpl   $0x1,0x18(%esp)</span><br><span class="line">   0x08048b92 &lt;+30&gt;:	je     0x8048b99 &lt;phase_2+37&gt;</span><br><span class="line">   &#x2F;&#x2F;如果0x1等于%esp+0x18地址存的值，跳过爆炸函数</span><br><span class="line">   0x08048b94 &lt;+32&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048b99 &lt;+37&gt;:	lea    0x1c(%esp),%ebx</span><br><span class="line">   &#x2F;&#x2F;将地址%esp+0x1c赋给寄存器%ebx</span><br><span class="line">   0x08048b9d &lt;+41&gt;:	lea    0x30(%esp),%esi</span><br><span class="line">   &#x2F;&#x2F;将地址%esp+0x30赋给寄存器%esi</span><br><span class="line">   0x08048ba1 &lt;+45&gt;:	mov    -0x4(%ebx),%eax</span><br><span class="line">   &#x2F;&#x2F;将*(%ebx-0x4)也就是*(%esp+0x18)也就是0x1赋给寄存器%eax</span><br><span class="line">   0x08048ba4 &lt;+48&gt;:	add    %eax,%eax</span><br><span class="line">   &#x2F;&#x2F;%eax中的值翻倍</span><br><span class="line">   0x08048ba6 &lt;+50&gt;:	cmp    %eax,(%ebx)</span><br><span class="line">   0x08048ba8 &lt;+52&gt;:	je     0x8048baf &lt;phase_2+59&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%eax存的值与%ebx存的内存地址上的值相等，跳过爆炸函数</span><br><span class="line">   0x08048baa &lt;+54&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048baf &lt;+59&gt;:	add    $0x4,%ebx</span><br><span class="line">   &#x2F;&#x2F;%ebx加0x4，又回到现在的数字</span><br><span class="line">   0x08048bb2 &lt;+62&gt;:	cmp    %esi,%ebx</span><br><span class="line">   0x08048bb4 &lt;+64&gt;:	jne    0x8048ba1 &lt;phase_2+45&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%esi不等于%ebx，就跳转到phase_2+45执行指令</span><br><span class="line">   0x08048bb6 &lt;+66&gt;:	add    $0x34,%esp</span><br><span class="line">   0x08048bb9 &lt;+69&gt;:	pop    %ebx</span><br><span class="line">   &#x2F;&#x2F;恢复%ebx原先的数据</span><br><span class="line">   0x08048bba &lt;+70&gt;:	pop    %esi</span><br><span class="line">   &#x2F;&#x2F;弹出程序的入口地址</span><br><span class="line">   0x08048bbb &lt;+71&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x08048b8d &lt;+25&gt;:    cmpl   $0x1,0x18(%esp)</code>得到地址为<code>ox18+%esp</code>的值应该等于<code>0x1</code>才能不爆炸</li>
<li><code>0x08048ba6 &lt;+50&gt;:    cmp    %eax,(%ebx)</code>可知如果<code>*(%ebx-4) + *(%ebx-4) </code>也就是<code>%eax</code>存的值等于<code>*%ebx</code>，跳过炸弹。第一次执行时的<code>%ebx</code>存的值为<code>0x1c+%esp</code>，也就是第二个数，所以第二个数为<code>0x2</code>.</li>
<li><code>0x08048bb2 &lt;+62&gt;:    cmp    %esi,%ebx</code>可知j如果<code>%esi != %ebx</code>，回到<code>&lt;phase_2+45&gt;</code>重新进行运算，判断现在的数字和2倍的前一个是否相等，不相等就爆炸，此时的<code>%esi</code>存的是<code>0x30+%esp</code>也就是第六位数字加<code>0x4</code>的地址</li>
<li>所以我们得到的六个数字是：<code>1 2 4 8 16 32 64</code>，测试，成功！<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430085749377.png" alt="image-20210430085749377"></li>
</ul>
<h4 id="phase-3："><a href="#phase-3：" class="headerlink" title="phase_3："></a><code>phase_3</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">   0x08048bbc &lt;+0&gt;:	    sub    $0x2c,%esp</span><br><span class="line">   0x08048bbf &lt;+3&gt;:	    lea    0x1c(%esp),%eax</span><br><span class="line">   0x08048bc3 &lt;+7&gt;:	    mov    %eax,0xc(%esp)</span><br><span class="line">   &#x2F;&#x2F; *(0xc+%esp)存着0x1c+%esp，第二个数</span><br><span class="line">   0x08048bc7 &lt;+11&gt;:	lea    0x18(%esp),%eax</span><br><span class="line">   0x08048bcb &lt;+15&gt;:	mov    %eax,0x8(%esp)</span><br><span class="line">   &#x2F;&#x2F; *(0x8+%esp)存着0x18+%esp，第一个数</span><br><span class="line">   0x08048bcf &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F; *(0x4+%esp)存着0x804a3e3</span><br><span class="line">   0x08048bd7 &lt;+27&gt;:	mov    0x30(%esp),%eax</span><br><span class="line">   0x08048bdb &lt;+31&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F; *%esp存着*(0x30+%esp)</span><br><span class="line">   0x08048bde &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x08048be3 &lt;+39&gt;:	cmp    $0x1,%eax</span><br><span class="line">   0x08048be6 &lt;+42&gt;:	jg     0x8048bed &lt;phase_3+49&gt;</span><br><span class="line">   &#x2F;&#x2F; %eax&gt;0x1，参数要大于1个，跳转至&lt;phase_3+49&gt;，否则炸弹爆炸</span><br><span class="line">   0x08048be8 &lt;+44&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048bed &lt;+49&gt;:	cmpl   $0x7,0x18(%esp)</span><br><span class="line">   0x08048bf2 &lt;+54&gt;:	ja     0x8048c30 &lt;phase_3+116&gt;</span><br><span class="line">   &#x2F;&#x2F; *(0x18+%esp)&gt;0x7的话，跳转至&lt;phase_3+316&gt; 炸弹爆炸，所以推测得到*(0x18+%esp)&lt;&#x3D;0x7，只有0-7八种情况</span><br><span class="line">   0x08048bf4 &lt;+56&gt;:	mov    0x18(%esp),%eax</span><br><span class="line">   0x08048bf8 &lt;+60&gt;:	jmp    *0x804a220(,%eax,4)</span><br><span class="line">   &#x2F;&#x2F; 跳转到*(0x804a220+4*%eax)地址</span><br><span class="line">   0x08048bff &lt;+67&gt;:	mov    $0x32d,%eax</span><br><span class="line">   0x08048c04 &lt;+72&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x32d存到%eax</span><br><span class="line">   0x08048c06 &lt;+74&gt;:	mov    $0x36c,%eax</span><br><span class="line">   0x08048c0b &lt;+79&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x36c存到%eax</span><br><span class="line">   0x08048c0d &lt;+81&gt;:	mov    $0x3db,%eax</span><br><span class="line">   0x08048c12 &lt;+86&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x3db存到%eax</span><br><span class="line">   0x08048c14 &lt;+88&gt;:	mov    $0x16d,%eax</span><br><span class="line">   0x08048c19 &lt;+93&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x16d存到%eax</span><br><span class="line">   0x08048c1b &lt;+95&gt;:	mov    $0x3d1,%eax</span><br><span class="line">   0x08048c20 &lt;+100&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x3d1存到%eax</span><br><span class="line">   0x08048c22 &lt;+102&gt;:	mov    $0x3cb,%eax</span><br><span class="line">   0x08048c27 &lt;+107&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x3cb存到%eax</span><br><span class="line">   0x08048c29 &lt;+109&gt;:	mov    $0x21c,%eax</span><br><span class="line">   0x08048c2e &lt;+114&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x21c存到%eax</span><br><span class="line">   0x08048c30 &lt;+116&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048c35 &lt;+121&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x08048c3a &lt;+126&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   &#x2F;&#x2F;0x0存到%eax</span><br><span class="line">   0x08048c3c &lt;+128&gt;:	mov    $0x283,%eax</span><br><span class="line">   &#x2F;&#x2F;0x283存到%eax</span><br><span class="line">   0x08048c41 &lt;+133&gt;:	cmp    0x1c(%esp),%eax</span><br><span class="line">   0x08048c45 &lt;+137&gt;:	je     0x8048c4c &lt;phase_3+144&gt;</span><br><span class="line">   &#x2F;&#x2F; *(0x1c+%esp)等于%eax，则跳过爆炸函数</span><br><span class="line">   0x08048c47 &lt;+139&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048c4c &lt;+144&gt;:	add    $0x2c,%esp</span><br><span class="line">   0x08048c4f &lt;+147&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>反汇编<code>__isoc99_sscanf</code>我们知道，这个<code>scanf</code>函数的参数在地址<code>0x804a3e3</code>，以字符串的形式输出，我们输入的是两个整数。<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430191833050.png" alt="image-20210430191833050">、</li>
<li><code>0x08048bed &lt;+49&gt;:    cmpl   $0x7,0x18(%esp)</code>可知，第一个参数范围是0-7，出范围就爆炸</li>
<li><code>0x08048bf8 &lt;+60&gt;:    jmp    *0x804a220(,%eax,4)</code>可知，根据第一个参数，决定跳转到什么位置<ul>
<li>查看这8个不同跳转位置<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430200908533.png" alt="image-20210430200908533"></li>
<li>因此我们得到了八个不同的输入组合：<br><code>0 813</code>、<code>1  643</code>、<code>2  876</code>、<code>3  987</code>、<code>4  365</code>、<code>5  977</code>、<code>6  971</code>、<code>7 540 </code></li>
<li>经验证，这几个都是符合的答案</li>
</ul>
</li>
<li>我们选<code>0 813</code>输入，输出成功拆除的提示语，第三关结束。<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430204301058.png" alt="image-20210430204301058"></li>
</ul>
<h4 id="phase-4："><a href="#phase-4：" class="headerlink" title="phase_4："></a><code>phase_4</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">   0x08048cb9 &lt;+0&gt;:	    sub    $0x2c,%esp</span><br><span class="line">   &#x2F;&#x2F;开2c空间</span><br><span class="line">   0x08048cbc &lt;+3&gt;:	    lea    0x1c(%esp),%eax</span><br><span class="line">   0x08048cc0 &lt;+7&gt;:	    mov    %eax,0xc(%esp)</span><br><span class="line">   0x08048cc4 &lt;+11&gt;:	lea    0x18(%esp),%eax</span><br><span class="line">   0x08048cc8 &lt;+15&gt;:	mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048ccc &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F; 0x804a3e3 %d %d</span><br><span class="line">   0x08048cd4 &lt;+27&gt;:	mov    0x30(%esp),%eax</span><br><span class="line">   0x08048cd8 &lt;+31&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F;这几行跟上一关一样的，为scanf函数准备参数</span><br><span class="line">   0x08048cdb &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x08048ce0 &lt;+39&gt;:	cmp    $0x2,%eax</span><br><span class="line">   0x08048ce3 &lt;+42&gt;:	jne    0x8048cf2 &lt;phase_4+57&gt;</span><br><span class="line">   &#x2F;&#x2F;如果输入2个参数则继续，否则跳转到0x8048cf2 &lt;phase_4+57&gt;爆炸</span><br><span class="line">   0x08048ce5 &lt;+44&gt;:	mov    0x18(%esp),%eax</span><br><span class="line">   &#x2F;&#x2F;第一个数放到%eax</span><br><span class="line">   0x08048ce9 &lt;+48&gt;:	test   %eax,%eax</span><br><span class="line">   0x08048ceb &lt;+50&gt;:	js     0x8048cf2 &lt;phase_4+57&gt;</span><br><span class="line">   &#x2F;&#x2F;如果是负数就跳转到0x8048cf2 &lt;phase_4+57&gt;爆炸</span><br><span class="line">   0x08048ced &lt;+52&gt;:	cmp    $0xe,%eax</span><br><span class="line">   0x08048cf0 &lt;+55&gt;:	jle    0x8048cf7 &lt;phase_4+62&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%eax存的值&gt;0xe，跳过爆炸函数，执行之后</span><br><span class="line">   0x08048cf2 &lt;+57&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048cf7 &lt;+62&gt;:	movl   $0xe,0x8(%esp)</span><br><span class="line">   0x08048cff &lt;+70&gt;:	movl   $0x0,0x4(%esp)</span><br><span class="line">   0x08048d07 &lt;+78&gt;:	mov    0x18(%esp),%eax</span><br><span class="line">   0x08048d0b &lt;+82&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048d0e &lt;+85&gt;:	call   0x8048c50 &lt;func4&gt;</span><br><span class="line">   &#x2F;&#x2F;func4(第一个数,0x0,0xe)</span><br><span class="line">   0x08048d13 &lt;+90&gt;:	cmp    $0x15,%eax</span><br><span class="line">   0x08048d16 &lt;+93&gt;:	jne    0x8048d1f &lt;phase_4+102&gt;</span><br><span class="line">   &#x2F;&#x2F;如果将0x15与func4的返回值作比较，如果不相等，就跳转爆炸</span><br><span class="line">   0x08048d18 &lt;+95&gt;:	cmpl   $0x15,0x1c(%esp)</span><br><span class="line">   0x08048d1d &lt;+100&gt;:	je     0x8048d24 &lt;phase_4+107&gt;</span><br><span class="line">   &#x2F;&#x2F;如果第二个数等于0x15我们跳过爆炸函数，所以第二个数字是0x21</span><br><span class="line">   0x08048d1f &lt;+102&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048d24 &lt;+107&gt;:	add    $0x2c,%esp</span><br><span class="line">   0x08048d27 &lt;+110&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看<code>scanf</code>的参数，在<code>0x804a3e3</code>以字符串的形式输出，我们看到是两个整数</p>
<p><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430230148066.png" alt="image-20210430230148066"></p>
</li>
<li><p><code>0x08048d18 &lt;+95&gt;:    cmpl   $0x15,0x1c(%esp)</code>，我们分析第二个数字要等于<code>0x15</code></p>
</li>
<li><p>为了知道第一个数字，我们需要看一下<code>func4</code>函数给<code>%eax</code>存入了什么</p>
</li>
</ul>
<h5 id="func4"><a href="#func4" class="headerlink" title="func4"></a><code>func4</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">   0x08048c50 &lt;+0&gt;:	sub    $0x1c,%esp</span><br><span class="line">   0x08048c53 &lt;+3&gt;:	    mov    %ebx,0x14(%esp)</span><br><span class="line">   0x08048c57 &lt;+7&gt;:	    mov    %esi,0x18(%esp)</span><br><span class="line">   0x08048c5b &lt;+11&gt;:	mov    0x20(%esp),%eax</span><br><span class="line">   0x08048c5f &lt;+15&gt;:	mov    0x24(%esp),%edx</span><br><span class="line">   0x08048c63 &lt;+19&gt;:	mov    0x28(%esp),%esi</span><br><span class="line">   &#x2F;&#x2F;三个数分别放在%eax,%edx,%esi</span><br><span class="line">   0x08048c67 &lt;+23&gt;:	mov    %esi,%ecx</span><br><span class="line">   0x08048c69 &lt;+25&gt;:	sub    %edx,%ecx</span><br><span class="line">   &#x2F;&#x2F;%ecx&#x3D;%esi-%edx</span><br><span class="line">   0x08048c6b &lt;+27&gt;:	mov    %ecx,%ebx</span><br><span class="line">   &#x2F;&#x2F;%ebx&#x3D;%ecx</span><br><span class="line">   0x08048c6d &lt;+29&gt;:	shr    $0x1f,%ebx</span><br><span class="line">   0x08048c70 &lt;+32&gt;:	add    %ebx,%ecx</span><br><span class="line">   &#x2F;&#x2F;将%ebx中的值逻辑右移0x1f位,如果为负数的话右移31位得到1，再加到%ecx中去；</span><br><span class="line">   0x08048c72 &lt;+34&gt;:	sar    %ecx</span><br><span class="line">   &#x2F;&#x2F;默认算术右移一位,即求%ecx&#x3D;(%esi-%edx)&#x2F;2，向0取整</span><br><span class="line">   0x08048c74 &lt;+36&gt;:	lea    (%ecx,%edx,1),%ebx</span><br><span class="line">   &#x2F;&#x2F;%ebx&#x3D;(%esi-%edx)&#x2F;2+%edx&#x3D;(%esi+%edx)&#x2F;2</span><br><span class="line">   0x08048c77 &lt;+39&gt;:	cmp    %eax,%ebx</span><br><span class="line">   0x08048c79 &lt;+41&gt;:	jle    0x8048c92 &lt;func4+66&gt;</span><br><span class="line">   &#x2F;&#x2F;%eax小于或等于(%esi+%edx)&#x2F;2转移</span><br><span class="line">   0x08048c7b &lt;+43&gt;:	lea    -0x1(%ebx),%ecx</span><br><span class="line">   0x08048c7e &lt;+46&gt;:	mov    %ecx,0x8(%esp)</span><br><span class="line">   0x08048c82 &lt;+50&gt;:	mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048c86 &lt;+54&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048c89 &lt;+57&gt;:	call   0x8048c50 &lt;func4&gt;</span><br><span class="line">   &#x2F;&#x2F;func4(第一个数,%edx,%ebx-0x1)</span><br><span class="line">   0x08048c8e &lt;+62&gt;:	add    %eax,%ebx</span><br><span class="line">   &#x2F;&#x2F; %ebx + func4(第一个数,%edx,%ebx-0x1)</span><br><span class="line">   0x08048c90 &lt;+64&gt;:	jmp    0x8048cab &lt;func4+91&gt;</span><br><span class="line">   &#x2F;&#x2F;无条件跳转</span><br><span class="line">   0x08048c92 &lt;+66&gt;:	cmp    %eax,%ebx</span><br><span class="line">   0x08048c94 &lt;+68&gt;:	jge    0x8048cab &lt;func4+91&gt;</span><br><span class="line">   &#x2F;&#x2F;大于或等于转移,配合前一个小于等于转移，就是如果%eax&#x3D;%ebx就跳转。</span><br><span class="line">   0x08048c96 &lt;+70&gt;:	mov    %esi,0x8(%esp)</span><br><span class="line">   0x08048c9a &lt;+74&gt;:	lea    0x1(%ebx),%edx</span><br><span class="line">   0x08048c9d &lt;+77&gt;:	mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048ca1 &lt;+81&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048ca4 &lt;+84&gt;:	call   0x8048c50 &lt;func4&gt;</span><br><span class="line">   &#x2F;&#x2F;func4(第一个数,%ebx+0x1,%esi)</span><br><span class="line">   0x08048ca9 &lt;+89&gt;:	add    %eax,%ebx</span><br><span class="line">   &#x2F;&#x2F; %ebx + func4(第一个数,%ebx+0x1,%esi)</span><br><span class="line">   0x08048cab &lt;+91&gt;:	mov    %ebx,%eax</span><br><span class="line">   &#x2F;&#x2F;这个%eax就是我们需要知道的，%eax&#x3D;%ebx</span><br><span class="line">   0x08048cad &lt;+93&gt;:	mov    0x14(%esp),%ebx</span><br><span class="line">   0x08048cb1 &lt;+97&gt;:	mov    0x18(%esp),%esi</span><br><span class="line">   0x08048cb5 &lt;+101&gt;:	add    $0x1c,%esp</span><br><span class="line">   0x08048cb8 &lt;+104&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>就是这么个意思，函数用到了递归，我们肯定想不清，于是将函数翻译成C语言代码。</p>
<ul>
<li>翻译成C语言代码，主函数遍历<code>func4</code>第一个参数，如果返回值等于<code>0x15</code>也就是<code>21</code>，那就是正确答案</li>
</ul>
<h5 id="func4转换成C语言："><a href="#func4转换成C语言：" class="headerlink" title="func4转换成C语言："></a><code>func4</code>转换成C语言：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> second, <span class="keyword">int</span> third)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> average = second + (third - second + ((third - second) &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; average) &#123;</span><br><span class="line">		<span class="keyword">return</span> average + <span class="built_in">func4</span>(x, second, average - <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; average) &#123;</span><br><span class="line">		<span class="keyword">return</span> average + <span class="built_in">func4</span>(x, average + <span class="number">1</span>, third);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">func4</span>(i, <span class="number">0</span>, <span class="number">15</span>) == <span class="number">21</span>)</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果如下：<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104004856.png" alt="image-20210501104004856"></li>
<li>所以第四关答案为：<code>6 21</code>，输入验证，输出过关提示语<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104406772.png" alt="image-20210501104406772"></li>
</ul>
<h4 id="phase-5："><a href="#phase-5：" class="headerlink" title="phase_5："></a><code>phase_5</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:</span><br><span class="line">   0x08048d28 &lt;+0&gt;:	sub    $0x2c,%esp</span><br><span class="line">   0x08048d2b &lt;+3&gt;:	    lea    0x1c(%esp),%eax</span><br><span class="line">   0x08048d2f &lt;+7&gt;:	    mov    %eax,0xc(%esp)</span><br><span class="line">   0x08048d33 &lt;+11&gt;:	lea    0x18(%esp),%eax</span><br><span class="line">   0x08048d37 &lt;+15&gt;:	mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048d3b &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)</span><br><span class="line">   0x08048d43 &lt;+27&gt;:	mov    0x30(%esp),%eax</span><br><span class="line">   0x08048d47 &lt;+31&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048d4a &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   &#x2F;&#x2F;scanf函数</span><br><span class="line">   0x08048d4f &lt;+39&gt;:	cmp    $0x1,%eax</span><br><span class="line">   0x08048d52 &lt;+42&gt;:	jg     0x8048d59 &lt;phase_5+49&gt;</span><br><span class="line">   &#x2F;&#x2F;jg大于转移，%eax是传入的参数个数，%eax&gt;1则会跳过爆炸函数</span><br><span class="line">   0x08048d54 &lt;+44&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048d59 &lt;+49&gt;:	mov    0x18(%esp),%eax</span><br><span class="line">   0x08048d5d &lt;+53&gt;:	and    $0xf,%eax</span><br><span class="line">   &#x2F;&#x2F;第一个数 按位与 0xf，将结果存到%eax</span><br><span class="line">   0x08048d60 &lt;+56&gt;:	mov    %eax,0x18(%esp)</span><br><span class="line">   0x08048d64 &lt;+60&gt;:	cmp    $0xf,%eax</span><br><span class="line">   0x08048d67 &lt;+63&gt;:	je     0x8048d93 &lt;phase_5+107&gt;</span><br><span class="line">   &#x2F;&#x2F;如过%eax等于0xf就跳转0x8048d93 &lt;phase_5+107&gt;爆炸，所以%eax不等于0xf</span><br><span class="line">   0x08048d69 &lt;+65&gt;:	mov    $0x0,%ecx</span><br><span class="line">   0x08048d6e &lt;+70&gt;:	mov    $0x0,%edx</span><br><span class="line">   0x08048d73 &lt;+75&gt;:	add    $0x1,%edx</span><br><span class="line">   &#x2F;&#x2F;%edx自加1</span><br><span class="line">   0x08048d76 &lt;+78&gt;:	mov    0x804a240(,%eax,4),%eax</span><br><span class="line">   &#x2F;&#x2F;以%eax为下标的数组元素是下一个元素的下标。</span><br><span class="line">   0x08048d7d &lt;+85&gt;:	add    %eax,%ecx</span><br><span class="line">   &#x2F;&#x2F;%ecx加上每一次的</span><br><span class="line">   0x08048d7f &lt;+87&gt;:	cmp    $0xf,%eax</span><br><span class="line">   0x08048d82 &lt;+90&gt;:	jne    0x8048d73 &lt;phase_5+75&gt;</span><br><span class="line">   &#x2F;&#x2F;%eax不等于0xf时转移到0x8048d73 &lt;phase_5+75&gt;</span><br><span class="line">   0x08048d84 &lt;+92&gt;:	mov    %eax,0x18(%esp)</span><br><span class="line">   0x08048d88 &lt;+96&gt;:	cmp    $0xf,%edx</span><br><span class="line">   0x08048d8b &lt;+99&gt;:	jne    0x8048d93 &lt;phase_5+107&gt;</span><br><span class="line">   &#x2F;&#x2F;%edx不等于0xf时转移到0x8048d93 &lt;phase_5+107&gt;爆炸，所以%edx&#x3D;0xf</span><br><span class="line">   0x08048d8d &lt;+101&gt;:	cmp    0x1c(%esp),%ecx</span><br><span class="line">   0x08048d91 &lt;+105&gt;:	je     0x8048d98 &lt;phase_5+112&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%ecx&#x3D;输入的第二个数，则跳过爆炸函数</span><br><span class="line">   0x08048d93 &lt;+107&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048d98 &lt;+112&gt;:	add    $0x2c,%esp</span><br><span class="line">   0x08048d9b &lt;+115&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还是先看输入，还是两个整数<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104814076.png" alt="image-20210501104814076"></p>
</li>
<li><p>输入一个数组元素的下标存到<code>%eax</code>，将<code>%eax</code>的值作为下一个数组元素的下标,，再一次将<code>%eax</code>等于这个元素值，如果<code>%eax</code>等于<code>0xf</code>结束，一共要进行15次，少一次<code>%edx</code>就不等于<code>0xf</code>就爆炸。</p>
<ul>
<li>我们查看一下这个数组，我们发现<code>0xf</code>元素的下标为6，<code>0x6</code>元素的下标为14，<code>0xe</code>的下标为2。。。。。。<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501113814480.png" alt="image-20210501113814480"></li>
<li>所以得到的序列为：<code>f 6 e 2 1 a 0 8 4 9 d b 7 3 c 5 </code></li>
<li>所以第一个输入是<code>5</code></li>
</ul>
</li>
<li><p>第二个输入等于<code>%ecx</code>，就是所有元素的和少了第一个5，所以是<code>115</code></p>
</li>
<li><p>所以答案是<code>5 115</code>，验证，成功。<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501120859183.png" alt="image-20210501120859183"></p>
</li>
</ul>
<h4 id="phase-6："><a href="#phase-6：" class="headerlink" title="phase_6："></a><code>phase_6</code>：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">   0x08048d9c &lt;+0&gt;:	    push   %esi</span><br><span class="line">   0x08048d9d &lt;+1&gt;:	    push   %ebx</span><br><span class="line">   0x08048d9e &lt;+2&gt;:	    sub    $0x44,%esp</span><br><span class="line">   0x08048da1 &lt;+5&gt;:	    lea    0x10(%esp),%eax</span><br><span class="line">   0x08048da5 &lt;+9&gt;:	    mov    %eax,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F; *0x4(%esp)存着0x10(%esp)</span><br><span class="line">   0x08048da9 &lt;+13&gt;:	mov    0x50(%esp),%eax</span><br><span class="line">   0x08048dad &lt;+17&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F; *(%esp)存着0x50(%esp)</span><br><span class="line">   0x08048db0 &lt;+20&gt;:	call   0x804922b &lt;read_six_numbers&gt;</span><br><span class="line">   &#x2F;&#x2F;读六个数</span><br><span class="line">   0x08048db5 &lt;+25&gt;:	mov    $0x0,%esi</span><br><span class="line">   &#x2F;&#x2F;下标</span><br><span class="line">   0x08048dba &lt;+30&gt;:	mov    0x10(%esp,%esi,4),%eax</span><br><span class="line">   0x08048dbe &lt;+34&gt;:	sub    $0x1,%eax</span><br><span class="line">   0x08048dc1 &lt;+37&gt;:	cmp    $0x5,%eax</span><br><span class="line">   0x08048dc4 &lt;+40&gt;:	jbe    0x8048dcb &lt;phase_6+47&gt;</span><br><span class="line">   &#x2F;&#x2F;6个数字必须介于1~6之间</span><br><span class="line">   0x08048dc6 &lt;+42&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048dcb &lt;+47&gt;:	add    $0x1,%esi</span><br><span class="line">   0x08048dce &lt;+50&gt;:	cmp    $0x6,%esi</span><br><span class="line">   0x08048dd1 &lt;+53&gt;:	je     0x8048dee &lt;phase_6+82&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%esi+1与0x6相等就跳转到0x8048dee &lt;phase_6+82&gt;</span><br><span class="line">   0x08048dd3 &lt;+55&gt;:	mov    %esi,%ebx</span><br><span class="line">   0x08048dd5 &lt;+57&gt;:	mov    0x10(%esp,%ebx,4),%eax</span><br><span class="line">   &#x2F;&#x2F;下一个放到%eax</span><br><span class="line">   0x08048dd9 &lt;+61&gt;:	cmp    %eax,0xc(%esp,%esi,4)</span><br><span class="line">   0x08048ddd &lt;+65&gt;:	jne    0x8048de4 &lt;phase_6+72&gt;</span><br><span class="line">   &#x2F;&#x2F;0x10(%esp,%ebx,4) !&#x3D; 0xc(%esp,%esi,4)就跳过爆炸</span><br><span class="line">   0x08048ddf &lt;+67&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048de4 &lt;+72&gt;:	add    $0x1,%ebx</span><br><span class="line">   &#x2F;&#x2F;ebx+&#x3D;1</span><br><span class="line">   0x08048de7 &lt;+75&gt;:	cmp    $0x5,%ebx</span><br><span class="line">   0x08048dea &lt;+78&gt;:	jle    0x8048dd5 &lt;phase_6+57&gt;</span><br><span class="line">   &#x2F;&#x2F;%ebx&lt;&#x3D;0x5就转移到0x8048dd5 &lt;phase_6+57&gt;,循环检查他们后面数字不能有重复的</span><br><span class="line">   0x08048dec &lt;+80&gt;:	jmp    0x8048dba &lt;phase_6+30&gt;</span><br><span class="line">   &#x2F;*通过观察得到上面表示的是六个输入均小于等于0x6，且不重复*&#x2F;</span><br><span class="line">   0x08048dee &lt;+82&gt;:	lea    0x10(%esp),%eax</span><br><span class="line">   0x08048df2 &lt;+86&gt;:	lea    0x28(%esp),%ebx	</span><br><span class="line">   0x08048df6 &lt;+90&gt;:	mov    $0x7,%ecx</span><br><span class="line">   0x08048dfb &lt;+95&gt;:	mov    %ecx,%edx</span><br><span class="line">   0x08048dfd &lt;+97&gt;:	sub    (%eax),%edx</span><br><span class="line">   0x08048dff &lt;+99&gt;:	mov    %edx,(%eax)</span><br><span class="line">   &#x2F;&#x2F; *(%eax)&#x3D;%edx-*(%eax)&#x3D;0x7-*(%eax)，意思是</span><br><span class="line">   0x08048e01 &lt;+101&gt;:	add    $0x4,%eax</span><br><span class="line">   &#x2F;&#x2F; %eax+&#x3D;0x4，下一个数</span><br><span class="line">   0x08048e04 &lt;+104&gt;:	cmp    %ebx,%eax</span><br><span class="line">   0x08048e06 &lt;+106&gt;:	jne    0x8048dfb &lt;phase_6+95&gt;</span><br><span class="line">   &#x2F;&#x2F;0x28-0x10&#x3D;0x18&#x3D;6*0x4，循环六次</span><br><span class="line">   &#x2F;* 上面就是将这六个数，每个都被7减一下*&#x2F;</span><br><span class="line">   0x08048e08 &lt;+108&gt;:	mov    $0x0,%ebx</span><br><span class="line">   0x08048e0d &lt;+113&gt;:	jmp    0x8048e25 &lt;phase_6+137&gt;</span><br><span class="line">   &#x2F;&#x2F;直接跳转到0x8048e25 &lt;phase_6+137&gt;</span><br><span class="line">   0x08048e0f &lt;+115&gt;:	mov    0x8(%edx),%edx</span><br><span class="line">   0x08048e12 &lt;+118&gt;:	add    $0x1,%eax</span><br><span class="line">   0x08048e15 &lt;+121&gt;:	cmp    %ecx,%eax</span><br><span class="line">   0x08048e17 &lt;+123&gt;:	jne    0x8048e0f &lt;phase_6+115&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%ecx,%eax不相等就跳转循环，每一次eax+1，edx+8</span><br><span class="line">   0x08048e19 &lt;+125&gt;:	mov    %edx,0x28(%esp,%esi,4)</span><br><span class="line">   0x08048e1d &lt;+129&gt;:	add    $0x1,%ebx</span><br><span class="line">   0x08048e20 &lt;+132&gt;:	cmp    $0x6,%ebx</span><br><span class="line">   0x08048e23 &lt;+135&gt;:	je     0x8048e3c &lt;phase_6+160&gt;</span><br><span class="line">   &#x2F;&#x2F;如果ebx等于6跳转到0x8048e3c &lt;phase_6+160&gt;</span><br><span class="line">   0x08048e25 &lt;+137&gt;:	mov    %ebx,%esi</span><br><span class="line">   0x08048e27 &lt;+139&gt;:	mov    0x10(%esp,%ebx,4),%ecx</span><br><span class="line">   0x08048e2b &lt;+143&gt;:	mov    $0x1,%eax</span><br><span class="line">   0x08048e30 &lt;+148&gt;:	mov    $0x804c13c,%edx</span><br><span class="line">   &#x2F;&#x2F;第一个节点的地址为0x804c13c</span><br><span class="line">   0x08048e35 &lt;+153&gt;:	cmp    $0x1,%ecx</span><br><span class="line">   0x08048e38 &lt;+156&gt;:	jg     0x8048e0f &lt;phase_6+115&gt;</span><br><span class="line">   &#x2F;&#x2F;如果%ecx大于1则跳转0x8048e0f &lt;phase_6+115&gt;</span><br><span class="line">   0x08048e3a &lt;+158&gt;:	jmp    0x8048e19 &lt;phase_6+125&gt;</span><br><span class="line">   &#x2F;&#x2F;无条件跳转0x8048e19 &lt;phase_6+125&gt;</span><br><span class="line">   0x08048e3c &lt;+160&gt;:	mov    0x28(%esp),%ebx</span><br><span class="line">   0x08048e40 &lt;+164&gt;:	mov    0x2c(%esp),%eax</span><br><span class="line">   0x08048e44 &lt;+168&gt;:	mov    %eax,0x8(%ebx)</span><br><span class="line">   0x08048e47 &lt;+171&gt;:	mov    0x30(%esp),%edx</span><br><span class="line">   0x08048e4b &lt;+175&gt;:	mov    %edx,0x8(%eax) </span><br><span class="line">   0x08048e4e &lt;+178&gt;:	mov    0x34(%esp),%eax</span><br><span class="line">   0x08048e52 &lt;+182&gt;:	mov    %eax,0x8(%edx)  </span><br><span class="line">   0x08048e55 &lt;+185&gt;:	mov    0x38(%esp),%edx</span><br><span class="line">   0x08048e59 &lt;+189&gt;:	mov    %edx,0x8(%eax)  </span><br><span class="line">   0x08048e5c &lt;+192&gt;:	mov    0x3c(%esp),%eax</span><br><span class="line">   0x08048e60 &lt;+196&gt;:	mov    %eax,0x8(%edx) </span><br><span class="line">   0x08048e63 &lt;+199&gt;:	movl   $0x0,0x8(%eax)</span><br><span class="line">   0x08048e6a &lt;+206&gt;:	mov    $0x5,%esi</span><br><span class="line">   0x08048e6f &lt;+211&gt;:	mov    0x8(%ebx),%eax</span><br><span class="line">   0x08048e72 &lt;+214&gt;:	mov    (%eax),%edx</span><br><span class="line">   &#x2F;&#x2F; %edx &#x3D; *(*0x8(%ebx))</span><br><span class="line">   0x08048e74 &lt;+216&gt;:	cmp    %edx,(%ebx)</span><br><span class="line">   0x08048e76 &lt;+218&gt;:	jge    0x8048e7d &lt;phase_6+225&gt;</span><br><span class="line">   &#x2F;&#x2F;判断第一个数是否大于第二个数，大的话不爆炸</span><br><span class="line">   0x08048e78 &lt;+220&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048e7d &lt;+225&gt;:	mov    0x8(%ebx),%ebx</span><br><span class="line">   0x08048e80 &lt;+228&gt;:	sub    $0x1,%esi</span><br><span class="line">   0x08048e83 &lt;+231&gt;:	jne    0x8048e6f &lt;phase_6+211&gt;</span><br><span class="line">   &#x2F;&#x2F;如果不等于0就跳转</span><br><span class="line">   0x08048e85 &lt;+233&gt;:	add    $0x44,%esp</span><br><span class="line">   0x08048e88 &lt;+236&gt;:	pop    %ebx</span><br><span class="line">   0x08048e89 &lt;+237&gt;:	pop    %esi</span><br><span class="line">   0x08048e8a &lt;+238&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有六个节点的链表，打印，查看<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501183605731.png" alt="image-20210501183605731"></p>
</li>
<li><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">495</td>
<td align="center">476</td>
<td align="center">197</td>
<td align="center">612</td>
<td align="center">890</td>
<td align="center">249</td>
</tr>
</tbody></table>
</li>
<li><p>正确序列：<code>5 4 1 2 6 3</code>，但是因为我们输入的数都要被7减一下，所以正确的答案是：<code>2 3 6 5 1 4</code> </p>
</li>
<li><p>验证<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210502160922650.png" alt="image-20210502160922650"></p>
</li>
</ul>
<h4 id="phase-defused"><a href="#phase-defused" class="headerlink" title="phase_defused"></a><code>phase_defused</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_defused:</span><br><span class="line">   0x0804927b &lt;+0&gt;:	sub    $0x8c,%esp</span><br><span class="line">   0x08049281 &lt;+6&gt;:	mov    %gs:0x14,%eax</span><br><span class="line">   &#x2F;&#x2F;传了一个int 0x14给eax</span><br><span class="line">   0x08049287 &lt;+12&gt;:	mov    %eax,0x7c(%esp)</span><br><span class="line">   &#x2F;&#x2F;将上面的int存入esp+0x7c</span><br><span class="line">   0x0804928b &lt;+16&gt;:	xor    %eax,%eax</span><br><span class="line">   &#x2F;&#x2F;eax&#x3D;0</span><br><span class="line">   0x0804928d &lt;+18&gt;:	cmpl   $0x6,0x804c3cc</span><br><span class="line">   0x08049294 &lt;+25&gt;:	jne    0x8049308 &lt;phase_defused+141&gt;</span><br><span class="line">   &#x2F;&#x2F; *0x804c3cc要等于0x6才能进入隐藏关卡，也就是要进入第六关之后才能进入隐藏关卡</span><br><span class="line">   0x08049296 &lt;+27&gt;:	lea    0x2c(%esp),%eax</span><br><span class="line">   0x0804929a &lt;+31&gt;:	mov    %eax,0x10(%esp)</span><br><span class="line">   0x0804929e &lt;+35&gt;:	lea    0x28(%esp),%eax</span><br><span class="line">   0x080492a2 &lt;+39&gt;:	mov    %eax,0xc(%esp)</span><br><span class="line">   0x080492a6 &lt;+43&gt;:	lea    0x24(%esp),%eax</span><br><span class="line">   0x080492aa &lt;+47&gt;:	mov    %eax,0x8(%esp)</span><br><span class="line">   0x080492ae &lt;+51&gt;:	movl   $0x804a3e9,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;&quot;%d %d %s&quot;</span><br><span class="line">   0x080492b6 &lt;+59&gt;:	movl   $0x804c4d0,(%esp)</span><br><span class="line">   &#x2F;&#x2F;input_string+240，这个地址在某一关被赋值</span><br><span class="line">   0x080492bd &lt;+66&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x080492c2 &lt;+71&gt;:	cmp    $0x3,%eax</span><br><span class="line">   0x080492c5 &lt;+74&gt;:	jne    0x80492fc &lt;phase_defused+129&gt;</span><br><span class="line">   &#x2F;&#x2F;scanf的参数要等于0x3，才能进入隐藏关卡</span><br><span class="line">   0x080492c7 &lt;+76&gt;:	movl   $0x804a3f2,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;0x804a3f2:	 &quot;DrEvil&quot;</span><br><span class="line">   0x080492cf &lt;+84&gt;:	lea    0x2c(%esp),%eax</span><br><span class="line">   0x080492d3 &lt;+88&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x080492d6 &lt;+91&gt;:	call   0x8048fe4 &lt;strings_not_equal&gt;</span><br><span class="line">   0x080492db &lt;+96&gt;:	test   %eax,%eax</span><br><span class="line">   &#x2F;&#x2F;字符串相同返回值为0</span><br><span class="line">   0x080492dd &lt;+98&gt;:	jne    0x80492fc &lt;phase_defused+129&gt;</span><br><span class="line">   &#x2F;&#x2F;两个字符串相等才能进入隐藏关卡</span><br><span class="line">   0x080492df &lt;+100&gt;:	movl   $0x804a2b8,(%esp)</span><br><span class="line">   &#x2F;&#x2F;0x804a2b8:	 &quot;Curses, you&#39;ve found the secret phase!&quot;</span><br><span class="line">   0x080492e6 &lt;+107&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x080492eb &lt;+112&gt;:	movl   $0x804a2e0,(%esp)</span><br><span class="line">   &#x2F;&#x2F;0x804a2e0:	 &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">   0x080492f2 &lt;+119&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x080492f7 &lt;+124&gt;:	call   0x8048edc &lt;secret_phase&gt;</span><br><span class="line">   &#x2F;&#x2F;隐藏的关卡</span><br><span class="line">   0x080492fc &lt;+129&gt;:	movl   $0x804a318,(%esp)</span><br><span class="line">   &#x2F;&#x2F;0x804a318:	 &quot;Congratulations! You&#39;ve defused the bomb!&quot;</span><br><span class="line">   0x08049303 &lt;+136&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x08049308 &lt;+141&gt;:	mov    0x7c(%esp),%eax</span><br><span class="line">   0x0804930c &lt;+145&gt;:	xor    %gs:0x14,%eax</span><br><span class="line">   0x08049313 &lt;+152&gt;:	je     0x804931a &lt;phase_defused+159&gt;</span><br><span class="line">   0x08049315 &lt;+154&gt;:	call   0x80487d0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0804931a &lt;+159&gt;:	add    $0x8c,%esp</span><br><span class="line">   0x08049320 &lt;+165&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一下炸弹拆除函数汇编代码，发现<code>0x080492f7 &lt;+124&gt;:    call   0x8048edc &lt;secret_phase&gt;</code>隐藏关卡</li>
<li><code>$0x804c4d0</code>这个地址的字符串如果等于内置的<code>DeEvil</code>，我们才能进入隐藏关卡<ul>
<li>但是这个地址什么时候被赋值的呢，我们进行调试，调试发现它是在第四关被赋值的，所以我们要将<code>DrEvil</code>放在第四关<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503173426765.png" alt="image-20210503173426765"></li>
<li>放进之后我们成功触发了隐藏关<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503173643070.png" alt="image-20210503173643070"></li>
</ul>
</li>
</ul>
<h5 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a><code>secret_phase</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function secret_phase:</span><br><span class="line">   0x08048edc &lt;+0&gt;:	push   %ebx</span><br><span class="line">   0x08048edd &lt;+1&gt;:	    sub    $0x18,%esp</span><br><span class="line">   0x08048ee0 &lt;+4&gt;:	    call   0x804911d &lt;read_line&gt;</span><br><span class="line">   0x08048ee5 &lt;+9&gt;:	    movl   $0xa,0x8(%esp)</span><br><span class="line">   &#x2F;&#x2F;传参10</span><br><span class="line">   0x08048eed &lt;+17&gt;:	movl   $0x0,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;传参0</span><br><span class="line">   0x08048ef5 &lt;+25&gt;:	mov    %eax,(%esp)</span><br><span class="line">   &#x2F;&#x2F;传参输入的内容</span><br><span class="line">   0x08048ef8 &lt;+28&gt;:	call   0x80488e0 &lt;strtol@plt&gt;</span><br><span class="line">   &#x2F;&#x2F;将字符串变成int 10进制</span><br><span class="line">   0x08048efd &lt;+33&gt;:	mov    %eax,%ebx</span><br><span class="line">   0x08048eff &lt;+35&gt;:	lea    -0x1(%eax),%eax</span><br><span class="line">   0x08048f02 &lt;+38&gt;:	cmp    $0x3e8,%eax</span><br><span class="line">   &#x2F;&#x2F; *%eax&lt;&#x3D;1000</span><br><span class="line">   0x08048f07 &lt;+43&gt;:	jbe    0x8048f0e &lt;secret_phase+50&gt;</span><br><span class="line">   0x08048f09 &lt;+45&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048f0e &lt;+50&gt;:	mov    %ebx,0x4(%esp)</span><br><span class="line">   0x08048f12 &lt;+54&gt;:	movl   $0x804c088,(%esp)</span><br><span class="line">   &#x2F;&#x2F;该地址的值为0x24十进制就是36</span><br><span class="line">   0x08048f19 &lt;+61&gt;:	call   0x8048e8b &lt;fun7&gt;</span><br><span class="line">   0x08048f1e &lt;+66&gt;:	cmp    $0x5,%eax</span><br><span class="line">   &#x2F;&#x2F;返回值要等于5</span><br><span class="line">   0x08048f21 &lt;+69&gt;:	je     0x8048f28 &lt;secret_phase+76&gt;</span><br><span class="line">   0x08048f23 &lt;+71&gt;:	call   0x80490f6 &lt;explode_bomb&gt;</span><br><span class="line">   0x08048f28 &lt;+76&gt;:	movl   $0x804a1e8,(%esp)</span><br><span class="line">   &#x2F;&#x2F; 0x804a1e8:	 &quot;Wow! You&#39;ve defused the secret stage!&quot;</span><br><span class="line">   0x08048f2f &lt;+83&gt;:	call   0x8048800 &lt;puts@plt&gt;</span><br><span class="line">   0x08048f34 &lt;+88&gt;:	call   0x804927b &lt;phase_defused&gt;</span><br><span class="line">   0x08048f39 &lt;+93&gt;:	add    $0x18,%esp</span><br><span class="line">   0x08048f3c &lt;+96&gt;:	pop    %ebx</span><br><span class="line">   0x08048f3d &lt;+97&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>我们看到调用了<code>&lt;fun7&gt;</code>，<code>%eax</code>如果等于5我们就能成功拆除炸弹</li>
<li>查看<code>fun7</code>函数</li>
</ul>
<h5 id="fun7"><a href="#fun7" class="headerlink" title="fun7"></a><code>fun7</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function fun7:</span><br><span class="line">   0x08048e8b &lt;+0&gt;:	push   %ebx</span><br><span class="line">   0x08048e8c &lt;+1&gt;:	sub    $0x18,%esp</span><br><span class="line">   0x08048e8f &lt;+4&gt;:	    mov    0x20(%esp),%edx</span><br><span class="line">   &#x2F;&#x2F; %edx存的是0x24 36</span><br><span class="line">   0x08048e93 &lt;+8&gt;:	    mov    0x24(%esp),%ecx</span><br><span class="line">   &#x2F;&#x2F;另一个参数</span><br><span class="line">   0x08048e97 &lt;+12&gt;:	test   %edx,%edx</span><br><span class="line">   0x08048e99 &lt;+14&gt;:	je     0x8048ed2 &lt;fun7+71&gt;</span><br><span class="line">   &#x2F;&#x2F;非空不跳继续</span><br><span class="line">   0x08048e9b &lt;+16&gt;:	mov    (%edx),%ebx</span><br><span class="line">   &#x2F;&#x2F; %ebx&#x3D;36</span><br><span class="line">   0x08048e9d &lt;+18&gt;:	cmp    %ecx,%ebx</span><br><span class="line">   0x08048e9f &lt;+20&gt;:	jle    0x8048eb4 &lt;fun7+41&gt;</span><br><span class="line">   &#x2F;&#x2F;36 &lt;&#x3D; 另一个参数</span><br><span class="line">   0x08048ea1 &lt;+22&gt;:	mov    %ecx,0x4(%esp)</span><br><span class="line">   0x08048ea5 &lt;+26&gt;:	mov    0x4(%edx),%eax</span><br><span class="line">   &#x2F;&#x2F;地址加1*4</span><br><span class="line">   0x08048ea8 &lt;+29&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048eab &lt;+32&gt;:	call   0x8048e8b &lt;fun7&gt;</span><br><span class="line">   &#x2F;&#x2F;递归</span><br><span class="line">   0x08048eb0 &lt;+37&gt;:	add    %eax,%eax</span><br><span class="line">   &#x2F;&#x2F; %eax&#x3D;2*%eax</span><br><span class="line">   0x08048eb2 &lt;+39&gt;:	jmp    0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   &#x2F;&#x2F;直接跳转结束</span><br><span class="line">   0x08048eb4 &lt;+41&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x08048eb9 &lt;+46&gt;:	cmp    %ecx,%ebx</span><br><span class="line">   0x08048ebb &lt;+48&gt;:	je     0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   &#x2F;&#x2F;36 与另一个参数 相等则跳转结束,返回0</span><br><span class="line">   0x08048ebd &lt;+50&gt;:	mov    %ecx,0x4(%esp)</span><br><span class="line">   &#x2F;&#x2F;36 &gt; 另一个参数</span><br><span class="line">   0x08048ec1 &lt;+54&gt;:	mov    0x8(%edx),%eax</span><br><span class="line">   &#x2F;&#x2F;地址加2*4</span><br><span class="line">   0x08048ec4 &lt;+57&gt;:	mov    %eax,(%esp)</span><br><span class="line">   0x08048ec7 &lt;+60&gt;:	call   0x8048e8b &lt;fun7&gt;</span><br><span class="line">   0x08048ecc &lt;+65&gt;:	lea    0x1(%eax,%eax,1),%eax</span><br><span class="line">   &#x2F;&#x2F;%eax&#x3D;2*%eax+1</span><br><span class="line">   0x08048ed0 &lt;+69&gt;:	jmp    0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   0x08048ed2 &lt;+71&gt;:	mov    $0xffffffff,%eax</span><br><span class="line">   &#x2F;&#x2F;返回值为-1</span><br><span class="line">   0x08048ed7 &lt;+76&gt;:	add    $0x18,%esp</span><br><span class="line">   0x08048eda &lt;+79&gt;:	pop    %ebx</span><br><span class="line">   0x08048edb &lt;+80&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果小于，乘2加1  ，地址加8；如果大于，乘2，地址加4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fun7(node* addr, int input)&#123;</span><br><span class="line">     if(addr&#x3D;&#x3D;null)  return -1;</span><br><span class="line">     if(*addr &lt;&#x3D; input)&#123;</span><br><span class="line">           if(*addr &#x3D;&#x3D; input ) return 0;</span><br><span class="line">           else 2*fun7(*addr+8,input)+1;</span><br><span class="line">     &#125;</span><br><span class="line">	else 2*fun7(*addr+4,input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>逆向推导：0-&gt;1-&gt;2-&gt;5，所以地址变化：加8、加4、加8，依次查看，答案是<code>0x2f=47</code><br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503163503472.png" alt="image-20210503163503472"></p>
</li>
<li><p>这个过程其实是：47比36大，47比50小，47比45大，47等于47<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503181401052.png" alt="image-20210503181401052"></p>
</li>
<li><p>完成验证<br><img src="/2021/04/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503160027467.png" alt="image-20210503160027467"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>bomb lab</code>这个实验让我对<code>gdb</code>调试更加熟悉，对于汇编代码不至于每一个都要去查，这实验还是很有用处的。</p>
<p>问题总是出现在函数的参数、各种跳转上，其实还是对寄存器、内存地址以及栈帧的认识不够，还需继续努力。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——基础知识</title>
    <url>/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——基础知识"><a href="#深入理解计算机系统——基础知识" class="headerlink" title="深入理解计算机系统——基础知识"></a>深入理解计算机系统——基础知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了方便我查询一些我可能会忘记的基础知识，我写下这篇博客</p>
<p>中间可能有自己的一些经验看法</p>
<p>以下的知识没有先后顺序，用时特定自查</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210503221648779.png" alt="image-20210503221648779"></p>
<p><code>EAX</code> 是”累加器”(accumulator)，它是很多<strong>加法乘法</strong>指令的<strong>缺省寄存器</strong>。</p>
<p><code>EBX</code> 是”基地址”(base)寄存器，在<strong>内存寻址</strong>时存放<strong>基地址</strong>。</p>
<p><code>ECX</code> 是计数器(counter)，是重复(<strong>REP</strong>)前缀指令和<strong>LOOP</strong>指令的<strong>内定计数器</strong>。</p>
<p><code>EDX </code>则总是被用来放<strong>整数除法</strong>产生的<strong>余数</strong>。</p>
<p><code>ESI/EDI</code> 分别叫做”源/目标索引寄存器”(source/destination index)，因为在很多<strong>字符串操作</strong>指令中，<code>DS:ESI</code>指向<strong>源串</strong>,而<code>ES:EDI</code>指向<strong>目标串</strong>.</p>
<p><code>EBP</code> 是”基址指针”(BASE POINTER)，它最经常被用作高级语言函数调用的”<strong>框架指针</strong>“(frame pointer)， 在破解的时候,经常可以看见一个标准的函数起始代码（左为目标寄存器）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ebp ;保存当前ebp</span><br><span class="line">mov ebp,esp ;EBP设为当前堆栈指针</span><br><span class="line">sub esp, xxx ;预留xxx字节给函数临时变量.</span><br></pre></td></tr></table></figure>

<p><code>ESP</code> 专门用作堆栈指针，被形象地称为<strong>栈顶指针</strong>，堆栈的顶部是地址小的区域，压入堆栈的数据越多，<strong>ESP也就越来越小</strong>。在<strong>32位系统</strong>中，<code>ESP</code><strong>每次减少4字节</strong>。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——课程作业2</title>
    <url>/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——课程作业2"><a href="#深入理解计算机系统——课程作业2" class="headerlink" title="深入理解计算机系统——课程作业2"></a>深入理解计算机系统——课程作业2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>五一放假还有作业。。。</p>
<p>课程作业2共有三个题，都是分析汇编代码</p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H ?  <span class="comment">//定义常数H   //H=37</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> J ?  <span class="comment">//定义常数J   //J=16</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[H][J]; </span><br><span class="line"><span class="keyword">int</span> array2[J][H]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    array1[x][y] = x+<span class="number">2</span>*y;</span><br><span class="line">    array2[y][x] = y-x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Ubuntu 32位</code>系统下经过<code>gcc</code>汇编后，得到的函数f汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f:</span><br><span class="line">pushl     %ebp            &#x2F;&#x2F;ebp入栈</span><br><span class="line">movl     %esp, %ebp       &#x2F;&#x2F;ebp设为现在的栈指针</span><br><span class="line">pushl     %ebx            &#x2F;&#x2F;ebx入栈</span><br><span class="line">movl     8(%ebp), %ecx    &#x2F;&#x2F;ecx&#x3D; M(8+ebp)&#x3D;x</span><br><span class="line">movl     12(%ebp), %edx   &#x2F;&#x2F;edx&#x3D; M(12+ebp)&#x3D;y</span><br><span class="line">movl     12(%ebp), %eax   &#x2F;&#x2F;eax&#x3D; M(12+ebp)&#x3D;y</span><br><span class="line">addl     %eax, %eax       &#x2F;&#x2F;eax&#x3D;2*eax&#x3D;2*y</span><br><span class="line">addl     8(%ebp), %eax    &#x2F;&#x2F;eax&#x3D; M(8+ebp)+eax&#x3D;x+2*y</span><br><span class="line">sall     $4, %ecx         &#x2F;&#x2F;ecx&#x3D;ecx*16&#x3D;16*x</span><br><span class="line">leal     (%ecx,%edx), %edx  &#x2F;&#x2F;edx&#x3D; ecx+edx &#x3D;16*x+y,so J&#x3D;16</span><br><span class="line">movl     %eax, array1(,%edx,4)   &#x2F;&#x2F;array1[edx]&#x3D;eax</span><br><span class="line">movl     12(%ebp), %edx   &#x2F;&#x2F;edx&#x3D;M(12+ebp)&#x3D;y</span><br><span class="line">movl     8(%ebp), %ebx    &#x2F;&#x2F;ebx&#x3D;M(8+ebp)&#x3D;x</span><br><span class="line">movl     8(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;M(8+ebp)&#x3D;x</span><br><span class="line">imull     8(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;eax*M(8+ebp)&#x3D;x*x</span><br><span class="line">movl     12(%ebp), %ecx    &#x2F;&#x2F;ecx&#x3D;M(12+ebp)&#x3D;y</span><br><span class="line">subl     %eax, %ecx       &#x2F;&#x2F;ecx&#x3D;ecx-eax&#x3D;y-x*x</span><br><span class="line">movl     %edx, %eax       &#x2F;&#x2F;eax&#x3D;edx&#x3D;y</span><br><span class="line">sall     $3, %eax          &#x2F;&#x2F;eax&#x3D;eax*8&#x3D;8*y</span><br><span class="line">addl     %edx, %eax       &#x2F;&#x2F;eax&#x3D;eax+edx&#x3D;8*y+y</span><br><span class="line">sall     $2, %eax         &#x2F;&#x2F;eax&#x3D;eax*4&#x3D;9*y*4</span><br><span class="line">addl     %edx, %eax       &#x2F;&#x2F;eax&#x3D;edx+eax&#x3D;36*y+y</span><br><span class="line">addl     %ebx, %eax        &#x2F;&#x2F;eax&#x3D;ebx+eax&#x3D;37*y+x,so H&#x3D;37</span><br><span class="line">movl     %ecx, array2(,%eax,4)   &#x2F;&#x2F;array2[eax]&#x3D;ecx&#x3D;y-x*x</span><br><span class="line">popl     %ebx              &#x2F;&#x2F;ebx出栈</span><br><span class="line">popl     %ebp              &#x2F;&#x2F;ebp出栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请分析每一行汇编代码的意义，并给出常数<code>H</code>和<code>J</code>的值。（20.0分）</p>
<p><code>gcc</code>得到的汇编代码验证：</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A2/image-20210504170911346.png" alt="image-20210504170911346"></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>如下为一个c语言程序中的函数及其在32位系统下编译得到的汇编语言程序代码，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aprod</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y, z;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; （  <span class="number">1</span>  ）; （  <span class="number">2</span>  ）) &#123;</span><br><span class="line">        （  <span class="number">3</span>  ）;</span><br><span class="line">        （  <span class="number">4</span>  ）;</span><br><span class="line">        （  <span class="number">5</span>  ）;</span><br><span class="line">        （  <span class="number">6</span>  ）;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">        （  <span class="number">7</span>  ）;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在32位系统中用<code>gcc</code>编译后，函数<code>aprod</code>对应的汇编语言程序代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aprod:</span><br><span class="line">pushl     %ebp           &#x2F;&#x2F;ebp入栈</span><br><span class="line">movl     %esp, %ebp      &#x2F;&#x2F;ebp设为现在的栈指针</span><br><span class="line">subl     $32, %esp       &#x2F;&#x2F;esp&#x3D;esp-32，预留32字节给函数临时变量</span><br><span class="line">movl     $1, -20(%ebp)   &#x2F;&#x2F;r&#x3D;M(ebp-20)&#x3D;1</span><br><span class="line">movl     $0, -4(%ebp)    &#x2F;&#x2F;i&#x3D;M(ebp-4)&#x3D;0</span><br><span class="line">jmp      .l2             &#x2F;&#x2F;跳转到.l2</span><br><span class="line"></span><br><span class="line">.l3:</span><br><span class="line">movl     -4(%ebp), %eax  &#x2F;&#x2F;eax&#x3D;M(ebp-4)&#x3D;i</span><br><span class="line">sall     $2, %eax        &#x2F;&#x2F;eax&#x3D;eax*4&#x3D;i*4</span><br><span class="line">addl     8(%ebp), %eax   &#x2F;&#x2F;eax&#x3D;eax+M(8+ebp)&#x3D;4i+a[]</span><br><span class="line">movl     (%eax), %eax    &#x2F;&#x2F;eax&#x3D;M(eax)</span><br><span class="line">movl     %eax, -8(%ebp)  &#x2F;&#x2F;x&#x3D;M(ebp-8)&#x3D;eax</span><br><span class="line">movl     -4(%ebp), %eax  &#x2F;&#x2F;eax&#x3D;M(ebp-4)</span><br><span class="line">addl     $1, %eax        &#x2F;&#x2F;eax&#x3D;eax+1</span><br><span class="line">sall     $2, %eax        &#x2F;&#x2F;eax&#x3D;eax*4</span><br><span class="line">addl     8(%ebp), %eax   &#x2F;&#x2F;eax&#x3D;M(8+ebp)</span><br><span class="line">movl     (%eax), %eax    &#x2F;&#x2F;eax&#x3D;M(eax)</span><br><span class="line">movl     %eax, -12(%ebp) &#x2F;&#x2F;M(ebp-12)&#x3D;eax</span><br><span class="line">movl     -4(%ebp), %eax  &#x2F;&#x2F;eax&#x3D;(ebp-4)</span><br><span class="line">addl     $2, %eax        &#x2F;&#x2F;eax&#x3D;eax+2</span><br><span class="line">sall     $2, %eax         &#x2F;&#x2F;eax&#x3D;eax*4</span><br><span class="line">addl     8(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;eax+M(8+ebp)</span><br><span class="line">movl     (%eax), %eax     &#x2F;&#x2F;eax&#x3D;M(eax)</span><br><span class="line">movl     %eax, -16(%ebp)  &#x2F;&#x2F;M(-16+ebp)&#x3D;eax</span><br><span class="line">movl     -20(%ebp), %eax  &#x2F;&#x2F;eax&#x3D;M(-20+ebp)</span><br><span class="line">imull     -8(%ebp), %eax  &#x2F;&#x2F;eax*&#x3D;M(-8+ebp)</span><br><span class="line">imull     -12(%ebp), %eax &#x2F;&#x2F;eax*&#x3D;M(-12+ebp)</span><br><span class="line">imull     -16(%ebp), %eax  &#x2F;&#x2F;eax*&#x3D;M(-16+ebp)</span><br><span class="line">movl     %eax, -20(%ebp)  &#x2F;&#x2F;M(-20+ebp)&#x3D;eax</span><br><span class="line">addl     $3, -4(%ebp)     &#x2F;&#x2F;M(-4+ebp)+&#x3D;3</span><br><span class="line"></span><br><span class="line">.l2:</span><br><span class="line">movl     12(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;M(12+ebp)&#x3D;n</span><br><span class="line">subl     $2, %eax          &#x2F;&#x2F;eax&#x3D;eax-2</span><br><span class="line">cmpl     -4(%ebp), %eax    &#x2F;&#x2F;compare eax&#x3D; with M(ebp-4)&#x3D;i</span><br><span class="line">jg       .l3               &#x2F;&#x2F;eax &gt; M(ebp-4)&#x3D;i则跳转.l3</span><br><span class="line">jmp      .l4               &#x2F;&#x2F;无条件跳转.l4,也就是小于等于i时跳转</span><br><span class="line"></span><br><span class="line">.l5:</span><br><span class="line">movl     -4(%ebp), %eax   &#x2F;&#x2F;eax&#x3D;M(-4+ebp)&#x3D;i</span><br><span class="line">sall     $2, %eax         &#x2F;&#x2F;eax&#x3D;eax*4</span><br><span class="line">addl     8(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;eax+M(8+ebp)</span><br><span class="line">movl     (%eax), %eax     &#x2F;&#x2F;eax&#x3D;M(eax)</span><br><span class="line">movl     -20(%ebp), %edx   &#x2F;&#x2F;edx&#x3D;M(-20+ebp)&#x3D;r</span><br><span class="line">imull     %edx, %eax      &#x2F;&#x2F;eax&#x3D;eax*edx</span><br><span class="line">movl     %eax, -20(%ebp)   &#x2F;&#x2F;r&#x3D;M(-20+ebp)&#x3D;eax</span><br><span class="line">addl     $1, -4(%ebp)      &#x2F;&#x2F;i&#x3D;M(-4+ebp)&#x3D;1</span><br><span class="line"></span><br><span class="line">.l4:</span><br><span class="line">movl     -4(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;M(-4+ebp)</span><br><span class="line">cmpl     12(%ebp), %eax    &#x2F;&#x2F;compare eax with M(12+ebp)</span><br><span class="line">jl       .l5               &#x2F;&#x2F;eax &lt; M(12+ebp)则跳转</span><br><span class="line">movl     -20(%ebp), %eax   &#x2F;&#x2F;eax&#x3D;M(-20+ebp)</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请详细说明每条汇编语句的意义，并将这个函数补充完整。（40.0分）</p>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>如下为一个c语言程序中的函数及其在32位系统下编译得到的汇编语言程序代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incl  ude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frac</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;           </span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">2</span>) <span class="keyword">return</span> ______;           <span class="comment">//a*a</span></span><br><span class="line">    <span class="keyword">return</span> _______;                  <span class="comment">//frac(a-2)+a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c= ______;                  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ______;                  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">10</span>,j=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> k=sum(_______,______);       <span class="comment">//int k=sum(j-i,i++);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frac:</span><br><span class="line">pushl  %ebp             &#x2F;&#x2F;ebp入栈</span><br><span class="line">movl  %esp, %ebp        &#x2F;&#x2F;ebp&#x3D;esp，设为当前的栈指针</span><br><span class="line">subl  $24, %esp         &#x2F;&#x2F;esp&#x3D;esp-24，预留24字节给临时变量</span><br><span class="line">cmpl  $1, 8(%ebp)       &#x2F;&#x2F;compare a&#x3D;M(8+ebp) with 1</span><br><span class="line">jg    .l2                &#x2F;&#x2F;a&#x3D;M(8+ebp) &gt; 1则跳转到.l2</span><br><span class="line">movl  8(%ebp), %eax      &#x2F;&#x2F;eax&#x3D;M(8+ebp)&#x3D;a</span><br><span class="line">imull  8(%ebp), %eax     &#x2F;&#x2F;eax*&#x3D;M(8+ebp)&#x3D;a*a</span><br><span class="line">jmp   .l3                 &#x2F;&#x2F;无条件跳转.l3</span><br><span class="line"></span><br><span class="line">.l2:</span><br><span class="line">movl  8(%ebp), %eax      &#x2F;&#x2F;eax&#x3D;M(8+ebp)&#x3D;a</span><br><span class="line">subl  $2, %eax           &#x2F;&#x2F;eax&#x3D;eax-2&#x3D;a-2</span><br><span class="line">movl  %eax, (%esp)        &#x2F;&#x2F;M(esp)&#x3D;eax&#x3D;a-2</span><br><span class="line">call  frac               &#x2F;&#x2F;递归fun(a-2)</span><br><span class="line">addl  8(%ebp), %eax       &#x2F;&#x2F;eax&#x3D;eax+M(8+ebp)&#x3D;fun(a-2)+a</span><br><span class="line"></span><br><span class="line">.l3:</span><br><span class="line">leave              &#x2F;&#x2F;函数结束</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum:</span><br><span class="line">pushl  %ebp              &#x2F;&#x2F;ebp入栈</span><br><span class="line">movl  %esp, %ebp         &#x2F;&#x2F;ebp&#x3D;esp,设为现在的栈指针</span><br><span class="line">subl  $40, %esp          &#x2F;&#x2F;esp&#x3D;esp-40,预留40字节给临时变量</span><br><span class="line">movl  12(%ebp), %eax     &#x2F;&#x2F;eax&#x3D;M(ebp+12)</span><br><span class="line">movl  8(%ebp), %edx      &#x2F;&#x2F;edx&#x3D;M(ebp+8)</span><br><span class="line">addl  %edx, %eax         &#x2F;&#x2F;eax&#x3D;eax+edx</span><br><span class="line">movl  %eax, (%esp)       &#x2F;&#x2F;M(esp)&#x3D;eax</span><br><span class="line">call  frac               &#x2F;&#x2F;调用frac函数</span><br><span class="line">movl  %eax, -12(%ebp)    &#x2F;&#x2F;M(ebp-12)&#x3D;eax</span><br><span class="line">movl  -12(%ebp), %eax    &#x2F;&#x2F;eax&#x3D;M(ebp-12)</span><br><span class="line">addl  %eax, %eax         &#x2F;&#x2F;eax&#x3D;2*eax</span><br><span class="line">addl  12(%ebp), %eax     &#x2F;&#x2F;eax&#x3D;eax+M(ebp+12)</span><br><span class="line">leave</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">pushl  %ebp           &#x2F;&#x2F;ebp入栈</span><br><span class="line">movl  %esp, %ebp      &#x2F;&#x2F;ebp设为现在的栈指针</span><br><span class="line">andl  $-16, %esp      &#x2F;&#x2F;esp&#x3D;esp &amp;&amp; 0xfffffff0</span><br><span class="line">subl  $32, %esp       &#x2F;&#x2F;esp&#x3D;esp-32,预留32位字节给临时变量</span><br><span class="line">movl  $10, 20(%esp)   &#x2F;&#x2F;i&#x3D;M(20+esp)&#x3D;10</span><br><span class="line">movl  $6, 24(%esp)    &#x2F;&#x2F;j&#x3D;M(24+esp)&#x3D;6</span><br><span class="line">movl  20(%esp), %eax  &#x2F;&#x2F;eax&#x3D;M(20+esp)&#x3D;i</span><br><span class="line">movl  24(%esp), %edx  &#x2F;&#x2F;edx&#x3D;M(24+esp)&#x3D;j</span><br><span class="line">subl  %eax, %edx       &#x2F;&#x2F;edx&#x3D;edx-eax&#x3D;j-i&#x3D;-4</span><br><span class="line">movl  20(%esp), %eax   &#x2F;&#x2F;eax&#x3D;M(20+esp)&#x3D;i&#x3D;10</span><br><span class="line">addl  $1, 20(%esp)     &#x2F;&#x2F;i&#x3D;M(20+esp)&#x3D;M(20+esp)+1&#x3D;11</span><br><span class="line">movl  %edx, 4(%esp)    &#x2F;&#x2F;M(4+esp)&#x3D;edx&#x3D;-4</span><br><span class="line">movl  %eax, (%esp)     &#x2F;&#x2F;M(esp)&#x3D;eax&#x3D;10</span><br><span class="line">call  sum              &#x2F;&#x2F;调用sum函数</span><br><span class="line">movl  %eax, 28(%esp)   &#x2F;&#x2F;k&#x3D;M(28+esp)&#x3D;eax，将sum函数返回值赋给k</span><br><span class="line">movl  $0, %eax         &#x2F;&#x2F;eax&#x3D;0, return 0</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请详细说明每条汇编语句的意义，并将这个函数补充完整。（40.0分）</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
</search>
