<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sung&#39;s Blog</title>
  
  <subtitle>Debug the World</subtitle>
  <link href="https://sun-ruijiang.github.io/atom.xml" rel="self"/>
  
  <link href="https://sun-ruijiang.github.io/"/>
  <updated>2021-04-24T03:54:12.590Z</updated>
  <id>https://sun-ruijiang.github.io/</id>
  
  <author>
    <name>Sung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯法——子集和问题</title>
    <link href="https://sun-ruijiang.github.io/2021/04/24/%E5%9B%9E%E6%BA%AF%E6%B3%95%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://sun-ruijiang.github.io/2021/04/24/%E5%9B%9E%E6%BA%AF%E6%B3%95%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-23T16:00:00.000Z</published>
    <updated>2021-04-24T03:54:12.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>子集和问题的一个实例为<code>&lt;S,t&gt;</code>。</p><p>其中，<code>S=&#123;s1,x2,...,xn&#125;</code>是一个正整数的集合，c是一个正整数。</p><p>子集和问题判定是否存在S的一个子集<code>S1</code>，使得集合中所有元素的和等于c。</p><p>试设计一个解子集和问题的回溯法。</p><h2 id="算法设计："><a href="#算法设计：" class="headerlink" title="算法设计："></a>算法设计：</h2><p>对于给定的正整数集合<code>S=&#123;s1,x2,...,xn&#125;</code>和正整数c，计算S的一个子集，使得子集和为c</p><h2 id="数据输入："><a href="#数据输入：" class="headerlink" title="数据输入："></a>数据输入：</h2><p>由文件<code>input.txt</code>提供输入数据。</p><p>文件第1行有2个整数n和c，n表示S的大小，c是子集和的目标值。</p><p>接下来的1行中，有n个正整数，表示集合S中的元素。</p><h2 id="结果输出："><a href="#结果输出：" class="headerlink" title="结果输出："></a>结果输出：</h2><p>将子集和问题的解输出到文件<code>output.txt</code>。</p><p>当问题无解时，输出“No Solution！”。</p><ul><li>输入文件示例</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.txt</span><br><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure><ul><li>输出文件示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output.txt</span><br><span class="line">2 2 6</span><br></pre></td></tr></table></figure><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ul><li>回溯法的步骤为：<ul><li>修改当前节点状态</li><li>递归子节点状态</li><li>回改当前节点状态</li></ul></li><li><code>backtracking</code>函数：<ul><li>我们将<code>value</code>的值加上当前节点的值，同时添加当前元素到<code>tem</code>数组里。</li><li>递归下一节点，<code>backtracking(i + 1, n, c, S, tem, answer, value);</code></li><li>弹出<code>tem</code>数组刚刚添加的元素，<code>value</code>减去刚才加上的值</li><li>如果<code>value</code>值等于<code>c</code>，那么就添加此时的<code>tem</code>数组到<code>answer</code>二维数组中</li></ul></li><li><code>ssumc</code>函数：<ul><li>如果<code>answer</code>二维数组为空，则返回<code>tem</code>数组</li><li>如果<code>answer</code>不为空，则返回<code>answer</code>数组的第一个元素</li></ul></li><li><code>main</code>函数：<ul><li>从文件输入n、c、S数组</li><li>数组<code>ans</code>等于函数<code>ssumc</code>函数的返回值</li><li>输出数组元素，如果为空，则输出“No Solution！”到文件中</li></ul></li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;outfile.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem,  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ssumc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> c, vector&lt;<span class="keyword">int</span>&gt; S)</span> </span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; answer;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; tem;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">backtracking</span>(i, n, c, S, tem, answer, value);</span><br><span class="line"><span class="keyword">if</span> (!answer.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> answer[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> &amp;c, vector&lt;<span class="keyword">int</span>&gt; S, vector&lt;<span class="keyword">int</span>&gt; &amp;tem, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;answer, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == c) &#123;</span><br><span class="line">answer.<span class="built_in">push_back</span>(tem);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i++) &#123;</span><br><span class="line">tem.<span class="built_in">push_back</span>(S[i]);</span><br><span class="line">value += S[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">backtracking</span>(i + <span class="number">1</span>, n, c, S, tem, answer, value);</span><br><span class="line"></span><br><span class="line">tem.<span class="built_in">pop_back</span>();</span><br><span class="line">value -= S[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line">infile &gt;&gt; n &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tem;</span><br><span class="line">infile &gt;&gt; tem;</span><br><span class="line">S.<span class="built_in">push_back</span>(tem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">ssumc</span>(n, c, S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">outfile &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans.<span class="built_in">empty</span>())</span><br><span class="line">outfile &lt;&lt; <span class="string">&quot;No Soution!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顾名思义，回溯法的核心是回溯。</p><p>在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。</p><p>这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子集和问题&quot;&gt;&lt;a href=&quot;#子集和问题&quot; class=&quot;headerlink&quot; title=&quot;子集和问题&quot;&gt;&lt;/a&gt;子集和问题&lt;/h1&gt;&lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://sun-ruijiang.github.io/categories/Algorithm/"/>
    
    
    <category term="回溯算法" scheme="https://sun-ruijiang.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法——双机调度问题</title>
    <link href="https://sun-ruijiang.github.io/2021/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>https://sun-ruijiang.github.io/2021/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%9C%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-04T16:00:00.000Z</published>
    <updated>2021-04-15T14:52:07.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h3><p>用2台处理机<code>A</code>和<code>B</code>处理<code>n</code>个作业。设第<code>i</code>个作业交给机器A处理时需要时间<code>ai</code>，若由机器<code>B</code>来处理,则需要时间bi。</p><p>由于各作业的特点和机器的性能关系，很可能对于某些<code>i</code>，有<code>ai ≥ bi</code>，而对于某些<code>j ≠ i</code>，有<code>aj &lt; bj</code>。既不能将一个作业分开由2台机器处理，也没有一台机器能同时处理2个作业。</p><p>研究一个实例:</p><p><code>(a1, a2, a3, a4, a5, a6) = (2, 5, 7, 10, 5, 2)</code></p><p><code>(b1, b2, b3, b4, b5, b6) = (3, 8, 4, 11, 3, 4)</code></p><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h3><p>对于给定的n个作业，找出一个最优调度方案，使<code>A</code>、<code>B</code>两台机器处理完这n个作业的时间最短。</p><h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入:"></a>数据输入:</h3><p>由文件<code>input. txt</code>提供输入数据。</p><p>文件的第1行是1个正整数<code>n</code>,表示要处理<code>n</code>个作业</p><p>在接下来的2行中,每行有n个正整数，分别表示处理机<code>A</code>和<code>B</code>处理第<code>i</code>个作业需要的处理时间。</p><h3 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出:"></a>结果输出:</h3><p>将计算出的最短处理时间输出到文件<code>output txt</code>。</p><ul><li><p>输入文件示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input.txt</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">2 5 7 10 5 2</span><br><span class="line">3 8 4 11 3 4</span><br></pre></td></tr></table></figure></li><li><p>输出文件示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output.txt</span><br><span class="line"></span><br><span class="line">15</span><br></pre></td></tr></table></figure></li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>找出<code>n</code>个任务所有耗时中最大的数<code>m</code>，也就是<code>A</code>和<code>B</code>数组的最大值。</li><li>设置三维布尔量数组<code>p[mn][mn][n]</code>，布尔量<code>p[i][j][k]</code>表示前<code>k</code>个作业可以在处理机<code>A</code>用时不超过<code>i</code>，处理机B不超过<code>j</code>的时间内完成。动态规划算法：<code>p[i][j][k] = p[i-ak][j][k-1] | p[i][j-bk][k-1]</code>（<code>|</code>为按位与运算符）</li><li>由上一步所得的结果我们可以找到时间最短的答案，具体是遍历布尔量为1的<code>k = n</code>的数组，取<code>min(i, j)</code>，如果比前一个小则取这个</li><li>具体算法如下</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream infile ;</span><br><span class="line">infile.<span class="built_in">open</span>( <span class="string">&quot;input.txt&quot;</span> ) ;</span><br><span class="line">infile &gt;&gt; n ;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line">b = <span class="keyword">new</span> <span class="keyword">int</span>[n] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">infile &gt;&gt; a[i] ;</span><br><span class="line">m = <span class="built_in">max</span>( a[i] , m ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">infile &gt;&gt; b[i] ;</span><br><span class="line">m = <span class="built_in">max</span>( b[i] , m ) ;</span><br><span class="line">&#125;</span><br><span class="line">mn = m * n ;</span><br><span class="line"></span><br><span class="line">infile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dyna</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span>*** p = <span class="keyword">new</span> <span class="keyword">bool</span>** [mn+<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="keyword">new</span> <span class="keyword">bool</span>* [mn+<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">&#123;</span><br><span class="line">p[i][j] = <span class="keyword">new</span> <span class="keyword">bool</span> [n+<span class="number">1</span>] ;</span><br><span class="line">p[i][j][<span class="number">0</span>] = <span class="literal">true</span> ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">&#123;</span><br><span class="line">p[i][j][k] = <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= mn ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i - a[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i-a[k<span class="number">-1</span>]][j][k<span class="number">-1</span>] ;</span><br><span class="line"><span class="keyword">if</span>( j - b[k<span class="number">-1</span>] &gt;= <span class="number">0</span> ) p[i][j][k] = p[i][j][k] || p[i][j-b[k<span class="number">-1</span>]][k<span class="number">-1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> opt = mn ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= mn ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> j= <span class="number">0</span> ; j &lt;= mn ; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( p[i][j][n] )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">max</span>( i , j ) ;</span><br><span class="line"><span class="keyword">if</span>( tmp &lt; opt ) opt = tmp ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ofstream outfile ;</span><br><span class="line">outfile.<span class="built_in">open</span>( <span class="string">&quot;output.txt&quot;</span> ) ;</span><br><span class="line">outfile &lt;&lt; opt &lt;&lt; endl ;</span><br><span class="line"> outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>() ;</span><br><span class="line"><span class="built_in">dyna</span>() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述算法的时间复杂度为<code>O(m2n3) </code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述:&quot;&gt;&lt;/a&gt;问题描述:&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://sun-ruijiang.github.io/categories/Algorithm/"/>
    
    
    <category term="Dynamic programming" scheme="https://sun-ruijiang.github.io/tags/Dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>hexo写作——我的第一篇博客</title>
    <link href="https://sun-ruijiang.github.io/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sun-ruijiang.github.io/2021/04/04/hexo%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-04-03T16:00:00.000Z</published>
    <updated>2021-04-15T15:04:46.733Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大体上建好了网站，现在我们来学习一下如何在<code>hexo</code>上写作，并同步你的第一篇文章到GitHub上</p></blockquote><h2 id="现在开始"><a href="#现在开始" class="headerlink" title="现在开始"></a>现在开始</h2><h3 id="创建一篇博客"><a href="#创建一篇博客" class="headerlink" title="创建一篇博客"></a>创建一篇博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &lt;My New Post&gt;</span><br></pre></td></tr></table></figure><p>如果不想使用命令行，直接在<code>source/_post</code>文件夹创建即可</p><p>需要注意的是，在文件编写的开头需要加上，<code>title</code>、<code>date</code>、<code>tag</code>、<code>category</code>、<code>author</code>、<code>Topping</code>这几个信息</p><h3 id="打开hexo服务器"><a href="#打开hexo服务器" class="headerlink" title="打开hexo服务器"></a>打开<code>hexo</code>服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>打开一个shell，输入这行命令</p><p>这是为了在本地观察渲染后的博客网站，显示一个<code>http://localhost:4000</code>网址，可以再这里观察网站变化</p><h3 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --watch</span><br></pre></td></tr></table></figure><p>打开另一个shell，输入命令·</p><p>如果不输入这行命令，网页是不会变化的，需要不断重复打开</p><p>输入命令后，我们可以刷新网页以更新变化，也可以在shell中看到网站的改变</p><h3 id="部署到GitHub仓库"><a href="#部署到GitHub仓库" class="headerlink" title="部署到GitHub仓库"></a>部署到GitHub仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>部署命令·，可能出错，如果出现<code>SSL Connection</code>错误，就是因为网络不好</p><p>再次输入部署命令就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;大体上建好了网站，现在我们来学习一下如何在&lt;code&gt;hexo&lt;/code&gt;上写作，并同步你的第一篇文章到GitHub上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;现在开始&quot;&gt;&lt;a href=&quot;#现在开始&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Others" scheme="https://sun-ruijiang.github.io/categories/Others/"/>
    
    
    <category term="hexo" scheme="https://sun-ruijiang.github.io/tags/hexo/"/>
    
    <category term="tutorial" scheme="https://sun-ruijiang.github.io/tags/tutorial/"/>
    
  </entry>
  
</feed>
